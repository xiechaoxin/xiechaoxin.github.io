<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>操作系统小总结-王道 - xcx</title><meta name="description" content=""><meta property="og:title" content="操作系统小总结-王道" />
<meta property="og:description" content="操作系统小总结 目录 第一章 计算机系统概述 1.1操作系统 第二章 进程管理 2.1进程和线程 2.2调度 2.3互斥同步 2.4死锁 第三章 内存管理 3.1内存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiechaoxin.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E6%80%BB%E7%BB%93-%E7%8E%8B%E9%81%93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-17T17:59:12+00:00" />
<meta property="article:modified_time" content="2022-06-17T17:59:12+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统小总结-王道"/>
<meta name="twitter:description" content="操作系统小总结 目录 第一章 计算机系统概述 1.1操作系统 第二章 进程管理 2.1进程和线程 2.2调度 2.3互斥同步 2.4死锁 第三章 内存管理 3.1内存"/>
<meta name="application-name" content="xcx">
<meta name="apple-mobile-web-app-title" content="xcx"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xiechaoxin.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E6%80%BB%E7%BB%93-%E7%8E%8B%E9%81%93/" /><link rel="prev" href="https://xiechaoxin.github.io/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/blog_cut/mysql/some-thoughts-on-database-storage-time/" /><link rel="next" href="https://xiechaoxin.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" /><link rel="stylesheet" href="/css/page.min.css"><link rel="stylesheet" href="/css/home.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "操作系统小总结-王道",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xiechaoxin.github.io\/posts\/os\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E6%80%BB%E7%BB%93-%E7%8E%8B%E9%81%93\/"
        },"genre": "posts","keywords": "OS","wordcount":  9583 ,
        "url": "https:\/\/xiechaoxin.github.io\/posts\/os\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E6%80%BB%E7%BB%93-%E7%8E%8B%E9%81%93\/","datePublished": "2022-06-17T17:59:12+00:00","dateModified": "2022-06-17T17:59:12+00:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"author": {
                "@type": "Person",
                "name": "作者"
            },"description": ""
    }
    </script></head><body data-header-desktop="" data-header-mobile=""><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xcx">xcx</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xcx">xcx</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><div class="menu-item"><a href="#" onclick="return false;" class="theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div></div>
    </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single" data-toc="disable"><div class="single-card" ><h2 class="single-title animated flipInX">操作系统小总结-王道</h2><div class="post-meta">
                <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-category">出版于  <a href="/categories/os/"><i class="far fa-folder fa-fw"></i>OS</a></span></div>
                <div class="post-meta-line"><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-06-17">2022-06-17</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 9583 字</span>&nbsp;
                    <span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 20 分钟</span>&nbsp;</div>
            </div>
            
            <hr><div class="details toc" id="toc-static"  data-kept="">
                    <div class="details-summary toc-title">
                        <span>目录</span>
                        <span><i class="details-icon fas fa-angle-right"></i></span>
                    </div>
                    <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-第一章-概述">1 第一章 概述</a></li>
    <li><a href="#2-第二章-进程管理">2 第二章 进程管理</a></li>
    <li><a href="#3-第三章-内存管理">3 第三章 内存管理</a></li>
    <li><a href="#4-第四章-文件管理">4 第四章 文件管理</a></li>
    <li><a href="#5-第五章-io管理">5 第五章 I/O管理</a></li>
  </ul>

  <ul>
    <li><a href="#6-目的为什么要有操作系统拿来干嘛管理什么">6 目的：为什么要有操作系统，拿来干嘛？管理什么？</a>
      <ul>
        <li><a href="#61-思想有什么底层思想支撑操作系统的开发">6.1 思想：有什么底层思想支撑操作系统的开发？</a></li>
        <li><a href="#62-历史操作系统是怎样一步一步发展起来的">6.2 历史：操作系统是怎样一步一步发展起来的？</a></li>
        <li><a href="#63-组成操作系统运行机制靠什么实现的">6.3 组成：操作系统运行机制，靠什么实现的？</a></li>
        <li><a href="#64-操作由底层思想可以延伸出什么基本操作">6.4 操作：由底层思想可以延伸出什么基本操作？</a></li>
        <li><a href="#65-状态操作系统在运行过程中有哪些状态">6.5 状态：操作系统在运行过程中有哪些状态？</a></li>
        <li><a href="#66-结构操作系统的结构和位于计算机哪个位置">6.6 结构：操作系统的结构，和位于计算机哪个位置？</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#7-进程和线程">7 进程和线程</a>
      <ul>
        <li><a href="#71-进程是什么">7.1 进程是什么？</a></li>
        <li><a href="#72-进程的功能有哪些特征实现">7.2 进程的功能有哪些特征实现？</a></li>
        <li><a href="#73-进程的状态有哪些怎么转换">7.3 进程的状态有哪些，怎么转换？</a></li>
        <li><a href="#74-进程是怎样控制的">7.4 进程是怎样控制的？</a></li>
        <li><a href="#75-进程由什么组成组织方式有哪些">7.5 进程由什么组成，组织方式有哪些？</a></li>
        <li><a href="#76-进程间怎么通信">7.6 进程间怎么通信？</a></li>
        <li><a href="#77-线程是什么和进程有什么不一样">7.7 线程是什么和进程有什么不一样？</a></li>
        <li><a href="#78-线程有哪些多线程有哪些">7.8 线程有哪些，多线程有哪些？</a></li>
      </ul>
    </li>
    <li><a href="#8-调度">8 调度</a>
      <ul>
        <li><a href="#81-调度是什么有哪些">8.1 调度是什么，有哪些？</a></li>
        <li><a href="#82-调度的使用时机在哪">8.2 调度的使用时机在哪？</a></li>
        <li><a href="#83-调度的方式有哪些">8.3 调度的方式有哪些？</a></li>
        <li><a href="#84-调度的基本准则是什么">8.4 调度的基本准则是什么？</a></li>
        <li><a href="#85-加入调度后进程的基本状态多了什么">8.5 加入调度后进程的基本状态多了什么？</a></li>
        <li><a href="#86-典型调度算法有哪些">8.6 典型调度算法有哪些？</a></li>
      </ul>
    </li>
    <li><a href="#9-互斥同步">9 互斥同步</a>
      <ul>
        <li><a href="#91-临界资源">9.1 临界资源</a></li>
        <li><a href="#92-同步">9.2 同步</a></li>
        <li><a href="#93-互斥">9.3 互斥</a></li>
        <li><a href="#94-信号量机制">9.4 信号量机制</a></li>
        <li><a href="#95-管程">9.5 管程</a></li>
      </ul>
    </li>
    <li><a href="#10-死锁">10 死锁</a>
      <ul>
        <li><a href="#101-定义">10.1 定义</a></li>
        <li><a href="#102-原因和必要条件">10.2 原因和必要条件</a></li>
        <li><a href="#103-预防">10.3 预防</a></li>
        <li><a href="#104-避免">10.4 避免</a></li>
        <li><a href="#105-检测和解除">10.5 检测和解除</a></li>
      </ul>
    </li>
    <li><a href="#11-信号量机制的各种问题应用">11 信号量机制的各种问题应用</a>
      <ul>
        <li><a href="#111-生产者消费者问题">11.1 生产者消费者问题</a></li>
        <li><a href="#112-多生产者多消费者问题">11.2 多生产者多消费者问题</a></li>
        <li><a href="#113-吸烟者问题">11.3 吸烟者问题</a></li>
        <li><a href="#114-读者-写者问题">11.4 读者-写者问题</a></li>
        <li><a href="#115-哲学家问题">11.5 哲学家问题</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#12-内存管理概念">12 内存管理概念</a>
      <ul>
        <li><a href="#121-为什么要有内存管理">12.1 为什么要有内存管理？</a></li>
        <li><a href="#122-内存管理的功能是什么">12.2 内存管理的功能是什么？</a></li>
        <li><a href="#123-程序是怎么装入和链接的">12.3 程序是怎么装入和链接的？</a></li>
        <li><a href="#124-动态分区分配">12.4 动态分区分配</a></li>
        <li><a href="#125-分页">12.5 分页</a></li>
        <li><a href="#126-分段">12.6 分段</a></li>
      </ul>
    </li>
    <li><a href="#13-虚拟内存管理">13 虚拟内存管理</a>
      <ul>
        <li><a href="#131-虚拟内存管理与传统存储管理的不同在哪">13.1 虚拟内存管理与传统存储管理的不同在哪？</a></li>
        <li><a href="#132-什么是局部性原理">13.2 什么是局部性原理？</a></li>
        <li><a href="#133-虚拟内存是怎样实现的">13.3 虚拟内存是怎样实现的？</a></li>
        <li><a href="#134-有哪些页面置换法">13.4 有哪些页面置换法？</a></li>
        <li><a href="#135-有哪些页面分配策略">13.5 有哪些页面分配策略？</a></li>
        <li><a href="#136-抖动">13.6 抖动</a></li>
        <li><a href="#137-工作集">13.7 工作集</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#14-文件管理">14 文件管理</a>
      <ul>
        <li><a href="#141-文件相关概念">14.1 文件相关概念</a></li>
        <li><a href="#142-文件逻辑结构">14.2 文件逻辑结构</a></li>
        <li><a href="#143-目录结构">14.3 目录结构</a></li>
        <li><a href="#144-文件共享">14.4 文件共享</a></li>
        <li><a href="#145-文件保护">14.5 文件保护</a></li>
      </ul>
    </li>
    <li><a href="#15-文件系统的实现">15 文件系统的实现</a>
      <ul>
        <li><a href="#151-文件层结构">15.1 文件层结构</a></li>
        <li><a href="#152-目录实现">15.2 目录实现</a></li>
        <li><a href="#153-文件分配方式">15.3 文件分配方式</a></li>
        <li><a href="#154-文件存储空间管理">15.4 文件存储空间管理</a></li>
      </ul>
    </li>
    <li><a href="#16-磁盘管理">16 磁盘管理</a>
      <ul>
        <li><a href="#161-磁盘结构">16.1 磁盘结构</a></li>
        <li><a href="#162-磁盘调度算法">16.2 磁盘调度算法</a></li>
        <li><a href="#163-磁盘管理">16.3 磁盘管理</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#17-io控制器的主要功能是什么">17 I/O控制器的主要功能是什么？</a></li>
    <li><a href="#18-io有哪些控制方式">18 I/O有哪些控制方式？</a>
      <ul>
        <li><a href="#181-程序直接控制方式">18.1 程序直接控制方式</a></li>
        <li><a href="#182-中断驱动方式">18.2 中断驱动方式</a></li>
        <li><a href="#183-dma方式">18.3 DMA方式</a></li>
        <li><a href="#184-通道控制方式">18.4 通道控制方式</a></li>
        <li><a href="#185-dma与通道的区别">18.5 DMA与通道的区别</a></li>
      </ul>
    </li>
    <li><a href="#19-io有哪些层次结构">19 I/O有哪些层次结构？</a>
      <ul>
        <li><a href="#191-用户层io软件">19.1 用户层IO软件</a></li>
        <li><a href="#192-设备独立性软件">19.2 设备独立性软件</a></li>
        <li><a href="#193-设备驱动程序">19.3 设备驱动程序</a></li>
        <li><a href="#194-中断处理程序">19.4 中断处理程序</a></li>
        <li><a href="#195-硬件设备">19.5 硬件设备</a></li>
      </ul>
    </li>
    <li><a href="#20-核心子系统包含哪些">20 核心子系统包含哪些？</a></li>
    <li><a href="#21-假脱机">21 假脱机</a></li>
    <li><a href="#22-设备的分配与回收">22 设备的分配与回收</a></li>
    <li><a href="#23-缓冲区管理">23 缓冲区管理</a>
      <ul>
        <li><a href="#231-高速缓存与缓冲区对比">23.1 高速缓存与缓冲区对比</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                </div><div class="content" id="content"><h1 id="操作系统小总结">操作系统小总结</h1>
<h1 id="目录">目录</h1>
<p>第一章 计算机系统概述</p>
<p>1.1操作系统</p>
<p>第二章 进程管理</p>
<p>2.1进程和线程</p>
<p>2.2调度</p>
<p>2.3互斥同步</p>
<p>2.4死锁</p>
<p>第三章 内存管理</p>
<p>3.1内存管理概念</p>
<p>3.2虚拟内存管理</p>
<p>第四章 文件管理</p>
<p>4.1文件管理</p>
<p>4.2磁盘管理</p>
<p>第五章 输入输出管理(IO)</p>
<p>5.1输入输出管理(IO)</p>
<hr>
<h2 id="1-第一章-概述">1 第一章 概述</h2>
<p>操作系统在干嘛，底层思想</p>
<h2 id="2-第二章-进程管理">2 第二章 进程管理</h2>
<p>操作系统的最大作用，核心功能</p>
<h2 id="3-第三章-内存管理">3 第三章 内存管理</h2>
<p>物理地址到逻辑地址的映射，脱离硬件第一步</p>
<h2 id="4-第四章-文件管理">4 第四章 文件管理</h2>
<p>再封装管理各种数据，脱离硬件第二部，到达软件层面</p>
<h2 id="5-第五章-io管理">5 第五章 I/O管理</h2>
<p>联通硬件和软件，捋一下各种功能</p>
<h1 id="第一章-计算机系统概述">第一章 计算机系统概述</h1>
<p>目的：为什么要有操作系统，拿来干嘛？管理什么？</p>
<p>思想：有什么底层思想支撑操作系统的开发？</p>
<p>历史：操作系统是怎样一步一步发展起来的？</p>
<p>组成：操作系统运行机制，靠什么实现的？</p>
<p>操作：由底层思想可以延伸出什么基本操作？</p>
<p>状态：操作系统在运行过程中有哪些状态？</p>
<p>结构：操作系统的结构，和位于计算机哪个位置？</p>
<hr>
<h2 id="6-目的为什么要有操作系统拿来干嘛管理什么">6 目的：为什么要有操作系统，拿来干嘛？管理什么？</h2>
<p>==概念、功能、管理、接口==</p>
<h3 id="61-思想有什么底层思想支撑操作系统的开发">6.1 思想：有什么底层思想支撑操作系统的开发？</h3>
<p>==并发、共享、虚拟、异步、封装==</p>
<h3 id="62-历史操作系统是怎样一步一步发展起来的">6.2 历史：操作系统是怎样一步一步发展起来的？</h3>
<p>==手工操作阶段、单道批处理、多道批处理、分时操作系统、实时操作系统、分布式、个人==</p>
<h3 id="63-组成操作系统运行机制靠什么实现的">6.3 组成：操作系统运行机制，靠什么实现的？</h3>
<p>==内核程序、自编程序、原语、时钟管理、中断机制==</p>
<h3 id="64-操作由底层思想可以延伸出什么基本操作">6.4 操作：由底层思想可以延伸出什么基本操作？</h3>
<p>==中断、异常、系统调用==</p>
<h3 id="65-状态操作系统在运行过程中有哪些状态">6.5 状态：操作系统在运行过程中有哪些状态？</h3>
<p>==用户态、内核态==</p>
<h3 id="66-结构操作系统的结构和位于计算机哪个位置">6.6 结构：操作系统的结构，和位于计算机哪个位置？</h3>
<p>==大内核、微内核、用户、应用程序、非内核功能、进程管理、存储管理、设备管理、时钟管理、中断处理、原语、裸机(纯硬件)==</p>
<h1 id="第二章-进程管理">第二章 进程管理</h1>
<h2 id="7-进程和线程">7 进程和线程</h2>
<p>进程是什么？</p>
<p>进程的功能有哪些特征实现？</p>
<p>进程的状态有哪些，怎么转换？</p>
<p>进程是怎样控制的？</p>
<p>进程由什么组成？</p>
<p>进程间怎么通信？</p>
<p>线程是什么和进程有什么不一样？</p>
<p>线程有哪些，多线程有哪些？</p>
<hr>
<h3 id="71-进程是什么">7.1 进程是什么？</h3>
<p>==实现操作系统的并发性和共享性==</p>
<h3 id="72-进程的功能有哪些特征实现">7.2 进程的功能有哪些特征实现？</h3>
<p>==动态性、并发性、独立性、异步性、结构性==</p>
<h3 id="73-进程的状态有哪些怎么转换">7.3 进程的状态有哪些，怎么转换？</h3>
<p>==运行态、就绪态、阻塞态、创建态、结束态==</p>
<p>==运行态可以返回就绪态，时间片结束==</p>
<h3 id="74-进程是怎样控制的">7.4 进程是怎样控制的？</h3>
<p>==进程创建(PCB)、进程终止(正常结束、异常结束、外界干预)、进程的阻塞和唤醒(阻塞原语、唤醒原语)、进程切换(内核态下完成)==</p>
<h3 id="75-进程由什么组成组织方式有哪些">7.5 进程由什么组成，组织方式有哪些？</h3>
<p>==进程控制块(进程描述信息、进程控制和管理信息、资源分配清单、处理及相关信息)、程序段(CPU执行程序代码段)、数据段(原始数据、中间数据、最终结果)==</p>
<p>==链接方式(PCB组成的队列)、索引方式(索引表)==</p>
<h3 id="76-进程间怎么通信">7.6 进程间怎么通信？</h3>
<p>==共享存储、信息传递(原语)、管道通信(半双工)==</p>
<h3 id="77-线程是什么和进程有什么不一样">7.7 线程是什么和进程有什么不一样？</h3>
<p>==进程是独立调度的基本单位，线程是支援的基本单位==</p>
<h3 id="78-线程有哪些多线程有哪些">7.8 线程有哪些，多线程有哪些？</h3>
<p>==用户级线程、内核级线程==</p>
<p>==多对一(效率高、一堵全堵、不能同时运行在处理机)、一对一(开销大)、多对多(提高并发性，又适当降低开销)==</p>
<h2 id="8-调度">8 调度</h2>
<p>调度是什么，有哪些？</p>
<p>调度的使用时机在哪？</p>
<p>调度的方式有哪些？</p>
<p>调度的基本准则是什么？</p>
<p>加入调度后进程的基本状态变为哪七种？</p>
<p>典型调度算法有哪些？</p>
<hr>
<h3 id="81-调度是什么有哪些">8.1 调度是什么，有哪些？</h3>
<p>==合理的分配处理机==</p>
<p>==作业调度(高级调度，一次)、中级调度(内存调度，进出内存)、进程调度(低级调度，选取就绪队列)==</p>
<h3 id="82-调度的使用时机在哪">8.2 调度的使用时机在哪？</h3>
<p>==不能切换的情况、可以切换的情况==</p>
<h3 id="83-调度的方式有哪些">8.3 调度的方式有哪些？</h3>
<p>==非剥夺调度方式、剥夺调度方式==</p>
<h3 id="84-调度的基本准则是什么">8.4 调度的基本准则是什么？</h3>
<p>==CPU利用率(尽可能忙碌)、系统吞吐量(单位时间内处理的作业数量)、周转时间(作业提交到完成的时间)、等待时间(作业等待处理机的时间)、响应时间(提交到首次响应的时间)==</p>
<h3 id="85-加入调度后进程的基本状态多了什么">8.5 加入调度后进程的基本状态多了什么？</h3>
<p>==就绪挂起、阻塞挂起==</p>
<h3 id="86-典型调度算法有哪些">8.6 典型调度算法有哪些？</h3>
<p>先来先服务(不利于IO繁忙型业务)</p>
<p>短作业优先算法(平均周转时间最短、饥饿)</p>
<p>优先级调度算法(饥饿)</p>
<p>高响应比算法(响应比 =(等待时间+要求服务时间)/ 要求服务时间 = 1 + 等待时间 / 要求服务时间)</p>
<p>时间片轮转法(分时系统)</p>
<p>多级反馈队列调度法(饥饿)</p>
<h2 id="9-互斥同步">9 互斥同步</h2>
<p>临界资源</p>
<p>同步</p>
<p>互斥</p>
<p>信号量机制</p>
<p>管程</p>
<hr>
<h3 id="91-临界资源">9.1 临界资源</h3>
<p>只允许一个进程使用</p>
<h3 id="92-同步">9.2 同步</h3>
<p>直接制约关系，相互合作</p>
<p>==空闲让进、忙则等待、有限等待、让权等待==</p>
<h3 id="93-互斥">9.3 互斥</h3>
<p>间接制约关系，一个访问临界区另一个不能访问</p>
<h3 id="94-信号量机制">9.4 信号量机制</h3>
<p>wait：资源-1、signal：资源+1</p>
<p>两个原语</p>
<p>==互斥信号量mutex、进入区P(申请资源)、退出区V(释放资源)==</p>
<h3 id="95-管程">9.5 管程</h3>
<p>模块化</p>
<h2 id="10-死锁">10 死锁</h2>
<p>定义</p>
<p>原因</p>
<p>策略</p>
<p>预防</p>
<p>避免</p>
<p>检测和解除</p>
<p>区别</p>
<hr>
<h3 id="101-定义">10.1 定义</h3>
<p>资源竞争造成的僵局，没有外力作用无法解除</p>
<h3 id="102-原因和必要条件">10.2 原因和必要条件</h3>
<p>==资源竞争、顺序非法==</p>
<p>==互斥条件、不可剥夺条件、请求并保持条件、循环等待条件(你等我我等你)==</p>
<h3 id="103-预防">10.3 预防</h3>
<p>破坏某一个必要条件</p>
<p>破坏互斥条件(==允许共享使用==)、破坏不可剥夺条件(导致饥饿)、破坏请求并保持条件(==一次申请完==它所需要的全部资源)、破坏循环等待条件(顺序资源分配法)</p>
<h3 id="104-避免">10.4 避免</h3>
<p>银行家算法(只分配给会进入安全状态的程序)</p>
<h3 id="105-检测和解除">10.5 检测和解除</h3>
<p>资源分配图，只要能约掉就不存在死锁。矩形表示资源节点，小圆代表资源数量。</p>
<p>资源==剥夺==法、==撤销==进程法、进程==回退==法</p>
<h2 id="11-信号量机制的各种问题应用">11 信号量机制的各种问题应用</h2>
<p>生产者消费者问题</p>
<p>多生产者多消费者问题</p>
<p>吸烟者问题</p>
<p>读者-写者问题</p>
<p>哲学家问题</p>
<hr>
<h3 id="111-生产者消费者问题">11.1 生产者消费者问题</h3>
<p>==互斥P一定要在同步P之后==</p>
<p>否则会导致：我要放东西通过了，没人占用但满了放不进去，去到消费者，通道被生产者占住了，形成死锁
同步：查看缓存区容量和非空区
互斥：消费者和生产者不能同时使用缓存区</p>
<h3 id="112-多生产者多消费者问题">11.2 多生产者多消费者问题</h3>
<p>互斥：前P后V</p>
<p>同步、前驱：前V后P</p>
<h3 id="113-吸烟者问题">11.3 吸烟者问题</h3>
<p>供应者到抽烟者一一对应，==多个==信号量</p>
<p>抽烟者抽完只有==一种==返回信号</p>
<h3 id="114-读者-写者问题">11.4 读者-写者问题</h3>
<p>写和读，写和写不能同时访问，==但读和读可以同时访问==</p>
<ul>
<li>读优先：==第一个读者先加两把锁，都关上，再打开互斥锁，让其他读者进行访问==</li>
<li>写优先(相对优先)：==第一个读者先加三把锁，都关上，再打开互斥锁和写优先锁，且先打开写优先锁，使只要读者读完就给写==</li>
</ul>
<h3 id="115-哲学家问题">11.5 哲学家问题</h3>
<p>SB问题</p>
<h1 id="第三章-内存管理">第三章 内存管理</h1>
<h2 id="12-内存管理概念">12 内存管理概念</h2>
<p>为什么要有内存管理？</p>
<p>内存管理的功能是什么？</p>
<p>程序是怎么装入和链接的？</p>
<p>动态分区分配</p>
<p>分页</p>
<p>分段</p>
<hr>
<h3 id="121-为什么要有内存管理">12.1 为什么要有内存管理？</h3>
<p>程序执行前需要先放到内存中才能被CPU处理——==缓和CPU与硬盘之间的速度矛盾==</p>
<h3 id="122-内存管理的功能是什么">12.2 内存管理的功能是什么？</h3>
<p>==内存空间的分配与回收、地址转换、内存空间的扩充、存储保护==</p>
<h4 id="1221-分配与回收">12.2.1 分配与回收</h4>
<p>连续分配管理方式：==单一连续分配==(低地址区，单用户、利用率低)、==固定分区分配==(固定划分相等或不等的区、内部碎片、多道程序、利用率低)、==动态分区分配==(根据大小建立分区、分区外部碎片、紧凑技术)</p>
<p>非连续分配管理方式：==分页、分段==</p>
<h4 id="1222-地址转换">12.2.2 地址转换</h4>
<p>绝对装入(单道程序阶段)：无操作系统</p>
<p>可重定位装入(静态重定位)(早期多道批处理阶段)：一次性全部装入，不能在内存中移动)</p>
<p>动态运行时装入(动态重定位)(==现代操作系统==)：==当程序真正执行时才进行转换==</p>
<p>==地址转换过程：逻辑地址-&gt;界地址寄存器-&gt;重定位寄存器-&gt;物理地址==</p>
<h4 id="1223-内存空间的扩充覆盖交换虚拟">12.2.3 内存空间的扩充(覆盖、交换、虚拟)</h4>
<p>覆盖技术：将用户空间分为==一个==固定区和==若干==覆盖区，活跃部分放在==固定区==，即将访问的段放在==覆盖区==。</p>
<p>交换技术：把磁盘空间分为==文件区==和==对换区==两部分，将处于等待状态的程序从内存中转移到辅存，==暂时换出==外存。</p>
<p>覆盖与交换区别：覆盖是在==同一个程序==或进程中的；交换是在==不同进程(或作业)==之间的</p>
<h4 id="1224-内存保护">12.2.4 内存保护</h4>
<p>CPU中设置上、下限寄存器，==判断是否越界==</p>
<p>重定位寄存器(基址寄存器)和界地址寄存器(限长寄存器)：重定位寄存器中包含最小物理地址值，界地址寄存器包含==逻辑地址的最大值==</p>
<h3 id="123-程序是怎么装入和链接的">12.3 程序是怎么装入和链接的？</h3>
<p>步骤：编译(形成若干目标模块)、链接(目标模块与库函数链接)、装入(内存执行)</p>
<p>链接：静态链接(完整可执行)、装入时动态链接(边装入变链接)、运行时动态链接(需要时才链接)</p>
<p>装入：绝对装入(实际内存地址)、可重定位装入(相对地址)、动态运行时装入(需要时才地址转换)</p>
<h3 id="124-动态分区分配">12.4 动态分区分配</h3>
<p>==首次适应算法==(不排序第一个)、==最佳适应算法==(容量递增顺序排列第一个、最多的外部碎片)、==最坏适应算法==(容量递减第一个、减少小碎片、不利于大工程)、==邻近适应算法==(上次结束位置查找，概率相同，所以容易把高地址大分区用完)</p>
<h3 id="125-分页">12.5 分页</h3>
<p>第一步：分好块，在第几块第几个(页号P和页内偏移量W)</p>
<p>第二部：去问一下我的新家在哪，获得新家块(去==页表寄存器==看页表起始地址和判断，查==页表==找到内存块号)</p>
<p>第三步：新家号，在加上偏移量，就算出物理地址(内存块号加页内偏移W得到物理地址)</p>
<p>添加==块表==，直接省略第二步，因为如果有，直接就能查到内存块号</p>
<p>两级列表解决页表必须连续存储的问题</p>
<h3 id="126-分段">12.6 分段</h3>
<p>页是信息的==物理单位==，完全是==系统行为==，对用户是==不可见的==。分页的用户进程地址空间是==一维==的，程序员只需给出一个记忆符即可表示一个==地址==。</p>
<p>段是信息的==逻辑单位==，分段对用户是==可见的==，用户编程时需要显式地给出==段名==。分段的用户进程地址空间是==二维==的，程序员在标识一个地址时，既要给出==段名==，也要给出==段内地址==。</p>
<h2 id="13-虚拟内存管理">13 虚拟内存管理</h2>
<p>虚拟内存管理与传统存储管理的不同在哪？</p>
<p>什么是局部性原理？</p>
<p>虚拟内存是怎样实现的？</p>
<p>有哪些页面置换法？</p>
<p>有哪些页面分配策略？</p>
<p>抖动</p>
<p>工作集</p>
<hr>
<h3 id="131-虚拟内存管理与传统存储管理的不同在哪">13.1 虚拟内存管理与传统存储管理的不同在哪？</h3>
<p>传统：作业必须一次性==全部装入==内存后，才能开始运行，作业装入内存后，==一直驻留在内存中==，任何部分不会被换出。</p>
<p>虚拟：基于局部性原理，程序的一部分装入内存，一部分留在外存，==需要的时候将外存内容调入内存==，就好像产生了一个巨大的内存空间</p>
<p>==多次性(一次作业多次调入)、对换性(换进换出)、虚拟性(大于实际内存)==</p>
<h3 id="132-什么是局部性原理">13.2 什么是局部性原理？</h3>
<h4 id="1321-时间局部性">13.2.1 时间局部性</h4>
<p>一条指令执行后，不就之后指令可能被再次执行，数据被访问后，不久后数据可能再次被访问</p>
<p>原因：程序中存在着大量的==循环操作==</p>
<p>时间局部性通过将==最近使用的指令==和数据存储在==高速缓冲存储器中==</p>
<h4 id="1322-空间局部性">13.2.2 空间局部性</h4>
<p>一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问</p>
<p>原因：指令通常是==顺序存放==，顺序执行的，数据一般也是以向量、数组、表等形式簇聚存储的</p>
<p>空间局部性使用较大的==高速缓存==，将预取机制继承到高速缓存控制逻辑中实现</p>
<h3 id="133-虚拟内存是怎样实现的">13.3 虚拟内存是怎样实现的？</h3>
<p>请求==分页==存储管理、请求==分段==存储管理、==请求段页式==存储管理</p>
<p>一定容量的内存和外存、页表机制(或者段表机制)、中断机制、地址变换机制</p>
<h3 id="134-有哪些页面置换法">13.4 有哪些页面置换法？</h3>
<p>最佳置换算法(OPT)：选择永不使用或者==最长时间内==不再访问的页面进行淘汰，但是现实中是无法预知的</p>
<p>先进先出页面置换算法(FIFO )：优先淘汰==最早进入==的页面，与进程的实际运行规律不匹配</p>
<p>最近最久未使用(LRU )置换算法：选择==最近最长时间==没有被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间</p>
<p>时钟(CLOCK)置换算法：当某页==被访问时，其访问位置为1==。当需要淘汰一个页面时，只需检查页的访问位。==如果是0，就选择该页换出==；==如果是1，则将它置为0==，暂不换出，继续检查下一个页面，若第一轮扫 描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面==最多会经过两轮扫描==)</p>
<p>改进型CLOCK算法：使用位(访问位)的基础上增加==修改位==</p>
<h3 id="135-有哪些页面分配策略">13.5 有哪些页面分配策略？</h3>
<p>固定分配局部置换</p>
<p>可变分配全局置换</p>
<p>可变分配局部置换</p>
<h3 id="136-抖动">13.6 抖动</h3>
<p>==刚换出的页面又要换入内存==</p>
<h3 id="137-工作集">13.7 工作集</h3>
<p>某段时间内，==进程要访问的页面集合==。</p>
<h1 id="第四章-文件管理">第四章 文件管理</h1>
<h2 id="14-文件管理">14 文件管理</h2>
<p>文件相关概念</p>
<p>文件逻辑结构</p>
<p>目录结构</p>
<p>文件共享</p>
<p>文件保护</p>
<p>文件系统的实现</p>
<hr>
<h3 id="141-文件相关概念">14.1 文件相关概念</h3>
<p>数据项、记录、文件</p>
<p>名称、标识符、类型、位置、大小、保护、时间</p>
<p>创建文件、写、读、文件重定位(文件寻址)、删除文件、截断文件</p>
<h3 id="142-文件逻辑结构">14.2 文件逻辑结构</h3>
<p>无结构文件：流式文件，==字符流==组成</p>
<p>有结构文件(记录式文件)：顺序文件(效率高、增删改查难)、索引文件(定长、变长)、索引顺序文件(分组)、直接文件或散列文件(函数转换决定地址)</p>
<h3 id="143-目录结构">14.3 目录结构</h3>
<p>单级目录(不能重名)、两级目录结构(不能分类)、多级目录结构(树形)、无环图目录结构(同一节点有向边，共享)</p>
<h3 id="144-文件共享">14.4 文件共享</h3>
<p>基于索引节点的共享方式(==硬==链接)：直接指针指向文件，只要还有一个指针，文件(索引节点)就==不能删除==
利用符合链实现文件共享(==软==链接)：保存共享文件的路径(==快捷方式==)，根据路径寻找文件。</p>
<h3 id="145-文件保护">14.5 文件保护</h3>
<p>口令保护：用户请求访问时需要提供相应的口令，直接存储在系统内部==不安全==</p>
<p>加密保护：用户访问需要秘钥==解密==，加密和解密需要==花费一定时间==</p>
<p>访问控制：==规定每个用户名及其所允许的访问类型==</p>
<h2 id="15-文件系统的实现">15 文件系统的实现</h2>
<h3 id="151-文件层结构">15.1 文件层结构</h3>
<p>用户调用接口：文件系统==为用户提供==与文件及目录有关的==调用==</p>
<p>文件目录系统：==管理文件目录==，管理活跃文件目录表，管理读写状态信息表，管理用户进程的打开文件表，管理与组织存储设备上的文件目录结构，调用下一级存取控制模块。</p>
<p>存取控制验证：实现==文件保护==，将用户的访问请求与FCB中指示的访问控制权限进行比较，以确认访问的合法性</p>
<p>逻辑文件系统管理文件信息缓冲区：逻辑文件系统与文件信息缓冲区的主要功能是，根据文件的逻辑结构将用户要读写的逻辑记录转换成文件==逻辑结构内的相应块号==</p>
<p>物理文件系统:把逻辑记录所在的相对块号转换成实际的==物理地址==</p>
<p>辅助分配模块：管理辅存空间，负责==分配==辅存空闲空间和==回收==辅存空间</p>
<p>设备管理程序模块：==分配设备==，分配设备读写用缓冲区，磁盘调度，启动设备，处理设备中断，释放设备读写缓冲区，==释放设备==</p>
<h3 id="152-目录实现">15.2 目录实现</h3>
<p>线性表、哈希表</p>
<h3 id="153-文件分配方式">15.3 文件分配方式</h3>
<p>连续分配：每个文件在磁盘上占有一组==连续的块==，磁盘地址定义了磁盘上的一个线性排序。访存1次</p>
<p>链接分配：磁盘块分布在磁盘的任何地方，除最后一个盘块，其他盘块都有指向==下一个盘块的指针==</p>
<p>索引分配：索引分配解决了链接分配不能直接访问的问题，支持==随机访问==</p>
<h3 id="154-文件存储空间管理">15.4 文件存储空间管理</h3>
<p>文件存储设备管理的实质是对空闲块的组织和管理，包括空闲块的组织、分配与回收等问题</p>
<h4 id="1541-空闲表法">15.4.1 空闲表法</h4>
<p>属于连续分配方式，系统为空闲区建立一张空闲盘块表，每个空闲区第一个盘块号，该区的空闲盘块数等信息。</p>
<h4 id="1542-空闲链表法">15.4.2 空闲链表法</h4>
<p>将所有的空闲盘区拉成一条空闲链，根据构成链所有的基本元素不同，可以把链表分成两种形式</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./image-20210818095638474.png"
        data-srcset="./image-20210818095638474.png, ./image-20210818095638474.png 1.5x, ./image-20210818095638474.png 2x"
        data-sizes="auto"
        alt="./image-20210818095638474.png"
        title="image-20210818095638474" /></p>
<p>空闲盘块链：将磁盘上所有空闲空间以盘块为单位拉成一条链</p>
<p>空闲盘区链：将磁盘上所有空闲盘区拉成一条链</p>
<h4 id="1543-位示图法">15.4.3 位示图法</h4>
<p>采用二进制的一位来表示一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应</p>
<h4 id="1544-成组链接法">15.4.4 成组链接法</h4>
<p>UNIX使用，结合了空闲表和空闲链表法克服了表太大的缺点</p>
<p>把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区内则保存另一顺序空闲扇区的地址</p>
<h2 id="16-磁盘管理">16 磁盘管理</h2>
<h3 id="161-磁盘结构">16.1 磁盘结构</h3>
<p>磁盘、磁道(同心圆)、扇区(数据量相同)、盘面、柱面</p>
<p>磁头是否可移动</p>
<p>固定头磁盘∶磁头相对于盘片的径向方向固定</p>
<p>活动头磁盘：每个磁道一个磁头，磁头可以移动</p>
<p>盘片是否可更换</p>
<p>固定盘磁盘∶磁头臂可以来回伸缩定位磁道，磁盘永久固定在磁盘驱动器内</p>
<p>可换盘磁盘∶可以移动和替换</p>
<h3 id="162-磁盘调度算法">16.2 磁盘调度算法</h3>
<h4 id="1621-读写时间组成">16.2.1 读写时间组成</h4>
<p>==寻找时间(寻道时间)TS==：在读/写数据前，将磁头移动到指定磁道所花的时间。</p>
<p>①启动磁头臂是需要时间的。假设耗时为s；</p>
<p>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间TS = s + m*n</p>
<p>==延迟时间TR==：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p>
<p>设磁盘转速为r(单位：转/秒，或转/分)，则平均所需的延迟时间TR = (1/2)*(1/r) = 1/2r</p>
<p>==传输时间Tt==：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。则：传输时间Tt = (1/r) * (b/N) = b/(rN)</p>
<h4 id="1622-先来先服务fcfs">16.2.2 先来先服务(FCFS)</h4>
<p>按照进程请求访问磁盘的先后顺序进行调度</p>
<p>优点：公平实现简单</p>
<p>缺点：适用于少量进程访问，如果进程过多算法更倾向于==随机调度==</p>
<h4 id="1623-最短寻找时间优先sstf">16.2.3 最短寻找时间优先(SSTF)</h4>
<p>选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道</p>
<p>优点：性能强于先来先服务算法</p>
<p>缺点：容易产生==饥饿==现象</p>
<h4 id="1624-扫描算法scan">16.2.4 扫描算法(SCAN)</h4>
<p>在磁头当前==移动方向上==选择与当前磁头所在的磁道距离最近的请求作为下一次服务对象，只有磁头移动到==最外侧磁道的时候才能往内移动==，移动到最内侧磁道的时候才能往外移动，因此也叫电梯算法。</p>
<p>优点：寻道性能好，可以==避免饥饿==现象</p>
<p>缺点：对最近扫描过的区域不公平，访问局部性方面不如FCFS和SSTF好</p>
<h4 id="1625-循环扫描算法c-scan">16.2.5 循环扫描算法(c-SCAN)</h4>
<p>磁头单向移动，回返时直接回到起始端，而不服务任何请求</p>
<h4 id="1626-look与c-look">16.2.6 LOOK与C-LOOK</h4>
<p>在SCAN与C-SCAN算法的基础上规定了查看移动方向上是否有请求，如果没有就不会继续向前移动，而是直接改变方向(LOOK)或者直接回到第一个请求处( C-LOOK)</p>
<h3 id="163-磁盘管理">16.3 磁盘管理</h3>
<h4 id="1631-磁盘初始化">16.3.1 磁盘初始化</h4>
<p>低级格式化：磁盘分扇区，为每个扇区采用特别的数据结构(头、数据区域、尾部组成)，头部含有一些磁盘控制器所使用的信息</p>
<p>进一步格式化处理∶磁盘分区，对物理分区进行==逻辑格式化==(创建文件管理系统)，包括空闲和已分配的空间及一个初始为==空的目录==</p>
<h4 id="1632-引导块">16.3.2 引导块</h4>
<p>计算机启动时运行==自举程序==，初始化CPU寄存器、设备控制器和内存等，然后启动操作系统</p>
<p>组局程序通常保存在ROM中，在ROM中保留很小的自举块，完整的自举程序保存在启动块上拥有启动分区的磁盘称为启动==磁盘或系统磁盘==</p>
<h4 id="1633-坏块">16.3.3 坏块</h4>
<p>无法使用的扇区</p>
<p>对于简单的磁盘，可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查，==标明哪些扇区是坏扇区==，比如：在FAT表上标明</p>
<p>处理方式</p>
<p>简单磁盘：==手动处理==，对坏块进行标记，程序不会使用</p>
<p>复杂磁盘：控制器维护一个==磁盘坏块链表==，同时将一些块作为==备用==，用于替代坏块(扇区备用)</p>
<h1 id="第五章-输入输出管理io">第五章 输入输出管理(IO)</h1>
<p>I/O控制器的主要功能是什么？</p>
<p>I/O有哪些控制方式？</p>
<p>I/O有哪些层次结构？</p>
<p>核心子系统包含哪些？</p>
<p>假脱机</p>
<p>设备的分配与回收</p>
<p>缓冲区管理</p>
<hr>
<h2 id="17-io控制器的主要功能是什么">17 I/O控制器的主要功能是什么？</h2>
<p>接收和识别CPU发出的命令(要有控制寄存器)、向CPU报告设备的状态(状态寄存器)、数据交换(数据寄存器)、地址识别(由I/O逻辑实现)</p>
<h2 id="18-io有哪些控制方式">18 I/O有哪些控制方式？</h2>
<h3 id="181-程序直接控制方式">18.1 程序直接控制方式</h3>
<p>计算机从外部设备读取数据到存储器，每次读一个字的数据，对读入的每个字，CPU都要对外没状态进行==循环检查==，知道确定该字已经在I设备控制器的数据寄存器中。</p>
<p>读写单位：==字==</p>
<p>优点：容易实现，操作简单</p>
<p>缺陷∶CPU高速性和IO设备的低速性的矛盾(降低了CPU的利用率)，CPU和IO设备只能串行工作</p>
<h3 id="182-中断驱动方式">18.2 中断驱动方式</h3>
<p>允许IO设备主动打断CPU的运行并请求服务，进而==解放CPU==，使其向IO控制器发送读命令后可以继续做其他有用的工作</p>
<p>读写单位∶==字==</p>
<p>优点∶比程序直接控制方式有效</p>
<p>缺点：数据的传输必须要经过CPU，仍然后消耗CPU的时间</p>
<h3 id="183-dma方式">18.3 DMA方式</h3>
<p>在IO设备和内存之间开辟直接的数据交换通路，==彻底解放CPU==</p>
<p>读写单位：==数据块==</p>
<p>设备==直接送入内存==</p>
<p>只有当一个或多个数据块开始和结束的时候，CPU才会进行干预</p>
<p>命令/状态寄存器(CR)：用于接收CPU发送的IO命令和有关控制信息或者设备状态</p>
<p>内存地址寄存器(MAR)：数据直接在设备与内存之间交互</p>
<p>数据寄存器(DR)：用于暂存从设备到内存或者从内存到设备的数据</p>
<p>数据计数器(DC) ：存放本次要传送的字(节)数</p>
<h3 id="184-通道控制方式">18.4 通道控制方式</h3>
<p>设置一个专门负责输入/输出的处理机(DMA方式的发展)，实现对一组数块的读写以及相关控制和管理为单位干预</p>
<p>读写单位：==一组块==</p>
<p>优点：有效的提高了系统资源利用率</p>
<p>缺点：实现较为复杂</p>
<h3 id="185-dma与通道的区别">18.5 DMA与通道的区别</h3>
<p>DMA需要==CPU来控制==传输的数据块大小、传输的内存位置、而通道方式中这些信息是由==通道控制==的</p>
<p>DMA控制器对应一台设备与内存传递数据，通道可以控制多态设备与内存的数据交换</p>
<h2 id="19-io有哪些层次结构">19 I/O有哪些层次结构？</h2>
<h3 id="191-用户层io软件">19.1 用户层IO软件</h3>
<p>==实现与用户交互的接口==，用户可以直接调用在用户层提供的，与IO操作有关的==库函数==，对设备进行操作</p>
<h3 id="192-设备独立性软件">19.2 设备独立性软件</h3>
<p>用于实现用户程序与设备驱动器的==统一接口、设备命令、设备保护、差错控制及设备分配与释放==，同时为设备管理与数据传送提供必要的存储空间</p>
<p>设备独立性也称为设备==无关性==，使得应用程序独立于具体使用的物理设备(使用逻辑设备名)</p>
<p>使用逻辑设备名的好处：增加设备分配的灵活性；易于实现IO重定向</p>
<p>主要功能</p>
<p>执行所有设备的公有操作(设备的分配与回收，==逻辑设备名映射为物理设备名==，对设备进行保护，进制用户直接访问设备)，屏蔽设备之间数据交换的速度差异等</p>
<p>向用户层(文件层)提供统一接口∶无论哪种设备，他们向用户提供的==接口都是相同的==</p>
<h3 id="193-设备驱动程序">19.3 设备驱动程序</h3>
<p>与硬件直接相关，负责实现系统==对设备发出的操作命令==，驱动IO设备工作的驱动程序</p>
<h3 id="194-中断处理程序">19.4 中断处理程序</h3>
<p>用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回被中断进程</p>
<h3 id="195-硬件设备">19.5 硬件设备</h3>
<p>IO设备通常包括一个机械部件和一个电子部件</p>
<h2 id="20-核心子系统包含哪些">20 核心子系统包含哪些？</h2>
<p>设备独立性软件、设备驱动程序、中断处理程序</p>
<p>主要提供==IO调度==，缓冲与高速缓存，设备分配与回收，假脱机，设备保护和差错处理</p>
<h2 id="21-假脱机">21 假脱机</h2>
<p>输入进程∶模拟脱机输入时的外围控制机，将用户要求的数据从输入机==通过输入缓冲区送到输入并中==，当CPU需要数据，直接将==输出井中的数据送入内存==</p>
<p>输出进程：模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井中，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备</p>
<p>通俗一点就是，如果设备被占用，我们就先把数据暂存一下，等到设备空闲了就把这些数据输送到设备中</p>
<h2 id="22-设备的分配与回收">22 设备的分配与回收</h2>
<p>―根据用户IO请求分配设备，原则：充分发挥设备的使用效率，避免进程死锁</p>
<h2 id="23-缓冲区管理">23 缓冲区管理</h2>
<p>缓和CPU与IO之间的速度差异矛盾</p>
<p>单缓冲、双缓冲、循环缓冲、缓冲池</p>
<h3 id="231-高速缓存与缓冲区对比">23.1 高速缓存与缓冲区对比</h3>
<h4 id="2311-相同点">23.1.1 相同点</h4>
<p>都介于高速设备和低速设备之间</p>
<h4 id="2312-不同">23.1.2 不同</h4>
<ul>
<li>
<p>存放数据</p>
<p>高速缓存：存放的是低速设备上的某些数据的==复制数据==</p>
<p>缓冲区：存放的是低速设备==传递==给高速设备的数据，这些数据在低速设备上==不一定有备份==，这些数据再从缓冲区传送到高速设备</p>
</li>
<li>
<p>目的</p>
<p>高速缓存∶高速缓存存放的是高速设备==经常要访问==的数据，如高速缓存中数据不在，高速设备就要访问低速设备</p>
<p>高速设备和低速设备的通信都要经过==缓冲区==，==高速设备永远不会去直接访问低速设备==</p>
</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info"><div class="post-info-tag"><span><a href="/tags/os/">OS</a>
                </span></div><div class="post-info-line"><div class="post-info-mod">
                <span>更新于 2022-06-17</span>
            </div><div class="post-info-mod"></div>
        </div></div><div class="post-nav"><a href="/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/blog_cut/mysql/some-thoughts-on-database-storage-time/" class="prev" rel="prev" title="关于数据库中如何存储时间的一点思考"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
            <a href="/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="next" rel="next" title="操作系统常见面试题&amp;知识点总结">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div></article></div>
            </main>
            <footer class="footer"><div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.112.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/khusika/FeelIt" target="_blank" rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a>
        </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/"></a></span></div>
</div>
</footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-chevron-up fa-fw"></i>
            </a></div><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script src="/lib/autocomplete/autocomplete.min.js"></script><script src="/lib/lunr/lunr.min.js"></script><script src="/lib/lunr/lunr.stemmer.support.min.js"></script><script src="/lib/lunr/lunr.zh.min.js"></script><script src="/lib/lazysizes/lazysizes.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body></html>
