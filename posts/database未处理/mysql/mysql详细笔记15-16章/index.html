<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>mysql详细笔记15-16章 - xcx</title><meta name="description" content=""><meta property="og:title" content="mysql详细笔记15-16章" />
<meta property="og:description" content="第15章 存储过程与函数 15.1 存储过程概述 理解 MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiechaoxin.github.io/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B015-16%E7%AB%A0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-17T17:59:12+00:00" />
<meta property="article:modified_time" content="2022-06-17T17:59:12+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mysql详细笔记15-16章"/>
<meta name="twitter:description" content="第15章 存储过程与函数 15.1 存储过程概述 理解 MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程"/>
<meta name="application-name" content="xcx">
<meta name="apple-mobile-web-app-title" content="xcx"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xiechaoxin.github.io/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B015-16%E7%AB%A0/" /><link rel="prev" href="https://xiechaoxin.github.io/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B017-18%E7%AB%A0/" /><link rel="next" href="https://xiechaoxin.github.io/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B013-14%E7%AB%A0/" /><link rel="stylesheet" href="/css/page.min.css"><link rel="stylesheet" href="/css/home.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "mysql详细笔记15-16章",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xiechaoxin.github.io\/posts\/database%E6%9C%AA%E5%A4%84%E7%90%86\/mysql\/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B015-16%E7%AB%A0\/"
        },"genre": "posts","keywords": "database, mysql","wordcount":  17908 ,
        "url": "https:\/\/xiechaoxin.github.io\/posts\/database%E6%9C%AA%E5%A4%84%E7%90%86\/mysql\/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B015-16%E7%AB%A0\/","datePublished": "2022-06-17T17:59:12+00:00","dateModified": "2022-06-17T17:59:12+00:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"author": {
                "@type": "Person",
                "name": "作者"
            },"description": ""
    }
    </script></head><body data-header-desktop="" data-header-mobile=""><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xcx">xcx</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xcx">xcx</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><div class="menu-item"><a href="#" onclick="return false;" class="theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div></div>
    </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single" data-toc="disable"><div class="single-card" ><h2 class="single-title animated flipInX">mysql详细笔记15-16章</h2><div class="post-meta">
                <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-category">出版于  <a href="/categories/database/"><i class="far fa-folder fa-fw"></i>database</a></span></div>
                <div class="post-meta-line"><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-06-17">2022-06-17</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 17908 字</span>&nbsp;
                    <span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 36 分钟</span>&nbsp;</div>
            </div>
            
            <hr><div class="details toc" id="toc-static"  data-kept="">
                    <div class="details-summary toc-title">
                        <span>目录</span>
                        <span><i class="details-icon fas fa-angle-right"></i></span>
                    </div>
                    <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#151-存储过程概述">15.1 存储过程概述</a></li>
  </ul>

  <ul>
    <li><a href="#1-分类">1 分类</a></li>
    <li><a href="#152-创建存储过程">15.2 创建存储过程</a>
      <ul>
        <li><a href="#11-语法分析">1.1 语法分析</a></li>
        <li><a href="#12-代码举例">1.2 代码举例</a></li>
      </ul>
    </li>
    <li><a href="#153-调用存储过程">15.3 调用存储过程</a>
      <ul>
        <li><a href="#13-调用格式">1.3 调用格式</a></li>
        <li><a href="#14-代码举例">1.4 代码举例</a></li>
        <li><a href="#15-如何调试">1.5 如何调试</a></li>
      </ul>
    </li>
    <li><a href="#154-存储函数的使用">15.4 存储函数的使用</a>
      <ul>
        <li><a href="#16-语法分析">1.6 语法分析</a></li>
        <li><a href="#17-调用存储函数">1.7 调用存储函数</a></li>
        <li><a href="#18-代码举例">1.8 代码举例</a></li>
        <li><a href="#19-对比存储函数和存储过程">1.9 对比存储函数和存储过程</a></li>
      </ul>
    </li>
    <li><a href="#155-存储过程和函数的查看修改删除">15.5. 存储过程和函数的查看、修改、删除</a>
      <ul>
        <li><a href="#110-查看">1.10 查看</a></li>
        <li><a href="#111-修改">1.11 修改</a></li>
        <li><a href="#112-删除">1.12 删除</a></li>
      </ul>
    </li>
    <li><a href="#156-关于存储过程使用的争议">15.6 关于存储过程使用的争议</a>
      <ul>
        <li><a href="#113-优点">1.13 优点</a></li>
        <li><a href="#114-缺点">1.14 缺点</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#161-变量">16.1 变量</a>
      <ul>
        <li><a href="#115-系统变量">1.15 系统变量</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#2-用户变量">2 用户变量</a>
      <ul>
        <li><a href="#21-用户变量分类">2.1 用户变量分类</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#3-局部变量">3 局部变量</a></li>
  </ul>

  <ul>
    <li><a href="#4-对比会话用户变量与局部变量">4 对比会话用户变量与局部变量</a></li>
    <li><a href="#162-定义条件与处理程序">16.2 定义条件与处理程序</a>
      <ul>
        <li><a href="#41-案例分析">4.1 案例分析</a></li>
        <li><a href="#42-定义条件">4.2 定义条件</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#5-定义处理程序">5 定义处理程序</a></li>
  </ul>

  <ul>
    <li><a href="#6-案例解决">6 案例解决</a></li>
  </ul>

  <ul>
    <li><a href="#163-流程控制">16.3 流程控制</a></li>
    <li><a href="#7-分支结构之-if">7 分支结构之 IF</a>
      <ul>
        <li><a href="#71-分支结构之-case">7.1 分支结构之 CASE</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#8-循环结构之loop">8 循环结构之LOOP</a>
      <ul>
        <li><a href="#81-循环结构之while">8.1 循环结构之WHILE</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#9-循环结构之repeat">9 循环结构之REPEAT</a>
      <ul>
        <li><a href="#91-跳转语句之leave语句">9.1 跳转语句之LEAVE语句</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#10-跳转语句之iterate语句">10 跳转语句之ITERATE语句</a></li>
    <li><a href="#164-游标">16.4 游标</a>
      <ul>
        <li><a href="#101-什么是游标或光标">10.1 什么是游标(或光标)</a></li>
        <li><a href="#102-使用游标步骤">10.2 使用游标步骤</a></li>
        <li><a href="#103-举例">10.3 举例</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#11-小结">11 小结</a>
      <ul>
        <li><a href="#111-mysql-80的新特性全局变量的持久化">11.1 MySQL 8.0的新特性—全局变量的持久化</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                </div><div class="content" id="content"><h1 id="第15章-存储过程与函数">第15章 存储过程与函数</h1>
<h2 id="151-存储过程概述">15.1 存储过程概述</h2>
<h1 id="理解">理解</h1>
<blockquote>
<p>MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p>
</blockquote>
<blockquote>
<p><strong>含义</strong>：存储过程的英文是 <code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p>
</blockquote>
<blockquote>
<p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
</blockquote>
<blockquote>
<p><strong>好处</strong>：</p>
<ul>
<li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力</li>
<li>减少操作过程中的失误，提高效率</li>
<li>减少网络传输量(客户端不需要把所有的 SQL 语句通过网络发给服务器)</li>
<li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li>
</ul>
</blockquote>
<blockquote>
<p><strong>和视图、函数的对比</strong>：</p>
<ul>
<li>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是<code>虚拟表</code>，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以<code>直接操作底层数据表</code>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</li>
<li>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是<code>没有返回值</code>的。</li>
</ul>
</blockquote>
<h2 id="1-分类">1 分类</h2>
<blockquote>
<p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<ul>
<li>没有参数(无参数无返回)</li>
<li>仅仅带 IN 类型(有参数无返回)</li>
<li>仅仅带 OUT 类型(无参数有返回)</li>
<li>既带 IN 又带 OUT(有参数有返回)</li>
<li>带 INOUT(有参数有返回)</li>
</ul>
<p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个</p>
</blockquote>
<h2 id="152-创建存储过程">15.2 创建存储过程</h2>
<h3 id="11-语法分析">1.1 语法分析</h3>
<pre><code>-- 语法：
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)
[characteristics ...]
BEGIN
	存储过程体
END
</code></pre>
<p>类似于Java中的方法：</p>
<pre><code>修饰符 返回类型 方法名(参数类型 参数名,...){

	方法体;
}
</code></pre>
<p>说明：</p>
<blockquote>
<p>1、参数前面的符号的意思</p>
<ul>
<li><code>IN</code>：当前参数为输入参数，也就是表示入参；</li>
<li>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</li>
<li><code>OUT</code>：当前参数为输出参数，也就是表示出参；</li>
<li>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li>
<li><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</li>
</ul>
</blockquote>
<blockquote>
<p>2、形参类型可以是 MySQL数据库中的任意类型。</p>
</blockquote>
<blockquote>
<p>3、<code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
</blockquote>
<pre><code>LANGUAGE SQL
| [NOT] DETERMINISTIC
| { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
| SQL SECURITY { DEFINER | INVOKER }
| COMMENT 'string'
</code></pre>
<blockquote>
<ul>
<li><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</li>
<li><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</li>
<li><code>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }</code>：指明子程序使用SQL语句的限制。
<ul>
<li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li>
<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li>
<li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li>
<li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
</li>
<li><code>SQL SECURITY { DEFINER | INVOKER }</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。
<ul>
<li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li>
<li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li>
<li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li>
</ul>
</li>
<li><code>COMMENT 'string'</code>：注释信息，可以用来描述存储过程。</li>
</ul>
</blockquote>
<blockquote>
<p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
</blockquote>
<pre><code>1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以(;)号为结束符。
2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。
3. SET：赋值语句，用于对变量进行赋值。
4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。
</code></pre>
<blockquote>
<p>5、需要设置新的结束标记</p>
</blockquote>
<pre><code>DELIMITER 新的结束标记
</code></pre>
<blockquote>
<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。
比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。
当使用DELIMITER命令时，应该避免使用反斜杠(‘\’)字符，因为反斜线是MySQL的转义字符。</p>
</blockquote>
<pre><code>-- 示例：
DELIMITER $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
[characteristics ...]
BEGIN
	sql语句1;
	sql语句2;
END $
</code></pre>
<h3 id="12-代码举例">1.2 代码举例</h3>
<p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p>
<pre><code>DELIMITER $

CREATE PROCEDURE select_all_data()
BEGIN
	SELECT * FROM emps;

END $

DELIMITER ;
</code></pre>
<p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p>
<pre><code>DELIMITER //

CREATE PROCEDURE avg_employee_salary ()
BEGIN
	SELECT AVG(salary) AS avg_salary FROM emps;
END //

DELIMITER ;
</code></pre>
<p>举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p>
<pre><code>CREATE PROCEDURE show_max_salary()
	LANGUAGE SQL
	NOT DETERMINISTIC
	CONTAINS SQL
	SQL SECURITY DEFINER
	COMMENT '查看最高薪资'
	BEGIN
		SELECT MAX(salary) FROM emps;
	END //

DELIMITER ;
</code></pre>
<p>举例4：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</p>
<pre><code>DELIMITER //

CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)
	BEGIN
		SELECT MIN(salary) INTO ms FROM emps;
	END //

DELIMITER ;
</code></pre>
<p>举例5：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))
	BEGIN
		SELECT salary FROM emps WHERE ename = empname;
	END //

DELIMITER ;
</code></pre>
<p>举例6：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)
	BEGIN
		SELECT salary INTO empsalary FROM emps WHERE ename = empname;
	END //

DELIMITER ;
</code></pre>
<p>举例7：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))
	BEGIN
		SELECT ename INTO empname FROM emps
		WHERE eid = (SELECT MID FROM emps WHERE ename=empname);
	END //

DELIMITER ;
</code></pre>
<h2 id="153-调用存储过程">15.3 调用存储过程</h2>
<h3 id="13-调用格式">1.3 调用格式</h3>
<blockquote>
<p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p>
</blockquote>
<pre><code>CALL 存储过程名(实参列表)
</code></pre>
<p><strong>格式：</strong>
1、调用in模式的参数：</p>
<pre><code>CALL sp1('值');
</code></pre>
<p>2、调用out模式的参数：</p>
<pre><code>SET @name;
CALL sp1(@name);
SELECT @name;
</code></pre>
<p>3、调用inout模式的参数：</p>
<pre><code>SET @name=值;
CALL sp1(@name);
SELECT @name;
</code></pre>
<h3 id="14-代码举例">1.4 代码举例</h3>
<p><strong>举例1：</strong></p>
<pre><code>DELIMITER //

CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)
BEGIN
	SELECT COUNT(*) INTO num FROM fruits
	WHERE s_id = sid;
END //

DELIMITER ;
</code></pre>
<p>调用存储过程：</p>
<pre><code>mysql&gt; CALL CountProc (101, @num);
Query OK, 1 row affected (0.00 sec)
</code></pre>
<p>查看返回结果：</p>
<pre><code>mysql&gt; SELECT @num;
</code></pre>
<blockquote>
<p>该存储过程返回了指定 s_id=101 的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查看，返回结果为3。</p>
</blockquote>
<p><strong>举例2</strong>：创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：</p>
<pre><code>DELIMITER //
CREATE PROCEDURE `add_num`(IN n INT)
BEGIN
       DECLARE i INT;
       DECLARE sum INT;

       SET i = 1;
       SET sum = 0;
       WHILE i &lt;= n DO
              SET sum = sum + i;
              SET i = i +1;
       END WHILE;
       SELECT sum;
END //
DELIMITER ;
</code></pre>
<blockquote>
<p>如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。
直接使用 <code>CALL add_num(50);</code>即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和。</p>
</blockquote>
<h3 id="15-如何调试">1.5 如何调试</h3>
<blockquote>
<p>在 MySQL 中，存储过程不像普通的编程语言(比如 VC++、Java 等)那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样<code>逐步推进</code>，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。</p>
</blockquote>
<h2 id="154-存储函数的使用">15.4 存储函数的使用</h2>
<blockquote>
<p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p>
</blockquote>
<h3 id="16-语法分析">1.6 语法分析</h3>
<p>学过的函数：LENGTH、SUBSTR、CONCAT等
语法格式：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...)
RETURNS 返回值类型
[characteristics ...]
BEGIN
	函数体   #函数体中肯定有 RETURN 语句

END
</code></pre>
<blockquote>
<p>说明：</p>
<ul>
<li>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</li>
<li>2、RETURNS type 语句表示函数返回数据的类型；
RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</li>
<li>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li>
<li>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</li>
</ul>
</blockquote>
<h3 id="17-调用存储函数">1.7 调用存储函数</h3>
<blockquote>
<p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是<code>用户自己定义</code>的，而内部函数是MySQL的<code>开发者定义</code>的。</p>
</blockquote>
<pre><code>SELECT 函数名(实参列表)
</code></pre>
<h3 id="18-代码举例">1.8 代码举例</h3>
<p><strong>举例1</strong>：创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p>
<pre><code>DELIMITER //

CREATE FUNCTION email_by_name()
RETURNS VARCHAR(25)
DETERMINISTIC
CONTAINS SQL
BEGIN
	RETURN (SELECT email FROM employees WHERE last_name = 'Abel');
END //

DELIMITER ;
</code></pre>
<p>调用：</p>
<pre><code>SELECT email_by_name();
</code></pre>
<p><strong>举例2</strong>：创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</p>
<pre><code>DELIMITER //

CREATE FUNCTION email_by_id(emp_id INT)
RETURNS VARCHAR(25)
DETERMINISTIC
CONTAINS SQL
BEGIN
	RETURN (SELECT email FROM employees WHERE employee_id = emp_id);
END //

DELIMITER ;
</code></pre>
<p>调用：</p>
<pre><code>SET @emp_id = 102;
SELECT email_by_id(102);
</code></pre>
<p><strong>举例3</strong>：创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p>
<pre><code>DELIMITER //

CREATE FUNCTION count_by_id(dept_id INT)
RETURNS INT
	LANGUAGE SQL
	NOT DETERMINISTIC
	READS SQL DATA
	SQL SECURITY DEFINER
	COMMENT '查询部门平均工资'
BEGIN
	RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);

END //

DELIMITER ;
</code></pre>
<p>调用：</p>
<pre><code>SET @dept_id = 50;
SELECT count_by_id(@dept_id);
</code></pre>
<blockquote>
<p><strong>注意：</strong>
若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p>
<ul>
<li>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</li>
<li>方式2：</li>
</ul>
</blockquote>
<pre><code>mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;
</code></pre>
<h3 id="19-对比存储函数和存储过程">1.9 对比存储函数和存储过程</h3>
<p>关键字</p>
<p>调用语法</p>
<p>返回值</p>
<p>应用场景</p>
<p>存储过程</p>
<p>PROCEDURE</p>
<p>CALL 存储过程()</p>
<p>理解为有0个或多个</p>
<p>一般用于更新</p>
<p>存储函数</p>
<p>FUNCTION</p>
<p>SELECT 函数()</p>
<p>只能是一个</p>
<p>一般用于查询结果为一个值并返回时</p>
<blockquote>
<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作(比如创建表，删除表等)和事务操作，这些功能是存储函数不具备的。</p>
</blockquote>
<h2 id="155-存储过程和函数的查看修改删除">15.5. 存储过程和函数的查看、修改、删除</h2>
<h3 id="110-查看">1.10 查看</h3>
<blockquote>
<p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？
MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。</p>
</blockquote>
<p><strong>1. 使用SHOW CREATE语句查看存储过程和函数的创建信息</strong>
基本语法结构如下：</p>
<pre><code>SHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名
</code></pre>
<p>举例：</p>
<pre><code>SHOW CREATE FUNCTION test_db.CountProc \G
</code></pre>
<p><strong>2. 使用SHOW STATUS语句查看存储过程和函数的状态信息</strong>
基本语法结构如下：</p>
<pre><code>SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']
</code></pre>
<blockquote>
<p>这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。
[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。</p>
</blockquote>
<p>举例：SHOW STATUS语句示例，代码如下：</p>
<pre><code>mysql&gt; SHOW PROCEDURE STATUS LIKE 'SELECT%' \G
*************************** 1. row ***************************
                  Db: test_db
                Name: SelectAllData
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2021-10-16 15:55:07
             Created: 2021-10-16 15:55:07
       Security_type: DEFINER
             Comment:
character_set_client: utf8mb4
collation_connection: utf8mb4_general_ci
  Database Collation: utf8mb4_general_ci
1 row in set (0.00 sec)
</code></pre>
<p><strong>3. 从information_schema.Routines表中查看存储过程和函数的信息</strong></p>
<blockquote>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>
</blockquote>
<pre><code>SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME='存储过程或函数的名' [AND ROUTINE_TYPE = {'PROCEDURE|FUNCTION'}];
</code></pre>
<blockquote>
<p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p>
</blockquote>
<p>举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下：</p>
<pre><code>SELECT * FROM information_schema.Routines
WHERE ROUTINE_NAME='count_by_id'　AND　ROUTINE_TYPE = 'FUNCTION' \G
</code></pre>
<h3 id="111-修改">1.11 修改</h3>
<p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<pre><code>ALTER {PROCEDURE | FUNCTION} 存储过程或函数的名 [characteristic ...]
</code></pre>
<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<pre><code>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
| SQL SECURITY { DEFINER | INVOKER }
| COMMENT 'string'
</code></pre>
<blockquote>
<ul>
<li><code>CONTAINS SQL</code>，表示子程序包含SQL语句，但不包含读或写数据的语句。</li>
<li><code>NO SQL</code>，表示子程序中不包含SQL语句。</li>
<li><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</li>
<li><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句。</li>
<li><code>SQL SECURITY { DEFINER | INVOKER }</code>，指明谁有权限来执行。
<ul>
<li><code>DEFINER</code>，表示只有定义者自己才能够执行。
-<code>INVOKER</code>，表示调用者可以执行。</li>
</ul>
</li>
<li><code>COMMENT 'string'</code>，表示注释信息。</li>
</ul>
</blockquote>
<blockquote>
<p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p>
</blockquote>
<p><strong>举例1：</strong>
修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：</p>
<pre><code>ALTER　PROCEDURE　CountProc
MODIFIES SQL DATA
SQL SECURITY INVOKER ;
</code></pre>
<p>查询修改后的信息：</p>
<pre><code>SELECT specific_name,sql_data_access,security_type
FROM information_schema.`ROUTINES`
WHERE routine_name = 'CountProc' AND routine_type = 'PROCEDURE';
</code></pre>
<blockquote>
<p>结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限(SQL_DATA_ ACCESS)已经变成MODIFIES SQL DATA，安全类型(SECURITY_TYPE)已经变成INVOKER。</p>
</blockquote>
<p><strong>举例2：</strong>
修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码如下：</p>
<pre><code>ALTER　FUNCTION　CountProc
READS SQL DATA
COMMENT 'FIND NAME' ;
</code></pre>
<blockquote>
<p>存储函数修改成功。从查询的结果可以看出，访问数据的权限(SQL_DATA_ACCESS)已经变成READS SQL DATA，函数注释(ROUTINE_COMMENT)已经变成FIND NAME。</p>
</blockquote>
<h3 id="112-删除">1.12 删除</h3>
<p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<pre><code>DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名
</code></pre>
<p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p>
<p>举例：</p>
<pre><code>DROP PROCEDURE CountProc;


DROP FUNCTION CountProc;
</code></pre>
<h2 id="156-关于存储过程使用的争议">15.6 关于存储过程使用的争议</h2>
<blockquote>
<p>尽管存储过程有诸多优点，但是对于存储过程的使用，<strong>一直都存在着很多争议</strong>，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p>
</blockquote>
<h3 id="113-优点">1.13 优点</h3>
<blockquote>
<ul>
<li><strong>1、存储过程可以一次编译多次使用</strong>。存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</li>
<li><strong>2、可以减少开发工作量</strong>。将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</li>
<li><strong>3、存储过程的安全性强</strong>。我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</li>
<li><strong>4、可以减少网络传输量</strong>。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</li>
<li><strong>5、良好的封装性</strong>。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。</li>
</ul>
</blockquote>
<h3 id="114-缺点">1.14 缺点</h3>
<blockquote>
<p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p>
</blockquote>
<blockquote>
<p><strong>阿里开发规范</strong>
【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<blockquote>
<p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<ul>
<li><strong>1、可移植性差</strong>。存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li>
<li><strong>2、调试困难</strong>。只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</li>
<li><strong>3、存储过程的版本管理很困难</strong>。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li>
<li><strong>4、它不适合高并发的场景</strong>。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，<code>增加数据库的压力</code>，显然就不适用了。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>小结</strong>：存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
</blockquote>
<h1 id="第16章-变量流程控制与游标">第16章 变量、流程控制与游标</h1>
<h2 id="161-变量">16.1 变量</h2>
<blockquote>
<p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。
在 MySQL 数据库中，变量分为<code>系统变量</code>以及<code>用户自定义变量</code>。</p>
</blockquote>
<h3 id="115-系统变量">1.15 系统变量</h3>
<h4 id="1151-系统变量分类">1.15.1 系统变量分类</h4>
<blockquote>
<p>变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>(例如my.ini等)中的参数值。大家可以通过网址 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html" target="_blank" rel="noopener noreffer">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</a> 查看MySQL文档的系统变量。</p>
</blockquote>
<blockquote>
<p>系统变量分为全局系统变量(需要添加<code>global</code> 关键字)以及会话系统变量(需要添加 <code>session</code> 关键字)，有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。**如果不写，默认会话级别。**静态变量(在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改)属于特殊的全局系统变量。</p>
</blockquote>
<blockquote>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zmz6aiw6aOb,size_17,color_FFFFFF,t_70,g_se,x_16-20220523012812859.png"
        data-srcset="./watermark%2ctype_d3F5LXplbmhlaQ%2cshadow_50%2ctext_Q1NETiBA6Zmz6aiw6aOb%2csize_17%2ccolor_FFFFFF%2ct_70%2cg_se%2cx_16-20220523012812859.png, ./watermark%2ctype_d3F5LXplbmhlaQ%2cshadow_50%2ctext_Q1NETiBA6Zmz6aiw6aOb%2csize_17%2ccolor_FFFFFF%2ct_70%2cg_se%2cx_16-20220523012812859.png 1.5x, ./watermark%2ctype_d3F5LXplbmhlaQ%2cshadow_50%2ctext_Q1NETiBA6Zmz6aiw6aOb%2csize_17%2ccolor_FFFFFF%2ct_70%2cg_se%2cx_16-20220523012812859.png 2x"
        data-sizes="auto"
        alt="./watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zmz6aiw6aOb,size_17,color_FFFFFF,t_70,g_se,x_16-20220523012812859.png"
        title="在这里插入图片描述" /></p>
<blockquote>
<ul>
<li>全局系统变量针对于所有会话(连接)有效，但<code>不能跨重启</code></li>
<li>会话系统变量仅针对于当前会话(连接)有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
</blockquote>
<blockquote>
<p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
</blockquote>
<h4 id="1152-查看系统变量">1.15.2 查看系统变量</h4>
<ul>
<li><strong>查看所有或部分系统变量</strong></li>
</ul>
<h1 id="查看所有全局变量">查看所有全局变量</h1>
<pre><code>SHOW GLOBAL VARIABLES;
</code></pre>
<h1 id="查看所有会话变量">查看所有会话变量</h1>
<pre><code>SHOW SESSION VARIABLES;
或
SHOW VARIABLES;
</code></pre>
<h1 id="查看满足条件的部分系统变量">查看满足条件的部分系统变量。</h1>
<pre><code>SHOW GLOBAL VARIABLES LIKE '%标识符%';
</code></pre>
<h1 id="查看满足条件的部分会话变量">查看满足条件的部分会话变量</h1>
<pre><code>SHOW SESSION VARIABLES LIKE '%标识符%';


举例:
SHOW GLOBAL VARIABLES LIKE 'admin_%';
</code></pre>
<ul>
<li><strong>查看指定系统变量</strong></li>
</ul>
<blockquote>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>
</blockquote>
<h1 id="查看指定的系统变量的值">查看指定的系统变量的值</h1>
<pre><code>SELECT @@global.变量名;
</code></pre>
<h1 id="查看指定的会话变量的值">查看指定的会话变量的值</h1>
<pre><code>SELECT @@session.变量名;
</code></pre>
<h1 id="或者">或者</h1>
<pre><code>SELECT @@变量名;
</code></pre>
<ul>
<li><strong>修改系统变量的值</strong></li>
</ul>
<blockquote>
<p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：</p>
<ul>
<li>方式1：修改MySQL<code>配置文件</code>，继而修改MySQL系统变量的值(该方法需要重启MySQL服务)</li>
<li>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</li>
</ul>
</blockquote>
<h1 id="为某个系统变量赋值">为某个系统变量赋值</h1>
<h1 id="方式1">方式1：</h1>
<pre><code>SET @@global.变量名=变量值;
</code></pre>
<h1 id="方式2">方式2：</h1>
<pre><code>SET GLOBAL 变量名=变量值;
</code></pre>
<p>​</p>
<h1 id="为某个会话变量赋值">为某个会话变量赋值</h1>
<h1 id="方式1-1">方式1：</h1>
<pre><code>SET @@session.变量名=变量值;
</code></pre>
<h1 id="方式2-1">方式2：</h1>
<pre><code>SET SESSION 变量名=变量值;
</code></pre>
<p>举例：</p>
<pre><code>SELECT @@global.autocommit;
SET GLOBAL autocommit=0;


SELECT @@session.tx_isolation;
SET @@session.tx_isolation='read-uncommitted';


SET GLOBAL max_connections = 1000;
SELECT @@global.max_connections;
</code></pre>
<h2 id="2-用户变量">2 用户变量</h2>
<h3 id="21-用户变量分类">2.1 用户变量分类</h3>
<blockquote>
<p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</li>
</ul>
</blockquote>
<h4 id="211-会话用户变量">2.1.1 会话用户变量</h4>
<ul>
<li>变量的定义</li>
</ul>
<h1 id="方式1或">方式1：“=”或“:=”</h1>
<pre><code>SET @用户变量 = 值;
SET @用户变量 := 值;
</code></pre>
<h1 id="方式2-或-into关键字">方式2：“:=” 或 INTO关键字</h1>
<pre><code>SELECT @用户变量 := 表达式 [FROM 等子句];
SELECT 表达式 INTO @用户变量  [FROM 等子句];
</code></pre>
<ul>
<li>
<p>查看用户变量的值 (查看、比较、运算等)</p>
<p>SELECT @用户变量</p>
</li>
</ul>
<p>举例:</p>
<pre><code>SET @a = 1;

SELECT @a;


SELECT @num := COUNT(*) FROM employees;

SELECT @num;


SELECT AVG(salary) INTO @avgsalary FROM employees;

SELECT @avgsalary;


SELECT @big;  #查看某个未声明的变量时，将得到NULL值
</code></pre>
<h2 id="3-局部变量">3 局部变量</h2>
<blockquote>
<p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量
作用域：仅仅在定义它的 BEGIN … END 中有效
位置：只能放在 BEGIN … END 中，而且只能放在第一句</p>
</blockquote>
<pre><code>BEGIN
</code></pre>
<h1 id="声明局部变量">声明局部变量</h1>
<pre><code>	DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];
	DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];
</code></pre>
<h1 id="为局部变量赋值">为局部变量赋值</h1>
<pre><code>	SET 变量名1 = 值;
	SELECT 值 INTO 变量名2 [FROM 子句];
</code></pre>
<h1 id="查看局部变量的值">查看局部变量的值</h1>
<pre><code>	SELECT 变量1,变量2,变量3;
END
</code></pre>
<ul>
<li>
<p><strong>定义变量</strong></p>
<p>DECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL</p>
</li>
</ul>
<p>举例：</p>
<pre><code>DECLARE　myparam　INT　DEFAULT 100;
</code></pre>
<ul>
<li><strong>变量赋值</strong></li>
</ul>
<p>方式1：一般用于赋简单的值</p>
<pre><code>SET 变量名=值;
SET 变量名:=值;
</code></pre>
<p>方式2：一般用于赋表中的字段值</p>
<pre><code>SELECT 字段名或表达式 INTO 变量名 FROM 表;
</code></pre>
<ul>
<li>
<p><strong>使用变量(查看、比较、运算等)</strong></p>
<p>SELECT 局部变量名;</p>
</li>
</ul>
<p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p>
<pre><code>DELIMITER //

CREATE PROCEDURE set_value()
BEGIN
	DECLARE emp_name VARCHAR(25);
	DECLARE sal DOUBLE(10,2);

	SELECT last_name,salary INTO emp_name,sal
	FROM employees
	WHERE employee_id = 102;

	SELECT emp_name,sal;
END //

DELIMITER ;
</code></pre>
<p>举例2：声明两个变量，求和并打印 (分别使用会话用户变量、局部变量的方式实现)</p>
<h1 id="方式1使用用户变量">方式1：使用用户变量</h1>
<pre><code>SET @m=1;
SET @n=1;
SET @sum=@m+@n;

SELECT @sum;
</code></pre>
<h1 id="方式2使用局部变量">方式2：使用局部变量</h1>
<pre><code>DELIMITER //

CREATE PROCEDURE add_value()
BEGIN
</code></pre>
<h1 id="局部变量">局部变量</h1>
<pre><code>	DECLARE m INT DEFAULT 1;
	DECLARE n INT DEFAULT 3;
	DECLARE SUM INT;

	SET SUM = m+n;
	SELECT SUM;
END //

DELIMITER ;
</code></pre>
<p>举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果。</p>
<h1 id="声明">声明</h1>
<pre><code>DELIMITER //

CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)
BEGIN
</code></pre>
<h1 id="声明局部变量-1">声明局部变量</h1>
<pre><code>	DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;
	DECLARE mgr_id INT;

	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
	SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;
	SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;
	SET dif_salary = mgr_sal - emp_sal;

END //

DELIMITER ;
</code></pre>
<h1 id="调用">调用</h1>
<pre><code>SET @emp_id = 102;
CALL different_salary(@emp_id,@diff_sal);
</code></pre>
<p>​</p>
<h1 id="查看">查看</h1>
<pre><code>SELECT @diff_sal;
</code></pre>
<h2 id="4-对比会话用户变量与局部变量">4 对比会话用户变量与局部变量</h2>
<p>作用域</p>
<p>定义位置</p>
<p>语法</p>
<p>会话用户变量</p>
<p>当前会话</p>
<p>会话的任何地方</p>
<p>加@符号，不用指定类型</p>
<p>局部变量</p>
<p>定义它的BEGIN END中</p>
<p>BEGIN END的第一句话</p>
<p>一般不用加@,需要指定类型</p>
<h2 id="162-定义条件与处理程序">16.2 定义条件与处理程序</h2>
<blockquote>
<p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。
说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
</blockquote>
<h3 id="41-案例分析">4.1 案例分析</h3>
<p>**案例分析：**创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p>
<pre><code>DELIMITER //

CREATE PROCEDURE UpdateDataNoCondition()
	BEGIN
		SET @x = 1;
		UPDATE employees SET email = NULL WHERE last_name = 'Abel';
		SET @x = 2;
		UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';
		SET @x = 3;
	END //

DELIMITER ;
</code></pre>
<p>调用存储过程：</p>
<pre><code>mysql&gt; CALL UpdateDataNoCondition();
ERROR 1048 (23000): Column 'email' cannot be null

mysql&gt; SELECT @x;
+------+
| @x   |
+------+
|   1  |
+------+
1 row in set (0.00 sec)
</code></pre>
<blockquote>
<p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p>
</blockquote>
<h3 id="42-定义条件">4.2 定义条件</h3>
<blockquote>
<p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中。</p>
</blockquote>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<pre><code>DECLARE 错误名称 CONDITION FOR 错误码(或错误条件)
</code></pre>
<blockquote>
<p>错误码的说明：</p>
<ul>
<li><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。
<ul>
<li>MySQL_error_code是数值类型错误代码。</li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
</li>
<li>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，&lsquo;HY000’是sqlstate_value。</li>
<li>例如，在ERROR 1142(42000)中，1142是MySQL_error_code，&lsquo;42000’是sqlstate_value。</li>
</ul>
</blockquote>
<p><strong>举例1</strong>：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。</p>
<h1 id="使用mysql_error_code">使用MySQL_error_code</h1>
<pre><code>DECLARE Field_Not_Be_NULL CONDITION FOR 1048;
</code></pre>
<h1 id="使用sqlstate_value">使用sqlstate_value</h1>
<pre><code>DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';
</code></pre>
<p><strong>举例2</strong>：定义&quot;ERROR 1148(42000)&ldquo;错误，名称为command_not_allowed。</p>
<h1 id="使用mysql_error_code-1">使用MySQL_error_code</h1>
<pre><code>DECLARE command_not_allowed CONDITION FOR 1148;
</code></pre>
<h1 id="使用sqlstate_value-1">使用sqlstate_value</h1>
<pre><code>DECLARE command_not_allowed CONDITION FOR SQLSTATE '42000';
</code></pre>
<h2 id="5-定义处理程序">5 定义处理程序</h2>
<blockquote>
<p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：</p>
</blockquote>
<pre><code>DECLARE 处理方式 HANDLER FOR 错误类型 处理语句
</code></pre>
<blockquote>
<ul>
<li><strong>处理方式</strong>：处理方式有3个取值：CONTINUE、EXIT、UNDO。
<ul>
<li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li>
<li><code>EXIT</code>：表示遇到错误马上退出。</li>
<li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li><strong>错误类型</strong>(即条件)可以有如下取值：
<ul>
<li><code>SQLSTATE '字符串错误码'</code>：表示长度为5的sqlstate_value类型的错误代码；</li>
<li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li>
<li><code>错误名称</code>：表示DECLARE … CONDITION定义的错误条件名称。</li>
<li><code>SQLWARNING</code>：匹配所有以01开头的SQLSTATE错误代码；</li>
<li><code>NOT FOUND</code>：匹配所有以02开头的SQLSTATE错误代码；</li>
<li><code>SQLEXCEPTION</code>：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
</li>
<li><strong>处理语句</strong>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“<code>SET 变量 = 值</code>”这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</li>
</ul>
</blockquote>
<p>定义处理程序的几种方式，代码如下：</p>
<h1 id="方法1捕获sqlstate_value">方法1：捕获sqlstate_value</h1>
<pre><code>DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE';
</code></pre>
<h1 id="方法2捕获mysql_error_value">方法2：捕获mysql_error_value</h1>
<pre><code>DECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE';
</code></pre>
<h1 id="方法3先定义条件再调用">方法3：先定义条件，再调用</h1>
<pre><code>DECLARE no_such_table CONDITION FOR 1146;
DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = 'NO_SUCH_TABLE';
</code></pre>
<h1 id="方法4使用sqlwarning">方法4：使用SQLWARNING</h1>
<pre><code>DECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'ERROR';
</code></pre>
<h1 id="方法5使用not-found">方法5：使用NOT FOUND</h1>
<pre><code>DECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'NO_SUCH_TABLE';
</code></pre>
<h1 id="方法6使用sqlexception">方法6：使用SQLEXCEPTION</h1>
<pre><code>DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'ERROR';
</code></pre>
<h2 id="6-案例解决">6 案例解决</h2>
<blockquote>
<p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行CONTINUE操作，并且将@proc_value的值设置为-1。</p>
</blockquote>
<pre><code>DELIMITER //

CREATE PROCEDURE UpdateDataNoCondition()
	BEGIN
</code></pre>
<h1 id="定义处理程序">定义处理程序</h1>
<pre><code>		DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;

		SET @x = 1;
		UPDATE employees SET email = NULL WHERE last_name = 'Abel';
		SET @x = 2;
		UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';
		SET @x = 3;
	END //

DELIMITER ;
</code></pre>
<p>调用过程：</p>
<pre><code>mysql&gt; CALL UpdateDataWithCondition();
Query OK, 0 rows affected (0.01 sec)

mysql&gt; SELECT @x,@proc_value;
+------+-------------+
| @x   | @proc_value |
+------+-------------+
|    3 |       	 -1  |
+------+-------------+
1 row in set (0.00 sec)
</code></pre>
<p><strong>举例：</strong></p>
<blockquote>
<p>创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。</p>
</blockquote>
<blockquote>
<p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操作，并且将@proc_value的值设置为-1。</p>
</blockquote>
<h1 id="准备工作">准备工作</h1>
<pre><code>CREATE TABLE departments
AS
SELECT * FROM atguigudb.`departments`;

ALTER TABLE departments
ADD CONSTRAINT uk_dept_name UNIQUE(department_id);


DELIMITER //

CREATE PROCEDURE InsertDataWithCondition()
	BEGIN
		DECLARE duplicate_entry CONDITION FOR SQLSTATE '23000' ;
		DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;

		SET @x = 1;
		INSERT INTO departments(department_name) VALUES('测试');
		SET @x = 2;
		INSERT INTO departments(department_name) VALUES('测试');
		SET @x = 3;
	END //

DELIMITER ;
</code></pre>
<p>调用存储过程：</p>
<pre><code>mysql&gt; CALL InsertDataWithCondition();
Query OK, 0 rows affected (0.01 sec)

mysql&gt; SELECT @x,@proc_value;
+------+-------------+
| @x   | @proc_value |
+------+-------------+
|    2 |       	 -1  |
+------+-------------+
1 row in set (0.00 sec)
</code></pre>
<h2 id="163-流程控制">16.3 流程控制</h2>
<blockquote>
<p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p>
<ul>
<li><code>顺序结构</code>：程序从上往下依次执行</li>
<li><code>分支结构</code>：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li>
<li><code>循环结构</code>：程序满足一定条件下，重复执行一组语句</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li><code>条件判断语句</code>：IF 语句和 CASE 语句</li>
<li><code>循环语句</code>：LOOP、WHILE 和 REPEAT 语句</li>
<li><code>跳转语句</code>：ITERATE 和 LEAVE 语句</li>
</ul>
</blockquote>
<h2 id="7-分支结构之-if">7 分支结构之 IF</h2>
<ul>
<li>
<p>IF 语句的语法结构是：</p>
<p>IF 表达式1 THEN 操作1
[ELSEIF 表达式2 THEN 操作2]……
[ELSE 操作N]
END IF</p>
</li>
</ul>
<p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。
<code>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</code>
<strong>举例1：</strong></p>
<pre><code>IF val IS NULL
	THEN SELECT 'val is null';
ELSE SELECT 'val is not null';

END IF;
</code></pre>
<p><strong>举例2</strong>：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)
BEGIN
	DECLARE emp_salary DOUBLE;
	DECLARE hire_year DOUBLE;

	SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;

	SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year
	FROM employees WHERE employee_id = emp_id;

	IF emp_salary &lt; 8000 AND hire_year &gt; 5
	THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;
	END IF;
END //
</code></pre>
<p>​
DELIMITER ;</p>
<p><strong>举例3</strong>：声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)
BEGIN
	DECLARE emp_salary DOUBLE;
	DECLARE hire_year DOUBLE;

	SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;

	SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year
	FROM employees WHERE employee_id = emp_id;

	IF emp_salary &lt; 8000 AND hire_year &gt; 5
		THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;
	ELSE
		UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;
	END IF;
END //
</code></pre>
<p>​
DELIMITER ;</p>
<p><strong>举例4</strong>：声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)
BEGIN
	DECLARE emp_salary DOUBLE;
	DECLARE bonus DECIMAL(3,2);

	SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;
	SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;

	IF emp_salary &lt; 9000
		THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;
	ELSEIF emp_salary &lt; 10000 AND bonus IS NULL
		THEN UPDATE employees SET commission_pct = 0.01 WHERE employee_id = emp_id;
	ELSE
		UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;
	END IF;
END //

DELIMITER ;
</code></pre>
<h3 id="71-分支结构之-case">7.1 分支结构之 CASE</h3>
<p>CASE 语句的语法结构1：</p>
<h1 id="情况一类似于switch">情况一：类似于switch</h1>
<pre><code>CASE 表达式
WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)
WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case](如果是放在begin end中需要加上case，如果放在select后面不需要)
</code></pre>
<p>CASE 语句的语法结构2：</p>
<h1 id="情况二类似于多重if">情况二：类似于多重if</h1>
<pre><code>CASE
WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)
WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case](如果是放在begin end中需要加上case，如果放在select后面不需要)
</code></pre>
<p><strong>举例1：</strong>
使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p>
<pre><code>CASE val
　　　WHEN 1 THEN SELECT 'val is 1';
　　　WHEN 2 THEN SELECT 'val is 2';
　　　ELSE SELECT 'val is not 1 or 2';
END CASE;
</code></pre>
<p><strong>举例2：</strong></p>
<p>使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。</p>
<pre><code>CASE
	WHEN val IS NULL THEN SELECT 'val is null';
	WHEN val &lt; 0 THEN SELECT 'val is less than 0';
	WHEN val &gt; 0 THEN SELECT 'val is greater than 0';
	ELSE SELECT 'val is 0';
END CASE;
</code></pre>
<p>**举例3：**声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)
BEGIN
	DECLARE emp_sal DOUBLE;
	DECLARE bonus DECIMAL(3,2);

	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
	SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;

	CASE
	WHEN emp_sal&lt;9000
		THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;
	WHEN emp_sal&lt;10000 AND bonus IS NULL
		THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;
	ELSE
		UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;
	END CASE;
END //

DELIMITER ;
</code></pre>
<p><strong>举例4</strong>：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年，薪资涨300；如果是4年，薪资涨400；其他的涨薪500。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)
BEGIN
	DECLARE emp_sal DOUBLE;
	DECLARE hire_year DOUBLE;

	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;

	SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees WHERE employee_id = emp_id;

	CASE hire_year
		WHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;
		WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;
		WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;
		WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;
		WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;
		ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;
	END CASE;
END //

DELIMITER ;
</code></pre>
<h2 id="8-循环结构之loop">8 循环结构之LOOP</h2>
<blockquote>
<p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出(使用LEAVE子句)，跳出循环过程。</p>
</blockquote>
<p>LOOP语句的基本格式如下：</p>
<pre><code>[loop_label:] LOOP
	循环执行的语句
END LOOP [loop_label]
</code></pre>
<p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。
<strong>举例1</strong>：使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p>
<pre><code>DECLARE id INT DEFAULT 0;
add_loop:LOOP
	SET id = id +1;
	IF id &gt;= 10 THEN LEAVE add_loop;
	END IF;

END LOOP add_loop;
</code></pre>
<p><strong>举例2</strong>：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_loop(OUT num INT)
BEGIN
	DECLARE avg_salary DOUBLE;
	DECLARE loop_count INT DEFAULT 0;

	SELECT AVG(salary) INTO avg_salary FROM employees;

	label_loop:LOOP
		IF avg_salary &gt;= 12000 THEN LEAVE label_loop;
		END IF;

		UPDATE employees SET salary = salary * 1.1;
		SET loop_count = loop_count + 1;
		SELECT AVG(salary) INTO avg_salary FROM employees;
	END LOOP label_loop;

	SET num = loop_count;

END //

DELIMITER ;
</code></pre>
<h3 id="81-循环结构之while">8.1 循环结构之WHILE</h3>
<blockquote>
<p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
</blockquote>
<pre><code>[while_label:] WHILE 循环条件  DO
	循环体
END WHILE [while_label];
</code></pre>
<blockquote>
<p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。</p>
</blockquote>
<p><strong>举例1</strong>：WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</p>
<pre><code>DELIMITER //

CREATE PROCEDURE test_while()
BEGIN
	DECLARE i INT DEFAULT 0;

	WHILE i &lt; 10 DO
		SET i = i + 1;
	END WHILE;

	SELECT i;
END //

DELIMITER ;
</code></pre>
<h1 id="调用-1">调用</h1>
<pre><code>CALL test_while();
</code></pre>
<p><strong>举例2</strong>：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_while(OUT num INT)
BEGIN
	DECLARE avg_sal DOUBLE ;
	DECLARE while_count INT DEFAULT 0;

	SELECT AVG(salary) INTO avg_sal FROM employees;

	WHILE avg_sal &gt; 5000 DO
		UPDATE employees SET salary = salary * 0.9;

		SET while_count = while_count + 1;

		SELECT AVG(salary) INTO avg_sal FROM employees;
	END WHILE;

	SET num = while_count;

END //

DELIMITER ;
</code></pre>
<h2 id="9-循环结构之repeat">9 循环结构之REPEAT</h2>
<blockquote>
<p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
</blockquote>
<p>REPEAT语句的基本格式如下：</p>
<pre><code>[repeat_label:] REPEAT
　　　　循环体的语句
UNTIL 结束循环的条件表达式
END REPEAT [repeat_label]
</code></pre>
<blockquote>
<p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</p>
</blockquote>
<p><strong>举例1</strong>：</p>
<pre><code>DELIMITER //

CREATE PROCEDURE test_repeat()
BEGIN
	DECLARE i INT DEFAULT 0;

	REPEAT
		SET i = i + 1;
	UNTIL i &gt;= 10
	END REPEAT;

	SELECT i;
END //

DELIMITER ;
</code></pre>
<p><strong>举例2</strong>：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE update_salary_repeat(OUT num INT)
BEGIN
	DECLARE avg_sal DOUBLE ;
	DECLARE repeat_count INT DEFAULT 0;

	SELECT AVG(salary) INTO avg_sal FROM employees;

	REPEAT
		UPDATE employees SET salary = salary * 1.15;

		SET repeat_count = repeat_count + 1;

		SELECT AVG(salary) INTO avg_sal FROM employees;
	UNTIL avg_sal &gt;= 13000
	END REPEAT;

	SET num = repeat_count;

END //

DELIMITER ;
</code></pre>
<blockquote>
<p><strong>对比三种循环结构：</strong></p>
<ul>
<li>这三种循环都可以省略名称，但如果循环中添加了循环控制语句(LEAVE或ITERATE)则必须添加名称。</li>
<li>LOOP：一般用于实现简单的&quot;死&quot;循环
WHILE：先判断后执行
REPEAT：先执行后判断，无条件至少执行一次</li>
</ul>
</blockquote>
<h3 id="91-跳转语句之leave语句">9.1 跳转语句之LEAVE语句</h3>
<blockquote>
<p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
</blockquote>
<p>基本格式如下：</p>
<pre><code>LEAVE 标记名
</code></pre>
<blockquote>
<p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p>
</blockquote>
<p><strong>举例1</strong>：创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。</p>
<ul>
<li>如果num&lt;=0，则使用LEAVE语句退出BEGIN…END；</li>
<li>如果num=1，则查询“employees”表的平均薪资；</li>
<li>如果num=2，则查询“employees”表的最低薪资；</li>
<li>如果num&gt;2，则查询“employees”表的最高薪资。</li>
</ul>
<p>IF语句结束后查询“employees”表的总人数。</p>
<pre><code>DELIMITER //

CREATE PROCEDURE leave_begin(IN num INT)

	begin_label: BEGIN
		IF num&lt;=0
			THEN LEAVE begin_label;
		ELSEIF num=1
			THEN SELECT AVG(salary) FROM employees;
		ELSEIF num=2
			THEN SELECT MIN(salary) FROM employees;
		ELSE
			SELECT MAX(salary) FROM employees;
		END IF;

		SELECT COUNT(*) FROM employees;
	END //
</code></pre>
<p>​
DELIMITER ;</p>
<p><strong>举例2</strong>：当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。</p>
<pre><code>DELIMITER //
CREATE PROCEDURE leave_while(OUT num INT)

BEGIN
</code></pre>
<h1 id="heading"></h1>
<pre><code>	DECLARE avg_sal DOUBLE;#记录平均工资
	DECLARE while_count INT DEFAULT 0; #记录循环次数

	SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件

	while_label:WHILE TRUE DO  #② 循环条件
</code></pre>
<h1 id="循环体">循环体</h1>
<pre><code>		IF avg_sal &lt;= 10000 THEN
			LEAVE while_label;
		END IF;

		UPDATE employees SET salary  = salary * 0.9;
		SET while_count = while_count + 1;
</code></pre>
<h1 id="迭代条件">迭代条件</h1>
<pre><code>		SELECT AVG(salary) INTO avg_sal FROM employees;

	END WHILE;
</code></pre>
<h1 id="赋值">赋值</h1>
<pre><code>	SET num = while_count;

END //

DELIMITER ;
</code></pre>
<h2 id="10-跳转语句之iterate语句">10 跳转语句之ITERATE语句</h2>
<blockquote>
<p>ITERATE语句：只能用在循环语句(LOOP、REPEAT和WHILE语句)内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p>
</blockquote>
<p>语句基本格式如下：</p>
<pre><code>ITERATE label
</code></pre>
<blockquote>
<p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p>
</blockquote>
<p><strong>举例</strong>： 定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p>
<ul>
<li>
<p>如果num &lt; 10，则继续执行循环；</p>
</li>
<li>
<p>如果num &gt; 15，则退出循环结构；</p>
<p>DELIMITER //</p>
<p>CREATE PROCEDURE test_iterate()</p>
<p>BEGIN
DECLARE num INT DEFAULT 0;</p>
<pre><code>my_loop:LOOP
	SET num = num + 1;

	IF num &lt; 10
		THEN ITERATE my_loop;
	ELSEIF num &gt; 15
		THEN LEAVE my_loop;
	END IF;

	SELECT '尚硅谷：让天下没有难学的技术';

END LOOP my_loop;
</code></pre>
<p>END //</p>
<p>DELIMITER ;</p>
</li>
</ul>
<h2 id="164-游标">16.4 游标</h2>
<h3 id="101-什么是游标或光标">10.1 什么是游标(或光标)</h3>
<blockquote>
<p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是<code>随意定位到某一条记录</code>，并对记录的数据进行处理。</p>
</blockquote>
<blockquote>
<p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</strong></p>
</blockquote>
<blockquote>
<p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标<code>充当了指针的作用</code>，我们可以通过操作游标来对数据行进行操作。</p>
</blockquote>
<blockquote>
<p>MySQL中游标可以在存储过程和函数中使用。</p>
</blockquote>
<p>比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：</p>
<pre><code>SELECT employee_id,last_name,salary FROM employees
WHERE salary &gt; 15000;
</code></pre>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zmz6aiw6aOb,size_16,color_FFFFFF,t_70,g_se,x_16.png"
        data-srcset="./watermark%2ctype_d3F5LXplbmhlaQ%2cshadow_50%2ctext_Q1NETiBA6Zmz6aiw6aOb%2csize_16%2ccolor_FFFFFF%2ct_70%2cg_se%2cx_16.png, ./watermark%2ctype_d3F5LXplbmhlaQ%2cshadow_50%2ctext_Q1NETiBA6Zmz6aiw6aOb%2csize_16%2ccolor_FFFFFF%2ct_70%2cg_se%2cx_16.png 1.5x, ./watermark%2ctype_d3F5LXplbmhlaQ%2cshadow_50%2ctext_Q1NETiBA6Zmz6aiw6aOb%2csize_16%2ccolor_FFFFFF%2ct_70%2cg_se%2cx_16.png 2x"
        data-sizes="auto"
        alt="./watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zmz6aiw6aOb,size_16,color_FFFFFF,t_70,g_se,x_16.png"
        title="在这里插入图片描述" /></p>
<blockquote>
<p>这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p>
</blockquote>
<h3 id="102-使用游标步骤">10.2 使用游标步骤</h3>
<blockquote>
<p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。
如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
</blockquote>
<p><strong>第一步，声明游标</strong>
在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<pre><code>DECLARE cursor_name CURSOR FOR select_statement;
</code></pre>
<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p>
<pre><code>DECLARE cursor_name CURSOR IS select_statement;
</code></pre>
<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。
比如：</p>
<pre><code>DECLARE cur_emp CURSOR FOR
SELECT employee_id,salary FROM employees;


DECLARE cursor_fruit CURSOR FOR
SELECT f_name, f_price FROM fruits ;
</code></pre>
<p><strong>第二步，打开游标</strong>
打开游标的语法如下：</p>
<pre><code>OPEN cursor_name
</code></pre>
<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的<code>逐条读取</code>结果集中的记录做准备。</p>
<pre><code>OPEN　cur_emp ;
</code></pre>
<p><strong>第三步，使用游标(从游标中取得数据)</strong>
语法如下：</p>
<pre><code>FETCH cursor_name INTO var_name [, var_name] ...
</code></pre>
<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p>注意：var_name必须在声明游标之前就定义好。</p>
<pre><code>FETCH　cur_emp INTO emp_id, emp_sal ;
</code></pre>
<p>注意：<strong>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
<p><strong>第四步，关闭游标</strong></p>
<pre><code>CLOSE cursor_name
</code></pre>
<p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会<code>占用系统资源</code>，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p>
<p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<pre><code>CLOSE　cur_emp;
</code></pre>
<h3 id="103-举例">10.3 举例</h3>
<blockquote>
<p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
</blockquote>
<pre><code>DELIMITER //

CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)

BEGIN
	DECLARE sum_salary DOUBLE DEFAULT 0;  #记录累加的总工资
	DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值
	DECLARE emp_count INT DEFAULT 0; #记录循环个数
</code></pre>
<h1 id="定义游标">定义游标</h1>
<pre><code>	DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;
</code></pre>
<h1 id="打开游标">打开游标</h1>
<pre><code>	OPEN emp_cursor;

	REPEAT
</code></pre>
<h1 id="使用游标从游标中获取数据">使用游标(从游标中获取数据)</h1>
<pre><code>		FETCH emp_cursor INTO cursor_salary;

		SET sum_salary = sum_salary + cursor_salary;
		SET emp_count = emp_count + 1;

		UNTIL sum_salary &gt;= limit_total_salary
	END REPEAT;

	SET total_count = emp_count;
</code></pre>
<h1 id="关闭游标">关闭游标</h1>
<pre><code>	CLOSE emp_cursor;

END //

DELIMITER ;
</code></pre>
<h2 id="11-小结">11 小结</h2>
<blockquote>
<p>游标是 MySQL 的一个重要的功能，为<code>逐条读取</code>结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p>
</blockquote>
<blockquote>
<p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行<code>加锁</code>，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会<code>消耗系统资源</code>，造成内存不足，这是因为游标是在内存中进行的处理。</p>
</blockquote>
<blockquote>
<p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p>
</blockquote>
<h3 id="111-mysql-80的新特性全局变量的持久化">11.1 MySQL 8.0的新特性—全局变量的持久化</h3>
<blockquote>
<p>在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：</p>
</blockquote>
<pre><code>SET GLOBAL MAX_EXECUTION_TIME=2000;
</code></pre>
<p>使用SET GLOBAL语句设置的变量值只会<code>临时生效</code>。<code>数据库重启</code>后，服务器又会从MySQL配置文件中读取变量的默认值。</p>
<p>MySQL 8.0版本新增了<code>SET PERSIST</code>命令。例如，设置服务器的最大连接数为1000：</p>
<pre><code>SET PERSIST global max_connections = 1000;
</code></pre>
<p>MySQL会将该命令的配置保存到数据目录下的<code>mysqld-auto.cnf</code>文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p>
<p>举例：
查看全局变量max_connections的值，结果如下：</p>
<pre><code>mysql&gt; show variables like '%max_connections%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| max_connections        | 151   |
| mysqlx_max_connections | 100   |
+------------------------+-------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<p>设置全局变量max_connections的值：</p>
<pre><code>mysql&gt; set persist max_connections=1000;
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<p><code>重启MySQL服务器</code>，再次查询max_connections的值：</p>
<pre><code>mysql&gt; show variables like '%max_connections%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| max_connections        | 1000  |
| mysqlx_max_connections | 100   |
+------------------------+-------+
2 rows in set, 1 warning (0.00 sec)</code></pre>
</div><div class="post-footer" id="post-footer">
    <div class="post-info"><div class="post-info-tag"><span><a href="/tags/database/">database</a>
                </span><span><a href="/tags/mysql/">mysql</a>
                </span></div><div class="post-info-line"><div class="post-info-mod">
                <span>更新于 2022-06-17</span>
            </div><div class="post-info-mod"></div>
        </div></div><div class="post-nav"><a href="/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B017-18%E7%AB%A0/" class="prev" rel="prev" title="mysql详细笔记17-18章"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
            <a href="/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/mysql%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B013-14%E7%AB%A0/" class="next" rel="next" title="mysql详细笔记13-14章">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div></article></div>
            </main>
            <footer class="footer"><div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.112.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/khusika/FeelIt" target="_blank" rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a>
        </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/"></a></span></div>
</div>
</footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-chevron-up fa-fw"></i>
            </a></div><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script src="/lib/autocomplete/autocomplete.min.js"></script><script src="/lib/lunr/lunr.min.js"></script><script src="/lib/lunr/lunr.stemmer.support.min.js"></script><script src="/lib/lunr/lunr.zh.min.js"></script><script src="/lib/lazysizes/lazysizes.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body></html>
