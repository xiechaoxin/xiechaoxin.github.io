<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>7.类 - xcx</title><meta name="description" content=""><meta property="og:title" content="7.类" />
<meta property="og:description" content="类 1 定义抽象数据类型 类的基本思想是 数据抽象(data abstraction)：接口与实现分离 数据抽象是一种依赖于接口(interface)和" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/1-cpp%E5%9F%BA%E7%A1%80/7.%E7%B1%BB/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-09T05:50:12+00:00" />
<meta property="article:modified_time" content="2022-07-09T05:50:12+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="7.类"/>
<meta name="twitter:description" content="类 1 定义抽象数据类型 类的基本思想是 数据抽象(data abstraction)：接口与实现分离 数据抽象是一种依赖于接口(interface)和"/>
<meta name="application-name" content="xcx">
<meta name="apple-mobile-web-app-title" content="xcx"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/1-cpp%E5%9F%BA%E7%A1%80/7.%E7%B1%BB/" /><link rel="prev" href="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/1-cpp%E5%9F%BA%E7%A1%80/5.%E8%AF%AD%E5%8F%A5/" /><link rel="next" href="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/2-cpp%E6%A0%87%E5%87%86%E5%BA%93/9.%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" /><link rel="stylesheet" href="/css/page.min.css"><link rel="stylesheet" href="/css/home.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "7.类",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xiechaoxin.github.io\/posts\/language\/cpp\/cpp-primer\/1-cpp%E5%9F%BA%E7%A1%80\/7.%E7%B1%BB\/"
        },"genre": "posts","keywords": "C\u002b\u002b primer, 1-CPP基础","wordcount":  5303 ,
        "url": "https:\/\/xiechaoxin.github.io\/posts\/language\/cpp\/cpp-primer\/1-cpp%E5%9F%BA%E7%A1%80\/7.%E7%B1%BB\/","datePublished": "2022-07-09T05:50:12+00:00","dateModified": "2022-07-09T05:50:12+00:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"author": {
                "@type": "Person",
                "name": "作者"
            },"description": ""
    }
    </script></head><body data-header-desktop="" data-header-mobile=""><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xcx">xcx</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xcx">xcx</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><div class="menu-item"><a href="#" onclick="return false;" class="theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div></div>
    </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single" data-toc="disable"><div class="single-card" ><h2 class="single-title animated flipInX">7.类</h2><div class="post-meta">
                <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-category">出版于  <a href="/categories/cpp/"><i class="far fa-folder fa-fw"></i>CPP</a></span></div>
                <div class="post-meta-line"><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-07-09">2022-07-09</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5303 字</span>&nbsp;
                    <span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 11 分钟</span>&nbsp;</div>
            </div>
            
            <hr><div class="details toc" id="toc-static"  data-kept="">
                    <div class="details-summary toc-title">
                        <span>目录</span>
                        <span><i class="details-icon fas fa-angle-right"></i></span>
                    </div>
                    <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-定义抽象数据类型">1 定义抽象数据类型</a>
      <ul>
        <li><a href="#11-例子">1.1 例子：</a></li>
        <li><a href="#12-成员-member">1.2 成员 (Member)</a></li>
        <li><a href="#13-类的成员函数">1.3 类的成员函数</a></li>
        <li><a href="#14-非成员函数">1.4 非成员函数</a></li>
        <li><a href="#15-类的构造函数">1.5 类的构造函数</a></li>
      </ul>
    </li>
    <li><a href="#2-访问控制与封装">2 访问控制与封装</a>
      <ul>
        <li><a href="#21-封装的益处">2.1 封装的益处</a></li>
        <li><a href="#22-友元">2.2 友元</a></li>
      </ul>
    </li>
    <li><a href="#3-类的其他特性">3 类的其他特性</a></li>
    <li><a href="#4-类的作用域">4 类的作用域</a>
      <ul>
        <li><a href="#41-名字查找与类的作用域">4.1 名字查找与类的作用域</a></li>
      </ul>
    </li>
    <li><a href="#5-构造函数再探">5 构造函数再探</a>
      <ul>
        <li><a href="#51-构造函数初始值列表">5.1 构造函数初始值列表</a></li>
        <li><a href="#52-委托构造函数delegating-constructor-c11">5.2 委托构造函数(delegating constructor, <code>C++11</code>)</a></li>
        <li><a href="#53-默认构造函数的作用">5.3 默认构造函数的作用</a></li>
        <li><a href="#54-隐式的类类型转换">5.4 隐式的类类型转换</a></li>
        <li><a href="#55-聚合类">5.5 聚合类</a></li>
        <li><a href="#56-字面值常量类">5.6 字面值常量类</a></li>
      </ul>
    </li>
    <li><a href="#6-类的静态成员">6 类的静态成员</a></li>
    <li><a href="#7-小结">7 小结</a></li>
    <li><a href="#8-术语表">8 术语表</a></li>
  </ul>
</nav></div>
                </div><div class="content" id="content"><h1 id="类">类</h1>
<h2 id="1-定义抽象数据类型">1 定义抽象数据类型</h2>
<p>类的基本思想是</p>
<ul>
<li>数据抽象(data abstraction)：接口与实现分离
<ul>
<li>数据抽象是一种依赖于<strong>接口</strong>(interface)和<strong>实现</strong>(implementation)分离的编程技术。</li>
</ul>
</li>
<li>封装(encapsulation)：把实现对外隐藏起来</li>
</ul>
<h3 id="11-例子">1.1 例子：</h3>
<p>设计 Sales_data 类</p>
<ol>
<li>一个 isbn 成员函数，用于返回对象的 ISBN 编号</li>
<li>一个 combine 成员函数，用户一个 Sales_data 对象加到另一个对象上</li>
<li>一个名为 add 的函数，指向两个 Sales_data 对象的加法</li>
<li>一个 read 函数，将数据从 istream 读入到 Sales_data 对象中</li>
<li>一个 print 函数，将 Sales_data 对象的值输出到 ostream</li>
</ol>
<blockquote>
<p>类的用户，即类的使用者，也是开发人员，包括类的开发人员本人。
但设计类的接口时，需要假设类的用户对类的细节并不知情。</p>
</blockquote>
<h3 id="12-成员-member">1.2 成员 (Member)</h3>
<ul>
<li>必须在类的内部声明，不能在其他地方增加成员。</li>
<li>成员可以是数据，函数，类型别名。</li>
</ul>
<h3 id="13-类的成员函数">1.3 类的成员函数</h3>
<ul>
<li>
<p>成员函数的<strong>声明</strong>必须在类的内部。</p>
</li>
<li>
<p>成员函数的<strong>定义</strong>既可以在类的内部也可以在外部。</p>
</li>
<li>
<p>使用点运算符 <code>.</code> 调用成员函数。</p>
</li>
<li>
<p>必须对任何<code>const</code>或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</p>
</li>
<li>
<p><code>ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }</code></p>
</li>
<li>
<p>默认实参： <code>Sales_item(const std::string &amp;book): isbn(book), units_sold(0), revenue(0.0) { }</code></p>
</li>
<li>
<p><code>*this</code>：</p>
<ul>
<li>每个成员函数都有一个额外的，隐含的形参<code>this</code>。</li>
<li><code>this</code>总是指向当前对象，因此<code>this</code>是一个常量指针。</li>
<li>形参表后面的<code>const</code>，改变了隐含的<code>this</code>形参的类型，如 <code>bool same_isbn(const Sales_item &amp;rhs) const</code>，这种函数称为“常量成员函数”(<code>this</code>指向的当前对象是常量)。</li>
<li><code>return *this;</code>可以让成员函数连续调用。</li>
<li>普通的非<code>const</code>成员函数：<code>this</code>是指向类类型的<code>const</code>指针(可以改变<code>this</code>所指向的值，不能改变<code>this</code>保存的地址)。</li>
<li><code>const</code>成员函数：<code>this</code>是指向 const 类类型的<code>const</code>指针(既不能改变<code>this</code>所指向的值，也不能改变<code>this</code>保存的地址)。</li>
</ul>
</li>
<li>
<p>类作用域和成员函数</p>
<ul>
<li>成员体可以随意使用类中的其他成员而无需在意这些成员出现的次序。</li>
<li>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。</li>
</ul>
</li>
</ul>
<h3 id="14-非成员函数">1.4 非成员函数</h3>
<ul>
<li>和类相关的非成员函数，定义和声明都应该在类的外部。</li>
<li>如果非成员函数是类接口的组成部分，则应该与类在同一个头文件中声明</li>
</ul>
<h3 id="15-类的构造函数">1.5 类的构造函数</h3>
<ul>
<li>类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。</li>
<li>构造函数是特殊的成员函数。</li>
<li>构造函数放在类的<code>public</code>部分。</li>
<li>与类同名的成员函数。</li>
<li><code>Sales_item(): units_sold(0), revenue(0.0) { }</code></li>
<li><code>=default</code>要求编译器合成默认的构造函数。(<code>C++11</code>)</li>
<li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) { }</code></li>
<li>构造函数与类名同名，没有返回值，它的任务是初始化类对象的数据成员</li>
<li>类可以包括多个构造函数，和重载函数差不多</li>
<li>构造函数不能被声明为 const 的
<ul>
<li>直到构造函数完成初始化，对象才能真正得到“常量”属性。</li>
</ul>
</li>
</ul>
<ul>
<li>只有当类没有声明任何构造函数，并且所有类类型的成员都有默认构造函数是，编译器才会自动地生成默认构造函数。</li>
<li>建议手动声明类的默认构造函数</li>
</ul>
<h2 id="2-访问控制与封装">2 访问控制与封装</h2>
<p>使用访问说明符加强类的封装性</p>
<ul>
<li><strong>访问说明符</strong>(access specifiers)：
<ul>
<li><code>public</code>：定义在 <code>public</code>后面的成员在整个程序内可以被访问； <code>public</code>成员定义类的接口。</li>
<li><code>private</code>：定义在 <code>private</code>后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； <code>private</code>隐藏了类的实现细节。</li>
</ul>
</li>
<li>使用 <code>class</code>或者 <code>struct</code>：都可以被用于定义一个类。唯一的却别在于默认访问权限。
<ul>
<li>使用 <code>class</code>：在第一个访问说明符之前的成员是 <code>priavte</code>的。</li>
<li>使用 <code>struct</code>：在第一个访问说明符之前的成员是 <code>public</code>的。</li>
</ul>
</li>
</ul>
<h3 id="21-封装的益处">2.1 封装的益处</h3>
<ul>
<li>确保用户的代码不会无意间破坏封装对象的状态。</li>
<li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li>
</ul>
<h3 id="22-友元">2.2 友元</h3>
<ul>
<li>允许特定的<strong>非成员函数</strong>访问自己类的<strong>私有成员</strong>.</li>
<li>友元的声明以关键字 <code>friend</code>开始。 <code>friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</code>表示非成员函数<code>add</code>可以访问类的非公有成员。</li>
<li>通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong>。</li>
<li>类之间的友元：
<ul>
<li>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</li>
</ul>
</li>
</ul>
<h2 id="3-类的其他特性">3 类的其他特性</h2>
<ul>
<li>成员函数作为内联函数 <code>inline</code>：
<ul>
<li>在类的内部，常有一些规模较小的函数适合于被声明成内联函数。</li>
<li><strong>定义</strong>在类内部的函数是<strong>自动内联</strong>的。</li>
<li>在类外部定义的成员函数，也可以在声明时显式地加上 <code>inline</code>。</li>
</ul>
</li>
<li><strong>可变数据成员</strong> (mutable data member)：
<ul>
<li><code>mutable size_t access_ctr;</code></li>
<li>永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。</li>
</ul>
</li>
<li><strong>类类型</strong>：
<ul>
<li>每个类定义了唯一的类型。</li>
</ul>
</li>
</ul>
<h2 id="4-类的作用域">4 类的作用域</h2>
<h3 id="41-名字查找与类的作用域">4.1 名字查找与类的作用域</h3>
<ul>
<li>一个类就是一个作用域</li>
<li>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。</li>
<li>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</li>
<li>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</li>
<li>类中的<strong>类型名定义</strong>都要放在一开始。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./image-20220709064110192.png"
        data-srcset="./image-20220709064110192.png, ./image-20220709064110192.png 1.5x, ./image-20220709064110192.png 2x"
        data-sizes="auto"
        alt="./image-20220709064110192.png"
        title="类的作用域" /></p>
<h2 id="5-构造函数再探">5 构造函数再探</h2>
<h3 id="51-构造函数初始值列表">5.1 构造函数初始值列表</h3>
<ul>
<li>类似<code>python</code>使用赋值的方式有时候不行，比如<code>const</code>或者引用类型的数据，只能初始化，不能赋值。(注意初始化和赋值的区别)</li>
<li>最好让构造函数初始值的顺序和成员声明的顺序保持一致。</li>
<li>如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。</li>
</ul>
<h3 id="52-委托构造函数delegating-constructor-c11">5.2 委托构造函数(delegating constructor, <code>C++11</code>)</h3>
<ul>
<li>委托构造函数将自己的职责委托给了其他构造函数。</li>
<li><code>Sale_data(): Sale_data(&quot;&quot;, 0, 0) {}</code></li>
</ul>
<h3 id="53-默认构造函数的作用">5.3 默认构造函数的作用</h3>
<p>一个构造函数为所有参数都提供了默认实参，也就定义了默认构造函数</p>
<h3 id="54-隐式的类类型转换">5.4 隐式的类类型转换</h3>
<ul>
<li>如果构造函数<strong>只接受一个实参</strong>，则它实际上定义了转换为此类类型的<strong>隐式转换机制</strong>。这种构造函数又叫<strong>转换构造函数</strong>(converting constructor)。</li>
<li>编译器只会自动地执行<code>仅一步</code>类型转换。</li>
<li>抑制构造函数定义的隐式转换：
<ul>
<li>将构造函数声明为<code>explicit</code>加以阻止。</li>
<li><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化。</li>
</ul>
</li>
</ul>
<h3 id="55-聚合类">5.5 聚合类</h3>
<ul>
<li>满足以下所有条件：
<ul>
<li>所有成员都是<code>public</code>的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类，也没有<code>virtual</code>函数。</li>
</ul>
</li>
<li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li>
</ul>
<blockquote>
<p>如果成员是 const、引用、或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始列表提供初始值</p>
</blockquote>
<h3 id="56-字面值常量类">5.6 字面值常量类</h3>
<ul>
<li><code>constexpr</code>函数的参数和返回值必须是字面值。</li>
<li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li>
<li>数据成员都是字面值类型的聚合类是字面值常量类。</li>
<li>如果不是聚合类，则必须满足下面所有条件：
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数。</li>
<li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li>
</ul>
</li>
</ul>
<h2 id="6-类的静态成员">6 类的静态成员</h2>
<ul>
<li>非<code>static</code>数据成员存在于类类型的每个对象中。</li>
<li><code>static</code>数据成员独立于该类的任意对象而存在。</li>
<li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li>
<li>声明：
<ul>
<li>声明之前加上关键词<code>static</code>。</li>
</ul>
</li>
<li>使用：
<ul>
<li>使用<strong>作用域运算符</strong><code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li>
<li>也可以使用对象访问：<code>r = ac.rate();</code></li>
</ul>
</li>
<li>定义：
<ul>
<li>在类外部定义时不用加<code>static</code>。</li>
</ul>
</li>
<li>初始化：
<ul>
<li>通常不在类的内部初始化，而是在定义时进行初始化，如 <code>double Account::interestRate = initRate();</code></li>
<li>如果一定要在类内部定义，则要求必须是字面值常量类型的<code>constexpr</code>。</li>
</ul>
</li>
</ul>
<h2 id="7-小结">7 小结</h2>
<p>类是 C++语言中最基本的特性。类允许我们为自己的应用定义新类型，从而使得程序更加简洁且易于修改。</p>
<p>类有两项基本能力：一是数据抽象，定义数据成员和函数成员的能力：二是封装，即保护类的成员不被随意访问的能力。通过将类的实现细节设为 private，我们就能完成类的封装。类可以将其他类或者函数设为友元，这样它们就能访问类的非公有成员了。</p>
<p>类可以定义一种特殊的成员函数：构造函数。其作用是控制初始化对象的方式。构造函数可以重载，构造函数应该使用构造函数初始值列表来初始化所有数据成员。</p>
<p>类还能定义可变或者静态成员。一个可变成员永远都不会是 const，即使在 const 成员函数内也能修改它的值：一个静态成员可以是函数也可以是数据，静态成员存在于所有对象之外。</p>
<h2 id="8-术语表">8 术语表</h2>
<p><strong>抽象数据类型(abstract data type)：</strong> 封装(隐藏)了实现细节的数据结构。</p>
<p><strong>访问说明符(access specifier)：</strong> 包括关键字 public 和 private。用于定义成员对类的用户可见还是只对类的友元和成员可见。在类中说明符可以 i 出现多次，每个说明符的有效范围从它自身开始，到下一个说明符为止。</p>
<p><strong>聚合类(aggregate class)：</strong> 只含有公有成员的类，并且没有类内初始值或者构造函数。聚合类的成员可以用花括号括起来的初始值列表进行初始化。</p>
<p><strong>类(class)：</strong> C++提供的自定义数据类型的机制。类可以包含数据，函数和类型成员。一个类定义一种新的类型和一个新的作用域。</p>
<p><strong>类的声明(class declaration)：</strong> 首先是关键字 class(或者 struct)，随后是类名以及分号。如果类已经声明而尚未定义，则它是一个不完全类型。</p>
<p><strong>类的作用域(class scope)：</strong> 每个类定义一个作用域。类作用域比其他作用域更加复杂，类中定义的成员函数甚至有可能使用定义语句之后的名字。</p>
<p><strong>常量成员函数(const member function)：</strong> 一个成员函数，在其中不能修改对象的普通(即既不是 static 也不是 mutable)数据成员。const 成员的 this 指针是指向常量的指针，通过区分函数是否是 const 可以进行重载。</p>
<p><strong>构造函数(constructor)：</strong> 用于初始化对象的一种特殊的成员函数。构造函数应该给每个数据成员都赋一个合适的初始值。</p>
<p><strong>构造函数初始值列表(constructor initializer list)：</strong> 说明一个类的数据成员的初始值，在构造函数体执行之前首先用初始值列表中的值初始化数据成员将被默认初始化。</p>
<p><strong>转换构造函数(converting constructor)：</strong> 可以用一个实参调用的非显式构造函数。这样的函数隐式地将参数类型转换成类类型。</p>
<p><strong>数据抽象(data abstraction)：</strong> 着重关注类型接口的一种编程技术。数据抽象令程序员可以忽略类型的实现细节，只关注类型执行的操作即可。数据抽象是面对对象编程和泛型编程的基础。</p>
<p><strong>默认构造函数(default constructor)：</strong> 当没有提供任何实参时使用的构造函数。</p>
<p><strong>委托构造函数(delegating constructor)：</strong> 委托构造函数的初始值列表只有一个入口，指定类的另一个构造函数执行初始化操作。</p>
<p><strong>封装(encapsulation)：</strong> 分类类的实现与接口，从而隐藏了类的实现细节。在 C++语言中，通过把实现部分设为 private 完成封装的任务。</p>
<p><strong>显式构造函数(explicit constructor)：</strong> 可以用一个单独的实参调用但是不能用于隐式转换的构造函数。通过在构造函数的声明之前加上 explicit 关键字就可以将其声明成显式构造函数。</p>
<p><strong>前向声明(forward declaration)：</strong> 对尚未定义的名字的声明，通常用于表示位于类定义之前的类声明。参见“不完全类型”</p>
<p><strong>友元(friend)：</strong> 类向外部提供其非公有成员访问权限的一种机制。友元的访问权限与成员函数一样。友元可以是类，也可以是函数。</p>
<p><strong>实现(implementatation)：</strong> 类的成员(通常是私有的)，定义了不希望为使用类类型的代码所用的数据及任何操作。</p>
<p><strong>接口(interface)：</strong> 类型提供的(公有)操作。通常情况下，接口不包含数据成员。</p>
<p><strong>成员函数(member function)：</strong> 类的函数成员。普通的成员函数通过隐式的 this 指针与类的对象绑定在一起；静态成员函数不与对象绑定在一起也没有 this 指针。成员函数可以重载，此时隐式的 this 指针参与函数匹配的过程。</p>
<p><strong>可变数据成员(mutable data member)：</strong> 这种成员永远不是 const，即使它属于 const 对象。在 const 函数内可以修改可变数据成员。</p>
<p><strong>名字查找(name lookup)：</strong> 根据名字的使用寻找匹配的声明过程。</p>
<p><strong>私有成员(private member)：</strong> 定义在 private 访问说明符之后的成员，只能被类的友元或类的其他成员访问。数据成员以及仅同类本书使用而不作为接口的功能函数一般设为 private。</p>
<p><strong>公有成员(public member)：</strong> 定义在 public 访问说明符之后的成员，可以被类的所有用户访问。通常情况下，只有实现类的接口的函数才被设为 public。</p>
<p><strong>合成默认构造函数(synthesized default constructor)：</strong> 对于没有显式地定义任何构造函数的类，编译器为其创建(合成)的默认构造函数。该构造函数检查类的数据成员，如果提供了类内初始值，就用它执行初始化操作；否则就对数据成员执行默认初始化。</p>
<p><strong>this 指针(this pointer)：</strong> 是一个隐式的值，作为额外的实参传递给类的每个非静态成员函数。this 指针指向代表函数调用者的对象。</p>
<p><strong>= default：</strong> 一种语法形式，位于类内部默认构造函数声明语句的参数列表之后，要求编译器生成构造函数，而不管类是否已经有了其他构造函数。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info"><div class="post-info-tag"><span><a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
                </span><span><a href="/tags/1-cpp%E5%9F%BA%E7%A1%80/">1-CPP基础</a>
                </span></div><div class="post-info-line"><div class="post-info-mod">
                <span>更新于 2022-07-09</span>
            </div><div class="post-info-mod"></div>
        </div></div><div class="post-nav"><a href="/posts/language/cpp/cpp-primer/1-cpp%E5%9F%BA%E7%A1%80/5.%E8%AF%AD%E5%8F%A5/" class="prev" rel="prev" title="5.语句"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
            <a href="/posts/language/cpp/cpp-primer/2-cpp%E6%A0%87%E5%87%86%E5%BA%93/9.%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" class="next" rel="next" title="9.顺序容器">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div></article></div>
            </main>
            <footer class="footer"><div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.112.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/khusika/FeelIt" target="_blank" rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a>
        </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/"></a></span></div>
</div>
</footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-chevron-up fa-fw"></i>
            </a></div><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script src="/lib/autocomplete/autocomplete.min.js"></script><script src="/lib/lunr/lunr.min.js"></script><script src="/lib/lunr/lunr.stemmer.support.min.js"></script><script src="/lib/lunr/lunr.zh.min.js"></script><script src="/lib/lazysizes/lazysizes.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body></html>
