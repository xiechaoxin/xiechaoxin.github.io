<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>14.重载运算与类型转换 - xcx</title><meta name="description" content=""><meta property="og:title" content="14.重载运算与类型转换" />
<meta property="og:description" content="重载运算与类型转换 1 基本概念 重载运算符是具有特殊名字的函数：由关键字operator和其后要定义的运算符号共同组成。 当一个重载的运算符是成员" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-10T05:32:37+00:00" />
<meta property="article:modified_time" content="2022-07-10T05:32:37+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="14.重载运算与类型转换"/>
<meta name="twitter:description" content="重载运算与类型转换 1 基本概念 重载运算符是具有特殊名字的函数：由关键字operator和其后要定义的运算符号共同组成。 当一个重载的运算符是成员"/>
<meta name="application-name" content="xcx">
<meta name="apple-mobile-web-app-title" content="xcx"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" /><link rel="prev" href="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" /><link rel="next" href="https://xiechaoxin.github.io/posts/language/cpp/cpp-primer/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" /><link rel="stylesheet" href="/css/page.min.css"><link rel="stylesheet" href="/css/home.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "14.重载运算与类型转换",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xiechaoxin.github.io\/posts\/language\/cpp\/cpp-primer\/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7\/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\/"
        },"genre": "posts","keywords": "C\u002b\u002b primer, 3-类设计者的工具","wordcount":  2338 ,
        "url": "https:\/\/xiechaoxin.github.io\/posts\/language\/cpp\/cpp-primer\/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7\/14.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\/","datePublished": "2022-07-10T05:32:37+00:00","dateModified": "2022-07-10T05:32:37+00:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"author": {
                "@type": "Person",
                "name": "作者"
            },"description": ""
    }
    </script></head><body data-header-desktop="" data-header-mobile=""><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xcx">xcx</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xcx">xcx</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><div class="menu-item"><a href="#" onclick="return false;" class="theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div></div>
    </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single" data-toc="disable"><div class="single-card" ><h2 class="single-title animated flipInX">14.重载运算与类型转换</h2><div class="post-meta">
                <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-category">出版于  <a href="/categories/cpp/"><i class="far fa-folder fa-fw"></i>CPP</a></span></div>
                <div class="post-meta-line"><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-07-10">2022-07-10</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2338 字</span>&nbsp;
                    <span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟</span>&nbsp;</div>
            </div>
            
            <hr><div class="details toc" id="toc-static"  data-kept="">
                    <div class="details-summary toc-title">
                        <span>目录</span>
                        <span><i class="details-icon fas fa-angle-right"></i></span>
                    </div>
                    <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-基本概念">1 基本概念</a></li>
    <li><a href="#2-输入和输出运算符">2 输入和输出运算符</a>
      <ul>
        <li><a href="#21-重载输出运算符">2.1 重载输出运算符&laquo;</a></li>
        <li><a href="#22-重载输入运算符">2.2 重载输入运算符&raquo;</a></li>
      </ul>
    </li>
    <li><a href="#3-算数和关系运算符-">3 算数和关系运算符(+、-、*、/)</a>
      <ul>
        <li><a href="#31-相等运算符">3.1 相等运算符==</a></li>
        <li><a href="#32-关系运算符">3.2 关系运算符</a></li>
      </ul>
    </li>
    <li><a href="#4-赋值运算符">4 赋值运算符=</a></li>
    <li><a href="#5-下标运算符">5 下标运算符[]</a></li>
    <li><a href="#6-递增和递减运算符--">6 递增和递减运算符(++、&ndash;)</a></li>
    <li><a href="#7-成员访问运算符-">7 成员访问运算符(*、-&gt;)</a></li>
    <li><a href="#8-函数调用运算符">8 函数调用运算符</a>
      <ul>
        <li><a href="#81-lambda是函数对象">8.1 <code>lambda</code>是函数对象</a></li>
        <li><a href="#82-标准库定义的函数对象">8.2 标准库定义的函数对象</a></li>
        <li><a href="#83-可调用对象与-function">8.3 可调用对象与 function</a></li>
      </ul>
    </li>
    <li><a href="#9-重载类型转换运算符">9 重载、类型转换、运算符</a>
      <ul>
        <li><a href="#91-类型转换运算符">9.1 类型转换运算符</a></li>
        <li><a href="#92-避免有二义性的类型转换">9.2 避免有二义性的类型转换</a></li>
        <li><a href="#93-函数匹配与重载运算符">9.3 函数匹配与重载运算符</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                </div><div class="content" id="content"><h1 id="重载运算与类型转换">重载运算与类型转换</h1>
<h2 id="1-基本概念">1 基本概念</h2>
<ul>
<li>重载运算符是具有特殊名字的函数：由关键字<code>operator</code>和其后要定义的运算符号共同组成。</li>
<li>当一个重载的运算符是成员函数时，<code>this</code>绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量<strong>少一个</strong>。</li>
<li>只能重载大多数已有的运算符，而不能发明新的运算符号。</li>
<li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li>
<li>调用方式：
<ul>
<li><code>data1 + data2;</code></li>
<li><code>operator+(data1, data2);</code></li>
</ul>
</li>
<li>是否是成员函数：
<ul>
<li>赋值(<code>=</code>)、下标(<code>[]</code>)、调用(<code>()</code>)和成员访问箭头(<code>-&gt;</code>)运算符必须是成员。</li>
<li>复合赋值运算符一般来说是成员。</li>
<li>改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。</li>
<li>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</li>
</ul>
</li>
</ul>
<p><strong>运算符</strong>:</p>
<table>
<thead>
<tr>
<th>可以被重载</th>
<th>不可以被重载</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td>
<td><code>::</code>, <code>.*</code>, <code>.</code>, <code>? :</code>,</td>
</tr>
<tr>
<td><code>&amp;</code>, <code>|</code>, <code>~</code>, <code>!</code>, <code>,</code>, <code>=</code></td>
<td></td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>++</code>, <code>--</code></td>
<td></td>
</tr>
<tr>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code></td>
<td></td>
</tr>
<tr>
<td><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code>, <code>&amp;=</code></td>
<td></td>
</tr>
<tr>
<td>|=, <code>*=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>[]</code>, <code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>-&gt;</code>, <code>-&gt;*</code>, <code>new</code>, <code>new[]</code>, <code>delete</code>, <code>delete[]</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="2-输入和输出运算符">2 输入和输出运算符</h2>
<h3 id="21-重载输出运算符">2.1 重载输出运算符&laquo;</h3>
<ul>
<li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个<code>ostream</code>对象。</li>
<li>输入输出运算符必须是非成员函数。</li>
</ul>
<h3 id="22-重载输入运算符">2.2 重载输入运算符&raquo;</h3>
<ul>
<li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的(非常量)对象的引用。</li>
<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</li>
</ul>
<h2 id="3-算数和关系运算符-">3 算数和关系运算符(+、-、*、/)</h2>
<ul>
<li>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。</li>
</ul>
<h3 id="31-相等运算符">3.1 相等运算符==</h3>
<ul>
<li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li>
<li>相等运算符和不等运算符的一个应该把工作委托给另一个。</li>
<li>相等运算符应该具有传递性。</li>
<li>如果某个类在逻辑上有相等性的含义，则该类应该定义<code>operator==</code>，这样做可以使用户更容易使用标准库算法来处理这个类。</li>
</ul>
<h3 id="32-关系运算符">3.2 关系运算符</h3>
<ul>
<li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且仅当<code>&lt;</code>的定义和<code>++</code>产生的结果一致才定义<code>&lt;</code>运算符。</li>
</ul>
<h2 id="4-赋值运算符">4 赋值运算符=</h2>
<ul>
<li>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</li>
<li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。</li>
</ul>
<h2 id="5-下标运算符">5 下标运算符[]</h2>
<ul>
<li>下标运算符必须是成员函数。</li>
<li>一般会定义两个版本：
<ul>
<li>1.返回普通引用。</li>
<li>2.类的常量成员，并返回常量引用。</li>
</ul>
</li>
</ul>
<h2 id="6-递增和递减运算符--">6 递增和递减运算符(++、&ndash;)</h2>
<ul>
<li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。</li>
<li>通常应该被定义成类的成员。</li>
<li>为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</li>
<li>同样为了和内置版本保持一致，后置运算符应该返回递增或递减前对象的值，而不是引用。</li>
<li>后置版本接受一个额外的，不被使用的<code>int</code>类型的形参。因为不会用到，所以无需命名。</li>
</ul>
<h2 id="7-成员访问运算符-">7 成员访问运算符(*、-&gt;)</h2>
<ul>
<li>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</li>
<li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li>
<li>解引用和乘法的区别是一个是一元运算符，一个是二元运算符。</li>
</ul>
<h2 id="8-函数调用运算符">8 函数调用运算符</h2>
<ul>
<li>可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。</li>
<li>函数调用运算符必须是成员函数。</li>
<li>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</li>
<li>如果累定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。</li>
</ul>
<h3 id="81-lambda是函数对象">8.1 <code>lambda</code>是函数对象</h3>
<ul>
<li><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</li>
</ul>
<h3 id="82-标准库定义的函数对象">8.2 标准库定义的函数对象</h3>
<p><strong>标准库函数对象</strong>:</p>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>plus&lt;Type&gt;</code></td>
<td><code>equal_to&lt;Type&gt;</code></td>
<td><code>logical_and&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>minus&lt;Type&gt;</code></td>
<td><code>not_equal_to&lt;Type&gt;</code></td>
<td><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>multiplies&lt;Type&gt;</code></td>
<td><code>greater&lt;Type&gt;</code></td>
<td><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>divides&lt;Type&gt;</code></td>
<td><code>greater_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>modulus&lt;Type&gt;</code></td>
<td><code>less&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>negate&lt;Type&gt;</code></td>
<td><code>less_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>可以在算法中使用标准库函数对象。</li>
</ul>
<h3 id="83-可调用对象与-function">8.3 可调用对象与 function</h3>
<p><strong>标准库 function 类型</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>function&lt;T&gt; f;</code></td>
<td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td>
</tr>
<tr>
<td><code>function&lt;T&gt; f(nullptr);</code></td>
<td>显式地构造一个空<code>function</code></td>
</tr>
<tr>
<td><code>function&lt;T&gt; f(obj)</code></td>
<td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td>
</tr>
<tr>
<td><code>f</code></td>
<td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td>
</tr>
<tr>
<td>定义为<code>function&lt;T&gt;</code>的成员的类型</td>
<td></td>
</tr>
<tr>
<td><code>result_type</code></td>
<td>该<code>function</code>类型的可调用对象返回的类型</td>
</tr>
<tr>
<td><code>argument_type</code></td>
<td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td>
</tr>
<tr>
<td><code>first_argument_type</code></td>
<td>第一个实参的类型</td>
</tr>
<tr>
<td><code>second_argument_type</code></td>
<td>第二个实参的类型</td>
</tr>
</tbody>
</table>
<ul>
<li>例如：声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></li>
</ul>
<h2 id="9-重载类型转换运算符">9 重载、类型转换、运算符</h2>
<h3 id="91-类型转换运算符">9.1 类型转换运算符</h3>
<ul>
<li>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：<code>operator type() const;</code></li>
<li>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code>。</li>
<li>避免过度使用类型转换函数。</li>
<li>C++11 引入了显式的类型转换运算符。</li>
<li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li>
</ul>
<h3 id="92-避免有二义性的类型转换">9.2 避免有二义性的类型转换</h3>
<ul>
<li>通常，不要为类定义几个相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。</li>
<li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</li>
</ul>
<h3 id="93-函数匹配与重载运算符">9.3 函数匹配与重载运算符</h3>
<ul>
<li>如果<code>a</code>是一种类型，则表达式<code>a sym b</code>可能是：
<ul>
<li><code>a.operatorsym(b);</code></li>
<li><code>operatorsym(a,b);</code></li>
</ul>
</li>
<li>如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info"><div class="post-info-tag"><span><a href="/tags/c&#43;&#43;-primer/">C&#43;&#43; primer</a>
                </span><span><a href="/tags/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/">3-类设计者的工具</a>
                </span></div><div class="post-info-line"><div class="post-info-mod">
                <span>更新于 2022-07-10</span>
            </div><div class="post-info-mod"></div>
        </div></div><div class="post-nav"><a href="/posts/language/cpp/cpp-primer/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="prev" rel="prev" title="15.面向对象程序设计"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
            <a href="/posts/language/cpp/cpp-primer/3-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/13.%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" class="next" rel="next" title="13.拷贝控制">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div></article></div>
            </main>
            <footer class="footer"><div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.112.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/khusika/FeelIt" target="_blank" rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a>
        </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/"></a></span></div>
</div>
</footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-chevron-up fa-fw"></i>
            </a></div><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script src="/lib/autocomplete/autocomplete.min.js"></script><script src="/lib/lunr/lunr.min.js"></script><script src="/lib/lunr/lunr.stemmer.support.min.js"></script><script src="/lib/lunr/lunr.zh.min.js"></script><script src="/lib/lazysizes/lazysizes.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body></html>
