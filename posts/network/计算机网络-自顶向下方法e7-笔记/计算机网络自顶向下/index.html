<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>计算机网络自顶向下 - xcx</title><meta name="description" content=""><meta property="og:title" content="计算机网络自顶向下" />
<meta property="og:description" content="中科大郑烇、杨坚全套《计算机网络(自顶向下方法 第 7 版，James F.Kurose，Keith W.Ross)》课程 中科大郑烇、杨坚全套《计算机" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiechaoxin.github.io/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95e7-%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-17T17:59:12+00:00" />
<meta property="article:modified_time" content="2022-06-17T17:59:12+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络自顶向下"/>
<meta name="twitter:description" content="中科大郑烇、杨坚全套《计算机网络(自顶向下方法 第 7 版，James F.Kurose，Keith W.Ross)》课程 中科大郑烇、杨坚全套《计算机"/>
<meta name="application-name" content="xcx">
<meta name="apple-mobile-web-app-title" content="xcx"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xiechaoxin.github.io/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95e7-%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/" /><link rel="prev" href="https://xiechaoxin.github.io/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/blog_cut/mysql/transaction-isolation-level/" /><link rel="next" href="https://xiechaoxin.github.io/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" /><link rel="stylesheet" href="/css/page.min.css"><link rel="stylesheet" href="/css/home.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "计算机网络自顶向下",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xiechaoxin.github.io\/posts\/network\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95e7-%E7%AC%94%E8%AE%B0\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B\/"
        },"genre": "posts","keywords": "network, 计算机网络-自顶向下方法E7-笔记","wordcount":  55535 ,
        "url": "https:\/\/xiechaoxin.github.io\/posts\/network\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95e7-%E7%AC%94%E8%AE%B0\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B\/","datePublished": "2022-06-17T17:59:12+00:00","dateModified": "2022-06-17T17:59:12+00:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"author": {
                "@type": "Person",
                "name": "作者"
            },"description": ""
    }
    </script></head><body data-header-desktop="" data-header-mobile=""><script>(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xcx">xcx</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xcx">xcx</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="在客户端搜索可能比较慢~" id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><div class="menu-item"><a href="#" onclick="return false;" class="theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div></div>
    </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single" data-toc="disable"><div class="single-card" ><h2 class="single-title animated flipInX">计算机网络自顶向下</h2><div class="post-meta">
                <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-category">出版于  <a href="/categories/network/"><i class="far fa-folder fa-fw"></i>network</a></span></div>
                <div class="post-meta-line"><span><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-06-17">2022-06-17</time></span>&nbsp;<span><i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 55535 字</span>&nbsp;
                    <span><i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 111 分钟</span>&nbsp;</div>
            </div>
            
            <hr><div class="details toc" id="toc-static"  data-kept="">
                    <div class="details-summary toc-title">
                        <span>目录</span>
                        <span><i class="details-icon fas fa-angle-right"></i></span>
                    </div>
                    <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-分层作用">1 分层作用</a>
      <ul>
        <li><a href="#11-应用层">1.1 应用层</a></li>
        <li><a href="#12-传输层">1.2 传输层</a></li>
        <li><a href="#13-网络端">1.3 网络端</a></li>
        <li><a href="#14-数据链路层">1.4 数据链路层</a></li>
        <li><a href="#15-物理层">1.5 物理层</a></li>
        <li><a href="#16-协议">1.6 协议</a></li>
        <li><a href="#17-什么是-internet">1.7 什么是 Internet</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#2-什么是-internet">2 什么是 Internet？</a>
      <ul>
        <li><a href="#21-网络">2.1 网络</a></li>
        <li><a href="#22-网络边缘">2.2 网络边缘</a></li>
        <li><a href="#23-网络核心">2.3 网络核心</a></li>
        <li><a href="#24-接入网和物理媒体">2.4 接入网和物理媒体</a></li>
        <li><a href="#25-internet-结构和-isp">2.5 Internet 结构和 ISP</a></li>
        <li><a href="#26-分组延时丢失和吞吐量">2.6 分组延时、丢失和吞吐量</a></li>
        <li><a href="#27-协议层次及服务模型">2.7 协议层次及服务模型</a></li>
        <li><a href="#28-历史">2.8 历史</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#3-应用层协议原理">3 应用层协议原理</a></li>
    <li><a href="#4-客户-服务器cs体系结构">4 客户-服务器(C/S)体系结构</a>
      <ul>
        <li><a href="#41-对等体p2p体系结构">4.1 对等体(P2P)体系结构</a></li>
        <li><a href="#42-cs-和-p2p-体系结构的混合体">4.2 C/S 和 P2P 体系结构的混合体</a></li>
        <li><a href="#43-进程通信">4.3 进程通信</a></li>
        <li><a href="#44-分布式进程通信需要解决的问题应用进程如何使用传输层提供的服务交换报文">4.4 分布式进程通信需要解决的问题(应用进程如何使用传输层提供的服务交换报文)</a></li>
        <li><a href="#45-应用层协议">4.5 应用层协议</a></li>
        <li><a href="#46-应用需要传输层提供什么样的服务">4.6 应用需要传输层提供什么样的服务？</a></li>
        <li><a href="#47-常见应用对传输服务的要求">4.7 常见应用对传输服务的要求</a></li>
        <li><a href="#48-internet-传输层提供的服务">4.8 Internet 传输层提供的服务</a></li>
        <li><a href="#49-internet-应用及其应用层协议和传输协议">4.9 Internet 应用及其应用层协议和传输协议</a></li>
      </ul>
    </li>
    <li><a href="#5-web-and-http">5 Web and HTTP</a>
      <ul>
        <li><a href="#51-http-概况">5.1 HTTP 概况</a></li>
        <li><a href="#52-http-连接">5.2 HTTP 连接</a></li>
        <li><a href="#53-http-请求报文">5.3 HTTP 请求报文</a></li>
        <li><a href="#54-http-响应报文">5.4 HTTP 响应报文</a></li>
        <li><a href="#55-用户-服务器状态cookies">5.5 用户-服务器状态：cookies</a></li>
        <li><a href="#56-web-缓存-代理服务器">5.6 Web 缓存 (代理服务器)</a></li>
        <li><a href="#57-缓存例子安装本地缓存">5.7 缓存例子：安装本地缓存</a></li>
      </ul>
    </li>
    <li><a href="#6-ftp">6 FTP*</a>
      <ul>
        <li><a href="#61-ftp-控制连接与数据连接分开">6.1 FTP: 控制连接与数据连接分开</a></li>
        <li><a href="#62-ftp-命令响应">6.2 FTP 命令、响应</a></li>
        <li><a href="#63-ftp-协议与-http-协议的差别">6.3 FTP 协议与 HTTP 协议的差别</a></li>
      </ul>
    </li>
    <li><a href="#7-email">7 EMail</a>
      <ul>
        <li><a href="#71-email-smtp-rfc-2821-原理">7.1 EMail: SMTP [RFC 2821] 原理</a></li>
        <li><a href="#72-简单的-smtp-交互">7.2 简单的 SMTP 交互</a></li>
        <li><a href="#73-smtp总结">7.3 SMTP：总结</a></li>
        <li><a href="#74-邮件报文格式">7.4 邮件报文格式</a></li>
        <li><a href="#75-邮件访问协议">7.5 邮件访问协议</a></li>
      </ul>
    </li>
    <li><a href="#8-dns">8 DNS</a>
      <ul>
        <li><a href="#81-dns-的必要性">8.1 DNS 的必要性</a></li>
        <li><a href="#82-dnsdomain-name-system总体思路和目标">8.2 DNS(Domain Name System)总体思路和目标</a></li>
        <li><a href="#83-问题-1dns-名字空间the-dns-name-space">8.3 问题 1：DNS 名字空间(The DNS Name Space)</a></li>
        <li><a href="#84-问题-2解析问题-名字服务器name-server">8.4 问题 2：解析问题-名字服务器(Name Server)</a></li>
        <li><a href="#85-dns-大致工作过程">8.5 DNS 大致工作过程</a></li>
        <li><a href="#86-dns-协议报文">8.6 DNS 协议、报文</a></li>
        <li><a href="#87-问题-3维护问题新增一个域">8.7 问题 3：维护问题：新增一个域</a></li>
      </ul>
    </li>
    <li><a href="#9-p2p-应用">9 P2P 应用</a>
      <ul>
        <li><a href="#91-文件分发-cs-vs-p2p">9.1 文件分发: C/S vs P2P</a></li>
        <li><a href="#92-p2p-文件共享">9.2 P2P 文件共享</a></li>
        <li><a href="#93-集中式目录">9.3 、集中式目录</a></li>
        <li><a href="#94-查询洪泛gnutella完全分布式">9.4 、查询洪泛：Gnutella(完全分布式)</a></li>
        <li><a href="#95-利用不匀称性kazaa混合体">9.5 、利用不匀称性：KaZaA(混合体)</a></li>
        <li><a href="#96-实际的例子p2p-文件分发-bittorrent">9.6 (实际的例子)P2P 文件分发： BitTorrent</a></li>
      </ul>
    </li>
    <li><a href="#10-cdn">10 CDN</a>
      <ul>
        <li><a href="#101-多媒体流化服务dash">10.1 多媒体流化服务：DASH</a></li>
      </ul>
    </li>
    <li><a href="#11-tcp-套接字编程">11 TCP 套接字编程</a>
      <ul>
        <li><a href="#111-过程">11.1 过程</a></li>
        <li><a href="#112-cs-模式的应用样例">11.2 C/S 模式的应用样例</a></li>
      </ul>
    </li>
    <li><a href="#12-cs-socket-交互-tcp">12 C/S socket 交互: TCP</a></li>
    <li><a href="#13-udp-套接字编程">13 UDP 套接字编程</a></li>
    <li><a href="#14-第-2-章小结">14 第 2 章：小结</a></li>
  </ul>

  <ul>
    <li><a href="#15-文章-31-概述和传输层服务">15 文章 3.1 概述和传输层服务</a>
      <ul>
        <li><a href="#151-传输层-vs-网络层">15.1 传输层 vs. 网络层</a></li>
        <li><a href="#152-internet-传输层协议">15.2 Internet 传输层协议</a></li>
      </ul>
    </li>
    <li><a href="#16-多路复用与解复用">16 多路复用与解复用</a></li>
    <li><a href="#17-无连接传输udp">17 无连接传输：UDP</a>
      <ul>
        <li><a href="#171-udp用户数据报协议">17.1 UDP：用户数据报协议</a></li>
        <li><a href="#172-为什么要有-udp">17.2 为什么要有 UDP?</a></li>
        <li><a href="#173-internet-校验和的例子">17.3 Internet 校验和的例子</a></li>
      </ul>
    </li>
    <li><a href="#18-可靠数据传输的原理">18 可靠数据传输的原理</a>
      <ul>
        <li><a href="#181-rdt10-在可靠信道上的可靠数据传输">18.1 Rdt1.0： 在可靠信道上的可靠数据传输</a></li>
        <li><a href="#182-rdt20具有比特差错的信道">18.2 Rdt2.0：具有比特差错的信道</a></li>
        <li><a href="#183-rdt20-的致命缺陷--rdt21">18.3 rdt2.0 的致命缺陷！-&gt; rdt2.1</a></li>
        <li><a href="#184-rdt22无-nak-的协议">18.4 rdt2.2：无 NAK 的协议</a></li>
        <li><a href="#185-rdt30具有比特差错和分组丢失的信道">18.5 rdt3.0：具有比特差错和分组丢失的信道</a></li>
        <li><a href="#186-rdt30停-等操作-stop-wait">18.6 rdt3.0：停-等操作 stop-wait</a></li>
        <li><a href="#187-流水线提高链路利用率">18.7 流水线：提高链路利用率</a></li>
      </ul>
    </li>
    <li><a href="#19-面向连接的传输-tcp">19 面向连接的传输： TCP</a>
      <ul>
        <li><a href="#191-tcp-报文段结构">19.1 TCP 报文段结构</a></li>
        <li><a href="#192-tcp可靠数据传输">19.2 TCP：可靠数据传输</a></li>
        <li><a href="#193-快速重传">19.3 快速重传</a></li>
        <li><a href="#194-tcp-流量控制">19.4 TCP 流量控制</a></li>
        <li><a href="#195-tcp-连接管理">19.5 TCP 连接管理</a></li>
      </ul>
    </li>
    <li><a href="#20-拥塞控制原理">20 拥塞控制原理</a>
      <ul>
        <li><a href="#201-拥塞的原因代价-场景-1">20.1 拥塞的原因/代价: 场景 1</a></li>
        <li><a href="#202-拥塞的原因代价-场景-2">20.2 拥塞的原因/代价: 场景 2</a></li>
        <li><a href="#203-拥塞的原因代价-场景-3">20.3 拥塞的原因/代价: 场景 3</a></li>
        <li><a href="#204-拥塞控制方法">20.4 拥塞控制方法</a></li>
        <li><a href="#205-案例学习-atm-abr-拥塞控制">20.5 案例学习: ATM ABR 拥塞控制</a></li>
      </ul>
    </li>
    <li><a href="#21-tcp-拥塞控制">21 TCP 拥塞控制</a>
      <ul>
        <li><a href="#211-tcp-拥塞控制机制">21.1 TCP 拥塞控制：机制</a></li>
        <li><a href="#212-tcp-拥塞控制拥塞感知">21.2 TCP 拥塞控制：拥塞感知</a></li>
        <li><a href="#213-tcp-拥塞控制速率控制方法">21.3 TCP 拥塞控制：速率控制方法</a></li>
        <li><a href="#214-tcp-拥塞控制和流量控制的联合动作">21.4 TCP 拥塞控制和流量控制的联合动作</a></li>
        <li><a href="#215-拥塞控制策略">21.5 拥塞控制策略</a></li>
        <li><a href="#216-总结-tcp-拥塞控制">21.6 总结: TCP 拥塞控制</a></li>
        <li><a href="#217-tcp-吞吐量">21.7 TCP 吞吐量</a></li>
        <li><a href="#218-tcp-公平性">21.8 TCP 公平性</a></li>
      </ul>
    </li>
    <li><a href="#22-第三章-总结">22 第三章 总结</a></li>
  </ul>

  <ul>
    <li><a href="#23-导论">23 导论</a></li>
    <li><a href="#24-网络层服务">24 网络层服务</a>
      <ul>
        <li><a href="#241-网络层的关键功能">24.1 网络层的关键功能</a></li>
        <li><a href="#242-网络层数据平面控制平面">24.2 网络层：数据平面、控制平面</a></li>
        <li><a href="#243-网络服务模型">24.3 网络服务模型</a></li>
        <li><a href="#244-连接建立">24.4 连接建立</a></li>
        <li><a href="#245-一些网络层服务模型">24.5 一些网络层服务模型</a></li>
      </ul>
    </li>
    <li><a href="#25-路由器组成">25 路由器组成</a>
      <ul>
        <li><a href="#251-路由器结构概况-传统">25.1 路由器结构概况 (传统)</a></li>
        <li><a href="#252-输入端口功能">25.2 输入端口功能</a></li>
        <li><a href="#253-交换结构">25.3 交换结构</a></li>
        <li><a href="#254-输出端口">25.4 输出端口</a></li>
        <li><a href="#255-调度机制">25.5 调度机制</a></li>
      </ul>
    </li>
    <li><a href="#26-ip-internet-protocol">26 IP: Internet Protocol</a>
      <ul>
        <li><a href="#261-ip-数据报格式">26.1 IP 数据报格式</a></li>
        <li><a href="#262-ip-分片和重组fragmentation--reassembly">26.2 IP 分片和重组(Fragmentation &amp; Reassembly)</a></li>
        <li><a href="#263-ip-编址-引论">26.3 IP 编址: 引论</a></li>
        <li><a href="#264-如何获得一个-ip-地址-主机">26.4 如何获得一个 IP 地址 主机</a></li>
        <li><a href="#265-如何获得一个-ip-地址-机构">26.5 如何获得一个 IP 地址 机构</a></li>
        <li><a href="#266-ip-编址-如何获得一块地址-isp">26.6 IP 编址: 如何获得一块地址 ISP</a></li>
        <li><a href="#267-nat-network-address-translation-网络地址转换内网">26.7 NAT: Network Address Translation 网络地址转换(内网)</a></li>
        <li><a href="#268-ipv6">26.8 IPv6</a></li>
      </ul>
    </li>
    <li><a href="#27-通用转发和-sdn">27 通用转发和 SDN</a>
      <ul>
        <li><a href="#271-网络层功能为例的数据平面和控制平面">27.1 网络层功能为例的数据平面和控制平面</a></li>
        <li><a href="#272-每个路由器per-route的控制平面-传统">27.2 每个路由器(Per Route)的控制平面 (传统)</a></li>
        <li><a href="#273-sdn逻辑上集中的控制平面-新">27.3 SDN：逻辑上集中的控制平面 (新)</a></li>
        <li><a href="#274-流量工程-传统路由比较困难">27.4 流量工程: 传统路由比较困难</a></li>
        <li><a href="#275-sdn-架构">27.5 SDN 架构</a></li>
        <li><a href="#276-openflow-协议">27.6 OpenFlow 协议</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#28-导论">28 导论</a></li>
    <li><a href="#29-网络层功能">29 网络层功能</a>
      <ul>
        <li><a href="#291-传统方式每-路由器per-router控制平面">29.1 传统方式：每-路由器(Per-router)控制平面</a></li>
      </ul>
    </li>
    <li><a href="#30-路由选择算法">30 路由选择算法</a>
      <ul>
        <li><a href="#301-路由route的概念">30.1 路由(route)的概念</a></li>
        <li><a href="#302-路由的原则">30.2 路由的原则</a></li>
        <li><a href="#303-路由选择算法-link-state-全局">30.3 路由选择算法 link state (全局)</a></li>
        <li><a href="#304-路由选择算法-distance-vector-分布式">30.4 路由选择算法 distance vector (分布式)</a></li>
        <li><a href="#305-ls-和-dv-算法的比较">30.5 LS 和 DV 算法的比较</a></li>
      </ul>
    </li>
    <li><a href="#31-因特网中自治系统内部的路由选择-实际的内部的">31 因特网中自治系统内部的路由选择 (实际的、内部的)</a>
      <ul>
        <li><a href="#311-rip--routing-information-protocol">31.1 RIP ( Routing Information Protocol)</a></li>
        <li><a href="#312-ospf-open-shortest-path-first">31.2 OSPF (Open Shortest Path First)</a></li>
      </ul>
    </li>
    <li><a href="#32-isp-之间的路由选择-bgp">32 ISP 之间的路由选择: BGP</a>
      <ul>
        <li><a href="#321-层次路由">32.1 层次路由</a></li>
        <li><a href="#322-互联网-as-间路由bgp-边界网关协议">32.2 互联网 AS 间路由：BGP 边界网关协议</a></li>
      </ul>
    </li>
    <li><a href="#33-sdn-控制平面">33 SDN 控制平面</a>
      <ul>
        <li><a href="#331-software-defined-networking-sdn">33.1 Software defined networking (SDN)</a></li>
      </ul>
    </li>
    <li><a href="#34-icmp-因特网控制报-文协议">34 ICMP: 因特网控制报 文协议</a>
      <ul>
        <li><a href="#341-icmp-internet-control-message-protocol">34.1 ICMP: Internet Control Message Protocol</a></li>
      </ul>
    </li>
    <li><a href="#35-网络管理和-snmp略">35 网络管理和 SNMP(略)</a>
      <ul>
        <li><a href="#351-什么是网络管理">35.1 什么是网络管理?</a></li>
        <li><a href="#352-网络管理架构">35.2 网络管理架构</a></li>
        <li><a href="#353-snmp-协议">35.3 SNMP 协议</a></li>
      </ul>
    </li>
    <li><a href="#36-第五章总结">36 第五章：总结</a></li>
  </ul>

  <ul>
    <li><a href="#37-数据链路层和局域网">37 数据链路层和局域网</a></li>
    <li><a href="#38-引论和服务">38 引论和服务</a></li>
    <li><a href="#39-链路层-导论">39 链路层: 导论</a>
      <ul>
        <li><a href="#391-链路层-上下文">39.1 链路层: 上下文</a></li>
      </ul>
    </li>
    <li><a href="#40-差错检测和纠正">40 差错检测和纠正</a>
      <ul>
        <li><a href="#401-错误检测">40.1 错误检测</a></li>
        <li><a href="#402-奇偶校验">40.2 奇偶校验</a></li>
        <li><a href="#403-internet-校验和">40.3 Internet 校验和</a></li>
        <li><a href="#404-检验和crc循环冗余校验">40.4 检验和：CRC(循环冗余校验)</a></li>
        <li><a href="#405-crc-例子">40.5 CRC 例子</a></li>
        <li><a href="#406-crc-性能分析">40.6 CRC 性能分析</a></li>
      </ul>
    </li>
    <li><a href="#41-多点访问协议">41 多点访问协议</a>
      <ul>
        <li><a href="#411-多路访问链路和协议">41.1 多路访问链路和协议</a></li>
        <li><a href="#412-多路访问协议">41.2 多路访问协议</a></li>
        <li><a href="#413-理想的多路访问协议">41.3 理想的多路访问协议</a></li>
        <li><a href="#414-mac媒体访问控制协议分类">41.4 MAC(媒体访问控制)协议：分类</a></li>
        <li><a href="#415-mac-协议总结">41.5 MAC 协议总结</a></li>
      </ul>
    </li>
    <li><a href="#42-lans">42 LANs</a>
      <ul>
        <li><a href="#421-mac-地址和-arp">42.1 MAC 地址和 ARP</a></li>
        <li><a href="#422-以太网">42.2 以太网</a></li>
        <li><a href="#423-wlan">42.3 WLAN</a></li>
        <li><a href="#424-switches">42.4 switches</a></li>
        <li><a href="#425-交换机-vs-路由器">42.5 交换机 vs. 路由器</a></li>
        <li><a href="#426-vlans-虚拟局域网">42.6 VLANS 虚拟局域网</a></li>
      </ul>
    </li>
    <li><a href="#43-链路虚拟化mpls">43 链路虚拟化：MPLS</a>
      <ul>
        <li><a href="#431-mpls-概述--标签分发">43.1 MPLS 概述 —— 标签分发</a></li>
      </ul>
    </li>
    <li><a href="#44-数据中心网络">44 数据中心网络</a></li>
    <li><a href="#45-a-day-in-the-life-of-web-request">45 a day in the life of web request</a>
      <ul>
        <li><a href="#451-日常场景">45.1 日常场景</a></li>
        <li><a href="#452-日常场景-连接到互联网">45.2 日常场景：… 连接到互联网</a></li>
        <li><a href="#453-日常场景-arp-dns-之前-http-之前">45.3 日常场景…… ARP (DNS 之前, HTTP 之前)</a></li>
        <li><a href="#454-日常场景使用-dns">45.4 日常场景：使用 DNS</a></li>
        <li><a href="#455-日常场景-tcp-连接携带-http-报文">45.5 日常场景： …TCP 连接携带 HTTP 报文</a></li>
      </ul>
    </li>
    <li><a href="#46-第-6-章总结">46 第 6 章：总结</a></li>
  </ul>

  <ul>
    <li><a href="#47-什么是网络安全">47 什么是网络安全？</a></li>
    <li><a href="#48-朋友和敌人-alice-bob-trudy">48 朋友和敌人: Alice, Bob, Trudy</a>
      <ul>
        <li><a href="#481-网络中的坏蛋">48.1 网络中的坏蛋</a></li>
        <li><a href="#482-谁有可能是-bob-alice">48.2 谁有可能是 Bob, Alice?</a></li>
      </ul>
    </li>
    <li><a href="#49-加密原理">49 加密原理</a>
      <ul>
        <li><a href="#491-加密语言">49.1 加密语言</a></li>
        <li><a href="#492-对称密钥加密">49.2 对称密钥加密</a></li>
        <li><a href="#493-对称密钥加密学-des">49.3 对称密钥加密学: DES</a></li>
        <li><a href="#494-块密码">49.4 块密码</a></li>
        <li><a href="#495-aes-advanced-encryption-standard">49.5 AES: Advanced Encryption Standard</a></li>
        <li><a href="#496-密码块链">49.6 密码块链</a></li>
        <li><a href="#497-公开密钥密码学">49.7 公开密钥密码学</a></li>
        <li><a href="#498-公开密钥加密算法">49.8 公开密钥加密算法</a></li>
        <li><a href="#499-rsa-选择密钥">49.9 RSA: 选择密钥</a></li>
        <li><a href="#4910-rsa-加密解密">49.10 RSA: 加密,解密</a></li>
        <li><a href="#4911-rsa-为什么">49.11 RSA: 为什么</a></li>
        <li><a href="#4912-rsa-例子">49.12 RSA 例子:</a></li>
        <li><a href="#4913-rsa-数字签名--先解密私钥-在加密公钥-确认身份">49.13 RSA: 数字签名 —— 先解密(私钥) 在加密(公钥) 确认身份</a></li>
      </ul>
    </li>
    <li><a href="#50-认证">50 认证</a>
      <ul>
        <li><a href="#501-认证重新尝试">50.1 认证:重新尝试</a></li>
        <li><a href="#502-目标-避免重放攻击">50.2 目标: 避免重放攻击</a></li>
        <li><a href="#503-认证-ap50">50.3 认证: ap5.0</a></li>
        <li><a href="#504-ap50-安全漏洞--中间攻击">50.4 ap5.0: 安全漏洞 —— 中间攻击</a></li>
      </ul>
    </li>
    <li><a href="#51-报文完整性">51 报文完整性</a>
      <ul>
        <li><a href="#511-ap50-安全漏洞">51.1 ap5.0: 安全漏洞</a></li>
        <li><a href="#512-数字签名">51.2 数字签名</a></li>
        <li><a href="#513-简单的对ｍ的数字签名">51.3 简单的对ｍ的数字签名：</a></li>
        <li><a href="#514-报文摘要">51.4 报文摘要</a></li>
        <li><a href="#515-internet-校验和-弱的散列函数-容易冲突">51.5 Internet 校验和: 弱的散列函数 (容易冲突)</a></li>
        <li><a href="#516-数字签名--对报文摘要进行数字签署">51.6 数字签名 = 对报文摘要进行数字签署</a></li>
      </ul>
    </li>
    <li><a href="#52-密钥分发和证书">52 密钥分发和证书</a>
      <ul>
        <li><a href="#521-散列函数算法">52.1 散列函数算法</a></li>
        <li><a href="#522-可信赖中介">52.2 可信赖中介</a></li>
        <li><a href="#523-key-distribution-center-kdc">52.3 Key Distribution Center (KDC)</a></li>
        <li><a href="#524-certification-authorities">52.4 Certification Authorities</a></li>
      </ul>
    </li>
    <li><a href="#53-各个层次的安全性">53 各个层次的安全性</a>
      <ul>
        <li><a href="#531-ssl">53.1 SSL</a></li>
        <li><a href="#532-ssl-3-阶段">53.2 SSL: 3 阶段</a></li>
        <li><a href="#533-ipsec-网络层次的安全性">53.3 IPsec: 网络层次的安全性</a></li>
        <li><a href="#534-esp-协议">53.4 ESP 协议</a></li>
      </ul>
    </li>
    <li><a href="#54-网络安全-总结">54 网络安全 (总结)</a></li>
  </ul>
</nav></div>
                </div><div class="content" id="content"><p>中科大郑烇、杨坚全套《计算机网络(自顶向下方法 第 7 版，James F.Kurose，Keith W.Ross)》课程</p>
<p><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=2&amp;spm_id_from=pageDriver&amp;vd_source=a207058e9bb4038abe5c190d26e9ff26" target="_blank" rel="noopener noreffer">中科大郑烇、杨坚全套《计算机网络(自顶向下方法 第 7 版，James F.Kurose，Keith W.Ross)》课程_哔哩哔哩_bilibili</a></p>
<h1 id="计算机网络和互联网">计算机网络和互联网</h1>
<p>Computer network and the Internet</p>
<h2 id="1-分层作用">1 分层作用</h2>
<p>解耦合，每一层都具备功能和向上层提供服务</p>
<h3 id="11-应用层">1.1 应用层</h3>
<p>交换应用报文，</p>
<h3 id="12-传输层">1.2 传输层</h3>
<p>为应用进程提供服务，网络层是主机到主机，传输层是进程到进程，细化了。</p>
<p>解决网络层不可靠，通常在这一层，TCP</p>
<h3 id="13-网络端">1.3 网络端</h3>
<p>路由器工作在网络层</p>
<p>提供端到端(end to end)的(源主机到目标主机，通过很多跳)(ip 数据报)，无保障的，是尽力而为的</p>
<p>路由(算出路由表，给 IP 协议使用)和转发是网络层的主要功能</p>
<p>传统的网络层的工作方式：一个 IP 分组传输到我这里，我查路由表，查到对应表项就转发，查不到就给到默认的路径，不具备灵活性，不具备升级和扩展的可能，不可编程扩展</p>
<p>现在的工作方式，SDN，分为控制平面和数据平面，具备可编程，可扩展，功能更多</p>
<h4 id="131-数据平面交换机">1.3.1 数据平面(交换机)</h4>
<h4 id="132-控制平面">1.3.2 控制平面</h4>
<p>安装网络操作系统，跑网络操作应用，算流表，学习功能和应用</p>
<h3 id="14-数据链路层">1.4 数据链路层</h3>
<p>交换机工作在链路层</p>
<p>点到点的服务，通过网卡，以帧为单位</p>
<h3 id="15-物理层">1.5 物理层</h3>
<p>把数字信号，变成物理信号或者光信号灯，电磁波信号，进行发送</p>
<h3 id="16-协议">1.6 协议</h3>
<p>让不同的厂商</p>
<h3 id="17-什么是-internet">1.7 什么是 Internet</h3>
<h1 id="第一章提纲">第一章：提纲</h1>
<h2 id="2-什么是-internet">2 什么是 Internet？</h2>
<h3 id="21-网络">2.1 网络</h3>
<p>网络可以理解是一张图，点和路径组成</p>
<p>蜘蛛网，神经中枢</p>
<h4 id="211-计算机网络">2.1.1 计算机网络</h4>
<h5 id="2111-组成节点链路协议">2.1.1.1 <strong>组成</strong>：节点，链路，协议</h5>
<p><strong>节点</strong>：是一个点，可以是源和目的，或者是数据交换节点，取决于作用</p>
<p>主机及其上运行的应用程序
路由器、交换机等冈络交换设备</p>
<p>一般方形是主机节点(源和目的)，圆形是数据交换节点(路由器，交换机，中继器)</p>
<p><strong>链路</strong>：边，分为两类</p>
<p>接入网链路：主机连接到互联网的链路(连接方圆)
主干链路：路由器间的链路(连接圆圆)</p>
<p><strong>协议</strong>：每一层相对应的实体，所遵守的一些规则，语法，语义，时序等</p>
<p>协议包括，报文格式、次序、动作</p>
<p>PDU 协议数据单元，在每一层上都有不同的语法语义</p>
<h4 id="212-互联网-internet">2.1.2 互联网 Internet</h4>
<h5 id="2121-什么是互联网">2.1.2.1 什么是互联网</h5>
<p>以 TCP/IP 为主的一簇协议，叫做互联网，目前用户最多的</p>
<p>从构成的角度，互联网是计算机网络的一种，所以对应计算机网络的节点+链路+协议</p>
<pre tabindex="0"><code>**端设备**：主机=端系统，网络应用程序，方的；分组交换设备，圆的

**通信链路**

**协议**：作用对象是对等层的实体(应用层传输层等)，协议是一个规则，比方我如何解析这个报文，这个字段是什么意思，字段等于1我做什么？这些就是协议内容

互联网也叫做网络的网络，每个网络可以通过路由器等和其它网络进行互联，网络也可以包含一个小的网络

ROT 物联网
</code></pre><p>从服务的角度，互联网是使用通信设施进行通信的分布式应用+通信基础设施(为分布式应用提供通信服务)</p>
<pre tabindex="0"><code>**分布式应用**：web，email，游戏，电商，社交网络

**通信基础设施**：提供的服务类似快递服务，服务分为无连接服务和面向连接的服务
</code></pre><h3 id="22-网络边缘">2.2 网络边缘</h3>
<p>网络按照服务的角度可以分为这三个子系统</p>
<ol>
<li>edge 边缘 <strong>主机分布式应用</strong>，组成是主机和应用程序，比方 iPhone 上的游戏</li>
<li>core 核心 <strong>通信基础设施</strong>，作用是数据交换(switch)，组成是互联的路由器，网络的网络</li>
<li>access <strong>接入网</strong> 就是把边缘接入到网络核心，核心连接着各式各样的主机，这让你可以和不同主机通信，组成是有线或者无线的通信链路</li>
</ol>
<h4 id="221-端系统">2.2.1 端系统</h4>
<p>运行应用程序</p>
<p>比如 web，email，在网络的边缘</p>
<h4 id="222-bs-模式">2.2.2 B/S 模式</h4>
<p>主从的模式</p>
<p>比如邮箱，普遍的网页服务，客户端向服务端请求数据</p>
<h4 id="223-p2p-模式peer-peer">2.2.3 P2P 模式(peer-peer)</h4>
<p>对等体模式</p>
<p>比如迅雷，电驴等文件下载应用，这种通讯是分布式的，我可以从其它迅雷客户端下载文件片段，别人也可以从我这个客户端下载文件片段</p>
<p>这些应用可能甚至没有专门的服务器，比如 KaZaA、Emule</p>
<hr>
<h4 id="224-面向连接">2.2.4 面向连接</h4>
<p><strong>可靠性</strong></p>
<p>端系统(边缘)维持面向连接(可靠的，有序的)，中间(core)并不维持这种连接</p>
<p>这里 TCP 发挥的是面向连接的作用，下层提供的服务是不可靠的，但是我要有一些协议(一些语法，语义等)保证我向上层提供的是可靠的服务(RDT(Reliable data transmission))，这个后面传输层怎么做到 RDT 的，后续再展开</p>
<p><strong>流量控制</strong></p>
<p>也是在传输层 TCP 控制的</p>
<p><strong>拥塞控制</strong></p>
<p>当网络拥塞时，发送方降低发送速率</p>
<h4 id="225-无连接">2.2.5 无连接</h4>
<p>如果我上层的端系统的应用不在乎数据传输的可靠性，那么可以考虑 UDP 协议(无连接)</p>
<p>不先建立连接，直接发送数据报文，缺点不可靠无控制，优点简单速度快</p>
<p>你想想，TCP 你考虑对方的接受速率(流量控制)，考虑网络的拥塞情况(拥塞控制)，还要先通知对方先建立连接(握手 可靠性)，你这么多愁善感，是要有时间和空间的成本，所以不如无连接的 UDP 简单迅速</p>
<p>无连接适合事务简短，对数据可靠性不在乎</p>
<h3 id="23-网络核心">2.3 网络核心</h3>
<ul>
<li>网络核心：路由器的网状网络</li>
<li>基本问题：数据怎样通过网络进行输？
<ul>
<li>电路交换：为每个呼叫预留一条专有电路：如电话网</li>
<li>分组交换：
<ul>
<li>将要传送的数据分成一个个单位：分组</li>
<li>将分组从一个路由器传到相邻路由器(hop)，一段段最终从源端传到目标端</li>
<li>每段：采用链路的最大传输能力(带宽)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="231-电路交换">2.3.1 电路交换</h4>
<p>独享，保证性能，线路建立，</p>
<p>电路(链路)(交换节点)之间分为多个片(piece)，为呼叫分配片，如果某个呼叫没有数据，那么资源片会处于空闲状态(不共享)</p>
<p>带宽分成片的方式：</p>
<ol>
<li>频分 FDM(Frequency-division multiplexing)</li>
<li>时分 TDM(Time-division multiplexing)</li>
<li>波分 WDM(Wave-division multiplexing)
<ol>
<li>光通信</li>
</ol>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./image-20220613125424870.png"
        data-srcset="./image-20220613125424870.png, ./image-20220613125424870.png 1.5x, ./image-20220613125424870.png 2x"
        data-sizes="auto"
        alt="./image-20220613125424870.png"
        title="image-20220613125424870" /></p>
<p>总结：电路交换不适合计算机之间的通信</p>
<ol>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多
<ol>
<li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>
</ol>
</li>
<li>可靠性不高？</li>
</ol>
<h4 id="232-分组交换">2.3.2 分组交换</h4>
<ol>
<li>电路(链路)(交换节点)之间不分片，使用全部带宽</li>
<li>把数据分块进行传输，称为分组(packet switch)</li>
<li>分组在每个节点之间进行存储转发，每个跳</li>
<li>为什么要先存储再转发？
<ol>
<li>为了可以链路复用，为了共享链路，不至于传输大文件时占用全部的链路，使得分组一跳一跳的时候可以进行按需使用</li>
</ol>
</li>
<li>缺点，分组交换比电路交换的时间延迟长，排队延迟和延迟</li>
<li>优点，获得网络的共享性</li>
</ol>
<p>计算时间的时候，发送和接受是一个事件的两个方面，所以计算时间算一份，而不是发送 5s，接收 5s，这是错误的，应该是这个事件的总时间为 5s</p>
<h5 id="2321-排队和延迟">2.3.2.1 排队和延迟</h5>
<p>如果太多分组经过我这个节点，我的传输速率是 1Mb/s，分组 a 的传输是 100Mb/s，那我会让它等待，如果等待队列过长，超出我路由器的缓存，分组将会被我抛弃</p>
<h5 id="2322-分组交换统计多路复用">2.3.2.2 分组交换：统计多路复用</h5>
<p>分组传输没有固定的模式，把这种模式称为统计多路复用</p>
<h5 id="2323-定性和定量分析为什么分组交换比电路交换的网络共享性更好">2.3.2.3 定性和定量分析为什么分组交换比电路交换的网络共享性更好</h5>
<h5 id="2324-分组交换的关键功能">2.3.2.4 分组交换的关键功能</h5>
<h6 id="23241-存储">2.3.2.4.1 存储</h6>
<h6 id="23242-转发">2.3.2.4.2 转发</h6>
<p>分组交换：分组的存储转发一段段从源端传到日标端，拔照有无网络层的连接，分成：</p>
<ol>
<li>数据包(datagram)
<ol>
<li>无连接</li>
<li>无状态路由器，不维护主机与主机的通信状态</li>
<li>是否 UDP 协议？</li>
</ol>
</li>
<li>虚电路(virtual circuit)
<ol>
<li>有连接</li>
<li>通过信令建立虚电路，维持主机和主机的通信状态</li>
</ol>
</li>
</ol>
<h3 id="24-接入网和物理媒体">2.4 接入网和物理媒体</h3>
<p>怎么把边缘(主机)接入网络核心(通信主体)</p>
<p>bps(bits per second)，带宽，每秒传输多少 bit</p>
<p>端系统和边缘路由器连接，按照接入方式分为：</p>
<ol>
<li>住宅接入网络(modem)</li>
<li>公司(单位)接入网络</li>
<li>无线接入网络</li>
</ol>
<p>接入网:digital subscriber line (DSL)</p>
<p>接入网：线缆网络</p>
<p>住宅接入：电缆模式</p>
<p>接入网：家庭网络</p>
<p>企业接入网络(Ethernet)</p>
<p>无线接入网络</p>
<p>物理媒体</p>
<p>物理媒体：同轴电缆、光纤</p>
<p>物理媒介：无线链路</p>
<h3 id="25-internet-结构和-isp">2.5 Internet 结构和 ISP</h3>
<h4 id="251-互联网络结构网络的网络">2.5.1 互联网络结构：网络的网络</h4>
<p>端系统通过接入 ISPs (Internet Service Providers)连 接到互联网</p>
<p>接入 ISPs 相应的必须是互联的</p>
<h3 id="26-分组延时丢失和吞吐量">2.6 分组延时、丢失和吞吐量</h3>
<h4 id="261-分组丢失和延时是怎样发生的">2.6.1 分组丢失和延时是怎样发生的？</h4>
<ul>
<li>在路由器缓冲区的分组队列
<ul>
<li>分组到达链路的速率超过了链路输出的能力</li>
<li>分组等待排到队头、被传输</li>
</ul>
</li>
</ul>
<h4 id="262-四种分组延时">2.6.2 四种分组延时</h4>
<ol>
<li>节点处理延时：
<ol>
<li>检查 bit 级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ol>
</li>
<li>排队延时
<ol>
<li>在输出链路上等待传输的 时间</li>
<li>依赖于路由器的拥塞程度</li>
</ol>
</li>
<li>传输延时
<ol>
<li>R=链路带宽(bps)</li>
<li>L=分组长度(bits)</li>
<li>将分组发送到链路上的 时间= L/R</li>
<li>存储转发延时</li>
</ol>
</li>
<li>传播延时
<ol>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度 (~2x108 m/sec)</li>
<li>传播延时 = d/s</li>
</ol>
</li>
</ol>
<h4 id="263-节点延时">2.6.3 节点延时</h4>
<p>等于四种分组延时相加</p>
<ul>
<li>dproc = 处理延时
<ul>
<li>通常是微秒数量级或更少</li>
</ul>
</li>
<li>dqueue = 排队延时
<ul>
<li>取决于拥塞程度</li>
</ul>
</li>
<li>dtrans = 传输延时 = L/R, 对低速率的链路而言很大(如拨号)，
<ul>
<li>通常为微秒级 到毫秒级</li>
</ul>
</li>
<li>dprop = 传播延时
<ul>
<li>几微秒到几百毫秒</li>
</ul>
</li>
</ul>
<h4 id="264-排队延时取决于什么">2.6.4 排队延时取决于什么？</h4>
<p>R=链路带宽 (bps)</p>
<p>L=分组长度 (bits)</p>
<p>a=分组到达队列的平均速率</p>
<p><code>流量强度 = La/R</code></p>
<h4 id="265-互联网控制报文协议">2.6.5 互联网控制报文协议</h4>
<p>ICMP</p>
<p>有一个字段是 TTL(time to live)，每一跳都减一，一旦 TTL 为 0，那么这个分组将被删除</p>
<h4 id="266-分组丢失">2.6.6 分组丢失</h4>
<p>链路的队列缓冲区容量有限</p>
<p>当分组到达一个满的队列时，该分组将会丢失</p>
<p>丢失的分组可能会被前一个节点或源端系统重 传，或根本不重传</p>
<h4 id="267-吞吐量">2.6.7 吞吐量</h4>
<p>吞吐量: 在源端和目标端之间传输的速率(数 据量/单位时间)</p>
<p>瞬间吞吐量: 在一个时间点的速率</p>
<p>平均吞吐量: 在一个长时间内平均</p>
<p>吞吐量取决于链路上最小吞吐量</p>
<p>瓶颈链路上的瓶颈带宽 限制了这条链路的吞吐量</p>
<h3 id="27-协议层次及服务模型">2.7 协议层次及服务模型</h3>
<p>网络是一个非常复杂的系统</p>
<p>复杂的系统可以使用模块化分解，进行模块之间的调用和被调用</p>
<p>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能， 通过接口为上层提供更好的服务</p>
<p>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一 组功能，功能中有其上层可以使用的功能：服务</p>
<p>在实现本层协议的时候，直接利用了下层所提供的服务</p>
<h4 id="271-协议">2.7.1 协议</h4>
<p>协议(protocol) ：对等层实体(peer entity)之间在相互 通信的过程中，需要遵循的规则的集合，水平</p>
<h4 id="272-服务">2.7.2 服务</h4>
<p>服务(Service)：低层实体向上层实体提供它们之间的 通信的能力，是通过原语(primitive)来操作的，在层间接口，垂直</p>
<h4 id="273-服务与协议的联系">2.7.3 服务与协议的联系</h4>
<p>本层协议的实现要靠下层提供的服务来实现</p>
<p>本层实体通过协议为上层提供更高级的</p>
<h4 id="274-服务service">2.7.4 服务(Service)：</h4>
<p>低层实体向上层实体提供它们之间的
通信的能力</p>
<ul>
<li>服务用户(service user)</li>
<li>服务提供者(service provider)</li>
</ul>
<h4 id="275-服务访问点-sap-services-access-point-">2.7.5 服务访问点 SAP (Services Access Point) ：</h4>
<p>上层使用下层提供的服务通过层间的接口—地点；</p>
<p>服务访问点区分是哪个服务提供者来使用，给到哪个服务访问者</p>
<p>socket</p>
<h4 id="276-原语primitive">2.7.6 原语(primitive)：</h4>
<p>服务用户使用什么形式来访问服务提供者,上层使用下层服务的形式，高层使用 低层提供的服务，以及低层向高层提供服务都是通过 服务访问原语来进行交互的&mdash;形式</p>
<h4 id="277-服务的类型">2.7.7 服务的类型</h4>
<ol>
<li>面向连接(Connection-oriented Service)</li>
<li>无连接的服务(Connectionless Service)</li>
</ol>
<h4 id="278-数据单元du">2.7.8 数据单元(DU)</h4>
<p>SAP( Service Access Point) = 服务访问点
IDU(Interface Data Unit) = 接口数据单元
SDU(Service Data Unit) = 服务数据单元
PDU(Prolocol Data Unit) = 协议数据单元
ICI( Interface Control Information) = 接口控制信息</p>
<p>SDU：上层要求我传的数据包，称为 SDU</p>
<p>ICI：控制信息，上层传给我的数据包，主要包括 SDU+ICI</p>
<p>IDU=ICI+SDU</p>
<p>本层生成的数据包是 PDU=header+SDU</p>
<h4 id="279-每一层的-pdu-叫法不同">2.7.9 每一层的 PDU 叫法不同：</h4>
<p>应用层：应用报文(message)</p>
<p>传输层：段(segment)，报文段</p>
<p>网络层：分组(面向连接)(package)，数据包(无连接)(datagram)</p>
<p>链路层：帧(frame)</p>
<p>物理层：Wave(波) bit(比特)</p>
<h4 id="2710-internet-协议栈">2.7.10 Internet 协议栈</h4>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ol>
<h4 id="2711-osi-参考模型">2.7.11 OSI 参考模型</h4>
<ol>
<li>应用层</li>
<li>表示层
<ol>
<li>表示层：允许应用解释传输的数据，比如，加密，压缩，机器相关的表示转换</li>
</ol>
</li>
<li>会话层
<ol>
<li>会话层：数据交换的同步，检查点，恢复</li>
</ol>
</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ol>
<p>这两个 Internet 协议没有的层(表示，会话)，对应的功能给到应用层去做</p>
<h3 id="28-历史">2.8 历史</h3>
<h1 id="第二章应用层-application-layer">第二章：应用层 Application layer</h1>
<h2 id="3-应用层协议原理">3 应用层协议原理</h2>
<p><strong>网络应用的体系结构</strong></p>
<p>可能的应用架构:
客户-服务器模式(C/S:client/server)
对等模式(P2P:Peer To Peer)
混合体:客户-服务器和对等体系结构</p>
<h2 id="4-客户-服务器cs体系结构">4 客户-服务器(C/S)体系结构</h2>
<p>服务器:</p>
<ul>
<li>一直运行</li>
<li>固定的 IP 地址和周知的端口号(约定)</li>
<li>扩展性:服务器场数据中心进行扩展扩展性差</li>
</ul>
<p>客户端:</p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接)</li>
<li>可能是动态 IP 地址</li>
<li>不直接与其它客户端通信</li>
</ul>
<p><strong>缺点 ：可拓展性差 达到一定能限(阈值)，性能暴跌 可靠性差</strong></p>
<h3 id="41-对等体p2p体系结构">4.1 对等体(P2P)体系结构</h3>
<ul>
<li>(几乎)没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器
<ul>
<li><strong>自扩展性-新 peer 节点带来新的</strong>
<strong>服务能力，当然也带来新的服务请求</strong></li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变地址
<ul>
<li><strong>难以管理(缺点)</strong></li>
</ul>
</li>
<li>例子:Gnutella，迅雷</li>
</ul>
<h3 id="42-cs-和-p2p-体系结构的混合体">4.2 C/S 和 P2P 体系结构的混合体</h3>
<p>Napster</p>
<ul>
<li>**文件搜索：集中 **
<ul>
<li>** 主机在中心服务器上注册其资源**</li>
<li>** 主机向中心服务器查询资源位置**</li>
</ul>
</li>
<li><strong>文件传输：P2P</strong>
<ul>
<li>** 任意 Peer 节点之间**</li>
</ul>
</li>
</ul>
<p>即时通信</p>
<ul>
<li><strong>在线检测：集中</strong>
<ul>
<li>当用户上线时，向中心服务器注册其 IP 地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li><strong>两个用户之间聊天：P2P</strong></li>
</ul>
<h3 id="43-进程通信">4.3 进程通信</h3>
<p>进程:在主机上运行的应用程序</p>
<ul>
<li>在同一个主机内，使用
<strong>进程间通信机制</strong>通信(操作系统定义)</li>
<li>不同主机，通过**交换报文(Message)**来通信
<ul>
<li>使用 OS 提供的通信服
务</li>
<li>按照应用协议交换报文
<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>客户端进程：发起通信 的进程 服务器进程：等待连接 的进程</strong></p>
<p><strong>注意：P2P 架构的应用也 有客户端进程和服务器进程之分</strong></p>
<h3 id="44-分布式进程通信需要解决的问题应用进程如何使用传输层提供的服务交换报文">4.4 分布式进程通信需要解决的问题(应用进程如何使用传输层提供的服务交换报文)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./940ee9b87ed85326e369ef3a280c01fc-20220614134552378.png"
        data-srcset="./940ee9b87ed85326e369ef3a280c01fc-20220614134552378.png, ./940ee9b87ed85326e369ef3a280c01fc-20220614134552378.png 1.5x, ./940ee9b87ed85326e369ef3a280c01fc-20220614134552378.png 2x"
        data-sizes="auto"
        alt="./940ee9b87ed85326e369ef3a280c01fc-20220614134552378.png"
        title="image-20210722150538808" /></p>
<p>问题 1：<strong>进程标示和寻址问题 (对于进程 谁发/谁收，对等层实体之间)</strong></p>
<p>问题 2：<strong>传输层-应用层提供服务是如何 (上下层间)</strong></p>
<ul>
<li>位置：层间界面的 SAP (TCP/IP ：socket)</li>
<li>形式：应用程序接口 API (TCP/IP ：socket API)</li>
</ul>
<p>问题 3：<strong>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用 (本层间)</strong></p>
<p>定义应用层协议：报文格式，解释，时序等</p>
<p>编制程序，使用 OS 提供的 API ，调用网络基础设施提 供通信服务传报文，实现应用时序等；</p>
<h4 id="441-问题-1对进程进行编址addressing">4.4.1 问题 1：对进程进行编址(addressing)</h4>
<ul>
<li>进程为了接收报文，必须有一个标识
即: SAP(发送也需要标示)
<ul>
<li><strong>主机:唯一的 32 位 IP 地址</strong>
仅仅有 IP 地址不能够唯一标示一个进程;在一台端系统上有很多应用进程在运行</li>
<li><strong>所采用的传输层协议:TCP or UDP</strong></li>
<li>**端口号(Port Numbers) 用来区分不同的应用进程 **</li>
</ul>
</li>
<li>一些知名端口号的例子:
<ul>
<li>HTTP: TCP 80 Mail: TCP 25 ftp: TCP 21</li>
</ul>
</li>
<li>一个进程:用 IP+port 标示端节点</li>
<li>本质上，一对主机进程之间的通信由 2 个端节点构成</li>
</ul>
<h4 id="442-问题-2传输层提供的服务-需要穿过层间的信息">4.4.2 问题 2：传输层提供的服务-需要穿过层间的信息</h4>
<p>层间接口必须要携带的信息</p>
<ul>
<li><strong>要传输的报文(对于本层来说:SDU)</strong> (SDU——未经本层封装的) (发的什么)</li>
<li><strong>谁传的:对方的应用进程的标示:IP+TCP(UDP)端口</strong> (谁发的)</li>
<li><strong>传给谁:对方的应用进程的标示:对方的 IP+TCP(UDP)端口号</strong> (发给谁)</li>
</ul>
<p>传输层实体(tcp 或者 udp 实体)根据这些信息进行 TCP 报文段(UDP 数据报)的封装</p>
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将 IP 地址往下交 IP 实体，用于封装 IP 数据报:源 IP,目标 IP</li>
</ul>
<blockquote>
<ul>
<li>如果 Socket API(原语)每次传输报文(穿过层间)，都携带如此多的信息，太繁琐易错，不便于管理</li>
<li>用个代号标示通信的双方或者单方: socket</li>
<li>就像 OS 打开文件返回的句柄一样
对句柄的操作，就是对文件的操作</li>
</ul>
</blockquote>
<h4 id="443-tcp-socket">4.4.3 TCP socket</h4>
<p><strong>TCP socket:</strong></p>
<ul>
<li>TCP 服务，两个进程之间的通信需要之前要建立连扫
两个进程通信会持续一段时间，通信关系稳定</li>
<li>可以用一个整数表示两个应用实体之间的通信关系
，本地标示</li>
<li>穿过层间接口的信息量最小</li>
<li>TCP socket: 源 IP,源端口，目标 IP，目标 IP,目标</li>
</ul>
<p><strong>TCP socket 是一个整数(类似文件描述符)代表一个四元组(我的 IP 和端口号 对方的 IP 和端口号)</strong>
<strong>便于管理 使得穿过层间的信息量最小</strong>
<strong>是应用层和传输层的一个约定 本地会话的标识</strong></p>
<p><strong>对于使用面向连接服务(TCP)的应用而言，套接字是 4 元组的一个具有本地意义的标识</strong></p>
<ul>
<li>
<p>4 元组: (源 IP，源 port，目标 IP，目标 port)</p>
</li>
<li>
<p>唯一的指定了一个会话(2 个进程之间的会话关系)o 应用使用这个标示，与远程的应用进程通信</p>
</li>
<li>
<p>不必在每一个报文的发送都要指定这 4 元组</p>
</li>
<li>
<p>就像使用操作系统打开一个文件，OS 返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</p>
</li>
<li>
<p>简单，便于管理</p>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./75028bacb9bb2fe1dcba35b3b7dc6bc3-20220614134552377.png"
        data-srcset="./75028bacb9bb2fe1dcba35b3b7dc6bc3-20220614134552377.png, ./75028bacb9bb2fe1dcba35b3b7dc6bc3-20220614134552377.png 1.5x, ./75028bacb9bb2fe1dcba35b3b7dc6bc3-20220614134552377.png 2x"
        data-sizes="auto"
        alt="./75028bacb9bb2fe1dcba35b3b7dc6bc3-20220614134552377.png"
        title="image-20210722160941836" /></p>
<p><strong>穿过层间接口的包括 ICI 和 SDU</strong></p>
<h4 id="444-udp-socket">4.4.4 UDP socket</h4>
<p><strong>UDP socket：</strong></p>
<ul>
<li>UDP 服务，两个进程之间的通信需要之前无需建立连接
每个报文都是独立传输的
前后报文可能给不同的分布式进程</li>
<li>因此，只能用一个整数表示本应用实体的标示
因为这个报文可能传给另外一个分布式进程·穿过层间接口的信息大小最小</li>
<li><strong>UDP socket:本 IP,本端口</strong>
<ul>
<li><strong>但是传输报文时:必须要提供对方 IP，port</strong></li>
<li><strong>接收报文时:传输层需要上传对方的 IP，port</strong></li>
</ul>
</li>
</ul>
<p><strong>对于使用无连接服务(UDP)的应用而言，套接字是 2 元组的一个具有本地意义的标识</strong></p>
<ul>
<li>2 元组: IP，port(源端指定)</li>
<li>UDP 套接字指定了应用所在的一个端节点(endpoint&gt;</li>
<li>在发送数据报时，采用创建好的本地套接字(标示 ID)，就不必在发送每个报文中指明自己所采用的 ip 和 port</li>
<li>但是在发送报文时，必须要指定对方的 ip 和 udpport(另外一个段节点)</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d8d5e26d2cd5d03f8cc498c1c4d40f7a-20220614134552417.png"
        data-srcset="./d8d5e26d2cd5d03f8cc498c1c4d40f7a-20220614134552417.png, ./d8d5e26d2cd5d03f8cc498c1c4d40f7a-20220614134552417.png 1.5x, ./d8d5e26d2cd5d03f8cc498c1c4d40f7a-20220614134552417.png 2x"
        data-sizes="auto"
        alt="./d8d5e26d2cd5d03f8cc498c1c4d40f7a-20220614134552417.png"
        title="image-20210722162951507" /></p>
<p>套接字(Socket)</p>
<p><strong>进程向套接字发送报文或从套接字接收报文</strong></p>
<p>套接字&lt;-&gt;门户</p>
<ul>
<li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的
门将报文交付给接受进程</li>
<li>接收进程从另外一端的门户收到报文(依赖于传输层设施)</li>
</ul>
<h4 id="445-问题-3如何使用传输层提供的服务实现应用">4.4.5 问题 3：如何使用传输层提供的服务实现应用</h4>
<ol>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，<strong>通过 API 调用网络基础设施提供通信服务</strong>传报文，解析报文，实现应用时序等</li>
</ol>
<h3 id="45-应用层协议">4.5 应用层协议</h3>
<p>定义了:运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换的报文类型:请求和应答报文</li>
<li>各种报文类型的<strong>语法</strong>:报文中的客个字段及其描述</li>
<li>字段的<strong>语义</strong>:即字段取值的含义进程何时、如何发送报文及对报文进行响应的<strong>规则</strong></li>
</ul>
<p>应用协议仅仅是应用的一个组成部分
Web 应用:HTTP 协议，web 客户端，web 服务器，HTML(超文本标记语言)</p>
<p>公开协议： 由 RFC 文档定义 允许互操作 如 HTTP, SMTP
专用(私有)协议： 协议不公开 如：Skype</p>
<h3 id="46-应用需要传输层提供什么样的服务">4.6 应用需要传输层提供什么样的服务？</h3>
<p>如何描述传输层的服务？</p>
<blockquote>
<p>数据丢失率
有些应用则要求 100%的可
靠数据传输(如文件)
有些应用(如音频)能容忍
一定比例以下的数据丢失</p>
<p>延迟
一些应用出于有效性考虑，对
数据传输有严格的时间限制
Internet 电话、交互式游戏 o 延迟、延迟差</p>
<p>吞吐
一些应用(如多媒体)必须
需要最小限度的吞吐，从而使得应用能够有效运转一些应用能充分利用可供使
用的吞吐(弹性应用)</p>
<p>安全性
机密性完整性
可认证性(鉴别)</p>
</blockquote>
<h3 id="47-常见应用对传输服务的要求">4.7 常见应用对传输服务的要求</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3983a5fa68ce082331936ad597f586c0-20220614134552403.png"
        data-srcset="./3983a5fa68ce082331936ad597f586c0-20220614134552403.png, ./3983a5fa68ce082331936ad597f586c0-20220614134552403.png 1.5x, ./3983a5fa68ce082331936ad597f586c0-20220614134552403.png 2x"
        data-sizes="auto"
        alt="./3983a5fa68ce082331936ad597f586c0-20220614134552403.png"
        title="image-20210722164856593" /></p>
<h3 id="48-internet-传输层提供的服务">4.8 Internet 传输层提供的服务</h3>
<p>实体：实行网络协议的软件模块或硬件模块(运行中的)</p>
<p>TCP 服务:
可靠的传输服务
流量控制:发送方不会淹没接受方
拥塞控制:当网络出现拥塞时，能抑制发送方
不能提供的服务:时间保证、最小吞吐保证和安全面向连接:要求在客户端进程和服务器进程之间建立连接</p>
<p>UDP 服务:
不可靠数据传输
不提供的服务:可靠,流量控制、拥塞控制、时间、带宽保证、建立连接
Q:为什么要有 UDP?</p>
<p><strong>UDP 存在的必要性</strong></p>
<ul>
<li>能够区分不同的进程，而 IP 服务不能
<ul>
<li>在 IP 提供的主机到主机端到端功能的基础上，区分了主机的
应用进程</li>
</ul>
</li>
<li>无需建立连接，省去了建立连接时间，适合事务性的应用</li>
<li>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用
<ul>
<li>因为为了实现可靠性(准确性、保序等)，必须付出时间代
价(检错重发〉</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据
<ul>
<li>而在 TCP 上面的应用，应用发送数据的速度和主机向网络发送
的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h3 id="49-internet-应用及其应用层协议和传输协议">4.9 Internet 应用及其应用层协议和传输协议</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4a8c42c0a9f8ce3ab3fc4a3395278fd4-20220614134552408.png"
        data-srcset="./4a8c42c0a9f8ce3ab3fc4a3395278fd4-20220614134552408.png, ./4a8c42c0a9f8ce3ab3fc4a3395278fd4-20220614134552408.png 1.5x, ./4a8c42c0a9f8ce3ab3fc4a3395278fd4-20220614134552408.png 2x"
        data-sizes="auto"
        alt="./4a8c42c0a9f8ce3ab3fc4a3395278fd4-20220614134552408.png"
        title="image-20210722165542697" /></p>
<p><strong>安全 TCP</strong></p>
<p>TCP &amp; UDP
都没有加密 明文通过互联网传输 ，甚至密码</p>
<p>SSL 提供安全性
在 TCP 上面实现，提供加密的 TCP 连接 私密性 数据完整性 端到端的鉴别</p>
<p>SSL 在应用层 应用采用 SSL 库，SSL 库使用 TCP 通信</p>
<p>SSL socket API 应用通过 API 将明文交 给 socket，SSL 将其加 密在互联网上传输 详见第 8 章</p>
<p>Https 跑在 SSL + TCP 上</p>
<h2 id="5-web-and-http">5 Web and HTTP</h2>
<p>一些术语</p>
<ul>
<li>
<p>Web 页:由一些对象组成</p>
</li>
<li>
<p>对象可以是 HTML 文件、JPEG 图像、Java 小程序、声音剪辑文件等</p>
</li>
<li>
<p>Web 页含有一个基本的 HTML 文件，该基本 HTML 文件又包含若干对象的引用(链接)</p>
</li>
<li>
<p>通过 URL 对每个对象进行引用
访问协议，用户名，口令字，端口等；</p>
</li>
<li>
<p>URL 格式:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./8c707181cbe15ca91427f3b3054bdc92-20220614134552386.png"
        data-srcset="./8c707181cbe15ca91427f3b3054bdc92-20220614134552386.png, ./8c707181cbe15ca91427f3b3054bdc92-20220614134552386.png 1.5x, ./8c707181cbe15ca91427f3b3054bdc92-20220614134552386.png 2x"
        data-sizes="auto"
        alt="./8c707181cbe15ca91427f3b3054bdc92-20220614134552386.png"
        title="image-20210722202411559" /></p>
</li>
</ul>
<h3 id="51-http-概况">5.1 HTTP 概况</h3>
<p>HTTP: 超文本传输协议
Web 的应用层协议
客户/服务器模式
客户: 请求、接收和显示 Web 对象的浏览器
服务器: 对请求进行响应， 发送对象的 Web 服务器
HTTP 1.0: RFC 1945
HTTP 1.1: RFC 206</p>
<p><strong>使用 TCP:</strong></p>
<ul>
<li><strong>客户发起一个与服务器的</strong>
<strong>TCP 连接(建立套接字)，端口号为 80</strong></li>
<li><strong>服务器接受客户的 TCP 连接</strong></li>
<li><strong>在浏览器(HTTP 客户端)</strong>
<strong>与 Web 服务器(HTTP 服务器 server)</strong>
<strong>交换 HTTP 报文(应用层协议报文)</strong></li>
<li><strong>TCP 连接关闭</strong></li>
</ul>
<p>HTTP 是无状态的 服务器并不维护关于客户的任何信息，是一个没有记忆的人~</p>
<blockquote>
<p>维护状态的协议很复杂！
必须维护历史信息(状态)
如果服务器/客户端死机，它们的状态信息可能不一致， 二者的信息必须是一致
无状态的服务器能够支持更 多的客户端</p>
</blockquote>
<h3 id="52-http-连接">5.2 HTTP 连接</h3>
<p>非持久 HTTP</p>
<p>最多只有一个对象在 TCP 连接上发送 下载多个对象需要多 个 TCP 连接 HTTP/1.0 使用非持 久连接</p>
<p>持久 HTTP</p>
<p>多个对象可以在一个 (在客户端和服务器 之间的)TCP 连接上 传输 HTTP/1.1 默认使用 持久连接</p>
<p>非持久 HTTP</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2e4e6c1c9c0f783332429a48c0f6524c-20220614134552408.png"
        data-srcset="./2e4e6c1c9c0f783332429a48c0f6524c-20220614134552408.png, ./2e4e6c1c9c0f783332429a48c0f6524c-20220614134552408.png 1.5x, ./2e4e6c1c9c0f783332429a48c0f6524c-20220614134552408.png 2x"
        data-sizes="auto"
        alt="./2e4e6c1c9c0f783332429a48c0f6524c-20220614134552408.png"
        title="image-20210722234055927" /></p>
<p>响应时间模型</p>
<p>往返时间 RTT(round-trip time)：一个小的分组从客 户端到服务器，在回到客户 端的时间(传输时间忽略)</p>
<p>响应时间： 一个 RTT 用来发起 TCP 连接 一个 RTT 用来 HTTP 请求并 等待 HTTP 响应 文件传输时间
总共：2 个 RTT + 一个对象的传输时间</p>
<p>持久 HTTP</p>
<p>非持久 HTTP 的缺点：
每个对象要 2 个 RTT
操作系统必须为每个 TCP 连接分 配资源
但浏览器通常打开并行 TCP 连接 ，以获取引用对象</p>
<p>持久 HTTP
服务器在发送响应后，仍保持 TCP 连接
在相同客户端和服务器之间的后 续请求和响应报文通过相同的连 接进行传送
客户端在遇到一个引用对象的时 候，就可以尽快发送该对象的请求</p>
<p><strong>非流水方式的持久 HTTP： 客户端只能在收到前一个响应后 才能发出新的请求 每个引用对象花费一个 RTT</strong></p>
<p><strong>流水方式的持久 HTTP： HTTP/1.1 的默认模式 客户端遇到一个引用对象就立即 产生一个请求 所有引用(小)对象只花费一个 RTT 是可能的</strong></p>
<h3 id="53-http-请求报文">5.3 HTTP 请求报文</h3>
<p>两种类型的 HTTP 报文：请求、响应
HTTP 请求报文:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d3089ecfb28d473f4bf13894f9072786-20220614134552430.png"
        data-srcset="./d3089ecfb28d473f4bf13894f9072786-20220614134552430.png, ./d3089ecfb28d473f4bf13894f9072786-20220614134552430.png 1.5x, ./d3089ecfb28d473f4bf13894f9072786-20220614134552430.png 2x"
        data-sizes="auto"
        alt="./d3089ecfb28d473f4bf13894f9072786-20220614134552430.png"
        title="image-20210722234518706" /></p>
<p>HTTP 请求报文：通用格式</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e2e85b7e3e5be6d02f04aa0bbae40827-20220614134552437.png"
        data-srcset="./e2e85b7e3e5be6d02f04aa0bbae40827-20220614134552437.png, ./e2e85b7e3e5be6d02f04aa0bbae40827-20220614134552437.png 1.5x, ./e2e85b7e3e5be6d02f04aa0bbae40827-20220614134552437.png 2x"
        data-sizes="auto"
        alt="./e2e85b7e3e5be6d02f04aa0bbae40827-20220614134552437.png"
        title="image-20210722234848572" /></p>
<p>提交表单输入(向服务器提交信息)</p>
<p>Post 方式： 网页通常包括表单输 入 包含在实体主体 (entity body )中的 输入被提交到服务器</p>
<p>URL 方式： 方法：GET 输入通过请求行的 URL 字段上载</p>
<p>例子
www. somesite.com/animalsearch?monkeys&amp;banana
http: //www. baidu.com/s?wd=xx+yy+zzz&amp;cl=3</p>
<p>参数：wd，cl 参数值：XX+YY+zzz，3</p>
<p>方法类型</p>
<p>HTTP/1.0
GET POST
HEAD
要求服务器在响应报文中 不包含请求对象 -&gt; 故障跟踪</p>
<p>HTTP/1.1 GET, POST, HEAD
PUT 将实体主体中的文件上载 到 URL 字段规定的路径
DELETE 删除 URL 字段规定的文件</p>
<h3 id="54-http-响应报文">5.4 HTTP 响应报文</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3d31208883a05b453c24c40f161e642c-20220614134552454.png"
        data-srcset="./3d31208883a05b453c24c40f161e642c-20220614134552454.png, ./3d31208883a05b453c24c40f161e642c-20220614134552454.png 1.5x, ./3d31208883a05b453c24c40f161e642c-20220614134552454.png 2x"
        data-sizes="auto"
        alt="./3d31208883a05b453c24c40f161e642c-20220614134552454.png"
        title="image-20210722235747718" /></p>
<p>HTTP 响应状态码</p>
<p>位于服务器 → 客户端的响应报文中的首行一些状态码的例子:</p>
<p>200 OK</p>
<ul>
<li>请求成功，请求对象包含在响应报文的后续部分</li>
</ul>
<p>301 Moved Permanently</p>
<ul>
<li>请求的对象己经被永久转移了;新的 URL 在响应报文的 Location:首部行中指定
客户端软件自动用新的 URL 去获取对象</li>
</ul>
<p>400 Bad Request</p>
<ul>
<li>一个通用的差错代码，表示该请求不能被服务器解读</li>
</ul>
<p>404 Not Found</p>
<ul>
<li>请求的文档在该服务上没有找到</li>
</ul>
<p>505 HTTP version Not supported</p>
<p>Trying out HTTP (client side) for yourself</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7119c3d9abdfe5b22ab36f69fc76891f-20220614134552463.png"
        data-srcset="./7119c3d9abdfe5b22ab36f69fc76891f-20220614134552463.png, ./7119c3d9abdfe5b22ab36f69fc76891f-20220614134552463.png 1.5x, ./7119c3d9abdfe5b22ab36f69fc76891f-20220614134552463.png 2x"
        data-sizes="auto"
        alt="./7119c3d9abdfe5b22ab36f69fc76891f-20220614134552463.png"
        title="image-20210723004345632" /></p>
<h3 id="55-用户-服务器状态cookies">5.5 用户-服务器状态：cookies</h3>
<p>为什么要有 cookies：因为 http 不维护用户状态(无状态协议)，所以需要有一个机制在服务器维护客户端状态</p>
<p><strong>大多数主要的门户网站使 用 cookies 4 个组成部分：</strong></p>
<p><strong>1) 在 HTTP 响应报文中有 一个 cookie 的首部行</strong></p>
<p><strong>2)在 HTTP 请求报文含有 一个 cookie 的首部行</strong></p>
<p><strong>3) 在用户端系统中保留有 一个 cookie 文件，由用户的浏览器管理</strong></p>
<p><strong>4) 在 Web 站点有一个后 端数据库</strong></p>
<p>例子：
Susan 总是用同一个 PC 使 用 Internet Explore 上网
她第一次访问了一个使 用了 Cookie 的电子商务网站
当最初的 HTTP 请求到达 服务器时，该 Web 站点 产生一个唯一的 ID，并 以此作为索引在它的后 端数据库中产生一个项</p>
<p>Cookies: 维护状态</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./755bcdc045ea1a074ec4185a1ad7f8c2-20220614134552474.png"
        data-srcset="./755bcdc045ea1a074ec4185a1ad7f8c2-20220614134552474.png, ./755bcdc045ea1a074ec4185a1ad7f8c2-20220614134552474.png 1.5x, ./755bcdc045ea1a074ec4185a1ad7f8c2-20220614134552474.png 2x"
        data-sizes="auto"
        alt="./755bcdc045ea1a074ec4185a1ad7f8c2-20220614134552474.png"
        title="image-20210723005216576" /></p>
<p>Cookies 能带来什么： 用户验证 购物车 推荐 用户状态 (Web e-mail)</p>
<p>如何维持状态： 协议端节点：在多个事务上 ，发送端和接收端维持状态 cookies: http 报文携带状 态信息</p>
<p>Cookies 与隐私：
Cookies 允许站点知道许多关于 用户的信息
可能将它知道的东西卖给第三方
使用重定向和 cookie 的搜索引 擎还能知道用户更多的信息
如通过某个用户在大量站点 上的行为，了解其个人浏览方式的大致模式
广告公司从站点获得信息</p>
<h3 id="56-web-缓存-代理服务器">5.6 Web 缓存 (代理服务器)</h3>
<p>目标：不访问**原始服务器**，就满足客户的请求</p>
<p>用户设置浏览器： 通 过缓存访问 Web</p>
<p>浏览器将所有的 HTTP 请求发给缓存
在缓存中的对象：缓存 直接返回对象
如对象不在缓存，缓存 请求原始服务器，然后 再将对象返回给客户端</p>
<p>缓存既是客户端又是服务器 通常缓存是由 ISP 安 装 (大学、公司、居 民区 ISP)</p>
<p>为什么要使用 Web 缓存 ？
** 降低客户端的请求响应时间 **
** 可以大大减少一个机构内 部网络与 Internent 接入 链路上的流量 **
** 互联网大量采用了缓存： 可以使较弱的 ICP 也能够 有效提供内容 **</p>
<p>缓存示例</p>
<p>假设 平均对象大小 = 100kb 机构内浏览器对原始服务器的 平均请求率为 = 15 请求/s 平均到浏览器的速率：1.5Mbps 机构内部路由器到原始服务器 再返回到路由器的的延时 ( Internet 延时)= 2s 接入链路带宽：1.54Mbps 结果 LAN 的流量强度 = 15%
** 接入链路上的流量强度 = 99%**
总延时 = LAN 延时 + 接入延时 + Internet 延时 = ms + 分</p>
<p><strong>t (queue) = I/(1 - I) * L / R</strong>
<strong>I——流量强度 L/R——一个分组的传输时间 排队延迟非常大</strong></p>
<p>缓存示例：更快的接入链路</p>
<p>假设 平均对象大小 = 100kb 机构内浏览器对原始服务器的 平均请求率为 = 15 请求/s 平均到浏览器的速率：1.5Mbps 机构内部路由器到原始服务器 再返回到路由器的的延时 ( Internet 延时)= 2s ** 接入链路带宽：1.54Mbps——&gt; 154Mbps** 结果 LAN 的流量强度 = 15% 接入链路上的流量强度 = 99%
** 总延时 = LAN 延时 + 接入延时 + Internet 延时 = ms + 分 + 2s**
<strong>代价: 增加了接入链路带宽(非常昂贵！)</strong></p>
<p><strong>排队延迟降低</strong></p>
<h3 id="57-缓存例子安装本地缓存">5.7 缓存例子：安装本地缓存</h3>
<p>假设 平均对象大小 = 100kb 机构内浏览器对原始服务器的平均 请求率为 = 15 请求/s 平均到浏览器的速率：1.5Mbps ** 机构内部路由器到原始服务器再返回到路由器的的延时 (Internet 延 时)= 2s** 接入链路带宽：1.54Mbps 结果 LAN 利用率: 15% 接入网络利用率： ？ 总体延迟= ? ? How to compute link utilization, delay? <strong>代价: web 缓存(廉价!)</strong></p>
<p>计算链路利用率，有缓存的延迟： 假设缓存命中率 0.4 40%请求在缓存中被满足，其他 60%的请求 需要被原始服务器满足 接入链路利用率: 60%的请求采用接入链路 进过接入链路到达浏览器的数据速 率 = 0.6*1.50 Mbps = .9 Mbps 利用率= 0.9/1.54 = .58 总体延迟： = 0.6 * (从原始服务器获取对象的 延迟) +0.4 * (从缓存获取对象的延迟)
<strong>= 0.6 (2.01) + 0.4 (msecs) = 1.2 secs 比安装 154Mbps 链路还来得小 (而且 比较便宜!)</strong></p>
<p><strong>条件 GET 方法(对象版本和服务器版本一致性问题)</strong></p>
<p>目标：如果缓存器中的对 象拷贝是最新的，就不要发送对象
缓存器: 在 HTTP 请求中指 定缓存拷贝的日期 If-modified-since: <!-- raw HTML omitted -->
服务器: 如果缓存拷贝陈 旧，则响应报文没包含对象: HTTP/1.0 304 Not Modified</p>
<h2 id="6-ftp">6 FTP*</h2>
<p>FTP: 文件传输协议</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./22d4312d501ea240706dc928117e21d9-20220614134552458.png"
        data-srcset="./22d4312d501ea240706dc928117e21d9-20220614134552458.png, ./22d4312d501ea240706dc928117e21d9-20220614134552458.png 1.5x, ./22d4312d501ea240706dc928117e21d9-20220614134552458.png 2x"
        data-sizes="auto"
        alt="./22d4312d501ea240706dc928117e21d9-20220614134552458.png"
        title="image-20210723081249382" /></p>
<p>向远程主机上传输文件或从远程主机接收文件
客户/服务器模式
客户端：发起传输的一方
服务器：远程主机
ftp: RFC 959
ftp 服务器：端口号为 21</p>
<h3 id="61-ftp-控制连接与数据连接分开">6.1 FTP: 控制连接与数据连接分开</h3>
<p>FTP 客户端与 FTP 服务器通过端口 21 联系，并使用 TCP 为传输协议
客户端通过控制连接获得身份确认
客户端通过控制连接发送命令浏览远程目录
收到一个文件传输命令时，服务器打开一个到客户端的数据连接
一个文件传输完成后，服务器关闭连接</p>
<p>** 服务器打开 第二个 TCP 数据连接用来传输另一个文件(服务器主动)**
** 控制连接： 带外( “out of band” )传送**
** FTP 服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应**
<strong>有状态的协议</strong></p>
<h3 id="62-ftp-命令响应">6.2 FTP 命令、响应</h3>
<p>命令样例：
在控制连接上以 ASCII 文本方式传送
USER username
PASS password
LIST：请服务器返回远程主 机当前目录的文件列表
RETR filename：从远程主 机的当前目录检索文件 (gets)
STOR filename：向远程主 机的当前目录存放文件 (puts)
返回码样例：
状态码和状态信息 (同 HTTP)
331 Username OK, password required
125 data connection already open; transfer starting
425 Can’t open data connection 452 Error writing file</p>
<h3 id="63-ftp-协议与-http-协议的差别">6.3 FTP 协议与 HTTP 协议的差别</h3>
<p><strong>FTP 协议是有状态的，FTP 协议的控制命令和数据传输分别在两个 TCP 上进行</strong></p>
<h2 id="7-email">7 EMail</h2>
<p>3 个主要组成部分：</p>
<p>用户代理</p>
<p>邮件服务器</p>
<p>简单邮件传输协议：SMTP</p>
<p>用户代理 (客户端软件)
又名 “邮件阅读器”
撰写、编辑和阅读邮件
如 Outlook、Foxmail
输出和输入邮件保存在服务器 上</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b4cbea417421a410967f7615d46d0eb8-20220614134552463.png"
        data-srcset="./b4cbea417421a410967f7615d46d0eb8-20220614134552463.png, ./b4cbea417421a410967f7615d46d0eb8-20220614134552463.png 1.5x, ./b4cbea417421a410967f7615d46d0eb8-20220614134552463.png 2x"
        data-sizes="auto"
        alt="./b4cbea417421a410967f7615d46d0eb8-20220614134552463.png"
        title="image-20210723084335560" /></p>
<p>邮件服务器
邮箱中管理和维护发送给用户的邮件
输出报文队列保持待发送邮件报文
邮件服务器之间的 SMTP 协议 ：发送 email 报文
客户：发送方邮件服务器
服务器：接收端邮件服务器</p>
<h3 id="71-email-smtp-rfc-2821-原理">7.1 EMail: SMTP [RFC 2821] 原理</h3>
<p>使用 TCP 在客户端和服务器之间传送报文，端口号为 25
直接传输：从发送方服务器到接收方服务器
传输的 3 个阶段 握手 传输报文 关闭
命令/响应交互
命令：ASCII 文本
响应：状态码和状态信息
报文必须为 7 位 ASCII 码 (规范传输内容)</p>
<p>举例：Alice 给 Bob 发送报文</p>
<ol>
<li>Alice 使用用户代理撰写邮件并发送给 <a href="mailto:bob@someschool.edu" rel="">bob@someschool.edu</a>
<strong>2) Alice 的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中</strong></li>
<li>SMTP 的客户端打开到 Bob 邮件服务器的 TCP 连接
<strong>4) SMTP 客户端通过 TCP 连接发送 Alice 的邮件</strong>
<strong>5) Bob 的邮件服务器将邮件放到 Bob 的邮箱</strong></li>
<li>Bob 调用他的用户代理阅读邮件</li>
</ol>
<h3 id="72-简单的-smtp-交互">7.2 简单的 SMTP 交互</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./371924baf9f2075f891fe2679a07187c-20220614134552504.png"
        data-srcset="./371924baf9f2075f891fe2679a07187c-20220614134552504.png, ./371924baf9f2075f891fe2679a07187c-20220614134552504.png 1.5x, ./371924baf9f2075f891fe2679a07187c-20220614134552504.png 2x"
        data-sizes="auto"
        alt="./371924baf9f2075f891fe2679a07187c-20220614134552504.png"
        title="image-20210723090653643" /></p>
<h3 id="73-smtp总结">7.3 SMTP：总结</h3>
<p><strong>SMTP 使用持久连接</strong>
** SMTP 要求报文(首部 和主体)为 7 位 ASCII 编 码**
<strong>SMTP 服务器使用 CRLF.CRLF 决定报文的 尾部</strong></p>
<p>HTTP 比较：
HTTP：拉(pull)
SMTP：推(push)
二者都是 ASCII 形式的命令/ 响应交互、状态码
HTTP：<strong>每个对象封装在各自的响应报文中</strong>
SMTP：<strong>多个对象包含在一个报文中</strong></p>
<h3 id="74-邮件报文格式">7.4 邮件报文格式</h3>
<p>SMTP：交换 email 报文的协议 RFC 822: 文本报文的标准：
首部行：如,
To: From: Subject:
主体
报文，只能是 ASCII 码字符</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./fd8c5863aa2757d858d8edbf9346c078-20220614134552464.png"
        data-srcset="./fd8c5863aa2757d858d8edbf9346c078-20220614134552464.png, ./fd8c5863aa2757d858d8edbf9346c078-20220614134552464.png 1.5x, ./fd8c5863aa2757d858d8edbf9346c078-20220614134552464.png 2x"
        data-sizes="auto"
        alt="./fd8c5863aa2757d858d8edbf9346c078-20220614134552464.png"
        title="image-20210723091532349" /></p>
<p>报文格式：多媒体扩展</p>
<p>MIME：多媒体邮件扩展(multimedia mail extension), RFC 2045, 2056
在报文首部用额外的行申明 MIME 内容类型</p>
<p><a href="https://juejin.cn/post/6844904197519835150" target="_blank" rel="noopener noreffer">常用 Base64 对 STMP 的 ASCII 码进行拓展 传输更多内容</a></p>
<blockquote>
<p>Base64 常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。**在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。**使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./8702424d97eb17842b46aee5e18cbe9a-20220614134552513.png"
        data-srcset="./8702424d97eb17842b46aee5e18cbe9a-20220614134552513.png, ./8702424d97eb17842b46aee5e18cbe9a-20220614134552513.png 1.5x, ./8702424d97eb17842b46aee5e18cbe9a-20220614134552513.png 2x"
        data-sizes="auto"
        alt="./8702424d97eb17842b46aee5e18cbe9a-20220614134552513.png"
        title="image-20210723091948545" /></p>
<h3 id="75-邮件访问协议">7.5 邮件访问协议</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9f0548be1601b71724bbfa3846c3ea29-20220614134552488.png"
        data-srcset="./9f0548be1601b71724bbfa3846c3ea29-20220614134552488.png, ./9f0548be1601b71724bbfa3846c3ea29-20220614134552488.png 1.5x, ./9f0548be1601b71724bbfa3846c3ea29-20220614134552488.png 2x"
        data-sizes="auto"
        alt="./9f0548be1601b71724bbfa3846c3ea29-20220614134552488.png"
        title="image-20210723101026569" /></p>
<p>两推一拉</p>
<p>SMTP: 传送到接收方的邮件服务器
邮件访问协议：从服务器访问邮件 (3 种方式)
POP：邮局访问协议(Post Office Protocol)[RFC 1939]
用户身份确认 (代理&lt;–&gt;服务器) 并下载
IMAP：Internet 邮件访问协议(Internet Mail Access Protocol)[RFC 1730]
更多特性和功能 (更复杂)
在服务器上处理存储的报文
HTTP：Hotmail , Yahoo! Mail 等
方便</p>
<p><strong>POP3 协议</strong>
用户确认阶段 客户端命令： user: 申明用户名 pass: 口令 服务器响应 +OK -ERR
事物处理阶段 客户端： list: 报文号列表 retr: 根据报文号检索报文 dele: 删除 quit</p>
<p>用户确认阶段</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0f65c907c594a1925c65c4b239135a89-20220614134552496.png"
        data-srcset="./0f65c907c594a1925c65c4b239135a89-20220614134552496.png, ./0f65c907c594a1925c65c4b239135a89-20220614134552496.png 1.5x, ./0f65c907c594a1925c65c4b239135a89-20220614134552496.png 2x"
        data-sizes="auto"
        alt="./0f65c907c594a1925c65c4b239135a89-20220614134552496.png"
        title="image-20210723101430314" /></p>
<p>事物处理阶段,</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1cefd0e23910f7c5e63d85c090da06f2-20220614134552501.png"
        data-srcset="./1cefd0e23910f7c5e63d85c090da06f2-20220614134552501.png, ./1cefd0e23910f7c5e63d85c090da06f2-20220614134552501.png 1.5x, ./1cefd0e23910f7c5e63d85c090da06f2-20220614134552501.png 2x"
        data-sizes="auto"
        alt="./1cefd0e23910f7c5e63d85c090da06f2-20220614134552501.png"
        title="image-20210723101438747" /></p>
<p>POP3
先前的例子使用 “下载 并删除”模式。
如果改变客户机，Bob 不 能阅读邮件
“下载并保留”：不同 客户机上为报文的拷贝
POP3 在会话中是无状态的</p>
<p><strong>IMAP</strong>
IMAP 服务器将每个报文 与一个文件夹联系起来
允许用户用目录来组织 报文
允许用户读取报文组件
IMAP 在会话过程中保留 用户状态：
目录名、报文 ID 与目录名 之间映射</p>
<h2 id="8-dns">8 DNS</h2>
<p>DNS(Domain Name System)</p>
<p>从域名到 IP 地址的转换(主要功能)</p>
<h3 id="81-dns-的必要性">8.1 DNS 的必要性</h3>
<p>IP 地址标识主机、路由器
<strong>但 IP 地址不好记忆，不便人类使用(没有意义)</strong>
<strong>人类一般倾向于使用一些有意义的字符串来标识 Internet 上的设备</strong>
<strong>例如：qzheng@ustc.edu.cn</strong>
<strong>所在的邮件服务器 <a href="https://www.ustc.edu.cn" target="_blank" rel="noopener noreffer">www.ustc.edu.cn</a> 所在的 web 服务器</strong></p>
<p>存在着“字符串”—IP 地址的转换的必要性
人类用户提供要访问机器的“字符串”名称
由 DNS 负责转换成为二进制的网络地址</p>
<p>DNS 系统需要解决的问题</p>
<p>问题 1：如何命名设备
用有意义的字符串：好记，便于人类用使用
解决一个平面命名的重名问题：层次化命名
问题 2：如何完成名字到 IP 地址的转换
分布式的数据库维护和响应名字查询
问题 3：如何维护：增加或者删除一个域，需 要在域名系统中做哪些工作</p>
<p>DNS(Domain Name System)的历史</p>
<p>ARPANET 的名字解析解决方案
主机名：没有层次的一个字符串(一个平面)
存在着一个(集中)维护站：维护着一张 主机名-IP 地址 的映射文件：Hosts.txt
每台主机定时从维护站取文件
ARPANET 解决方案的问题 当网络中主机数量很大时 没有层次的主机名称很难分配</p>
<h3 id="82-dnsdomain-name-system总体思路和目标">8.2 DNS(Domain Name System)总体思路和目标</h3>
<p>DNS 的主要思路
<strong>分层的、基于域的命名机制</strong>
<strong>若干分布式的数据库完成名字到 IP 地址的转换</strong>
<strong>运行在 UDP 之上端口号为 53 的应用服务</strong>
核心的 Internet 功能，但以应用层协议实现
<strong>在网络边缘处理复杂性 (互联网最核心的功能(DNS)在边缘系统实现的)</strong></p>
<p>DNS 主要目的：
实现主机名-IP 地址的转换(name/IP translate) (主要功能)
其它目的
<strong>主机别名到 规范名字 的转换：Host aliasing</strong>
<strong>邮件服务器别名到邮件服务器的 正规名字 的转换：Mail server aliasing</strong>
<strong>负载均衡：Load Distribution(分配具体的服务器提供服务)</strong></p>
<h3 id="83-问题-1dns-名字空间the-dns-name-space">8.3 问题 1：DNS 名字空间(The DNS Name Space)</h3>
<p>DNS 域名结构
一个层面命名设备会有很多重名
NDS 采用层次树状结构的 命名方法
<strong>Internet 根被划为几百个顶级域(top lever domains)</strong>
通用的(generic) .com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ; .web ; .arts ; .rec ;
<strong>国家的(countries) .cn ; .us ; .nl ; .jp</strong>
每个(子)域下面可划分为若干子域(subdomains)
树叶是主机</p>
<h4 id="831-dns-根名字服务器">8.3.1 DNS: 根名字服务器</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7140f72ce9e93c78fcad17a4a037cc43-20220614134552550.png"
        data-srcset="./7140f72ce9e93c78fcad17a4a037cc43-20220614134552550.png, ./7140f72ce9e93c78fcad17a4a037cc43-20220614134552550.png 1.5x, ./7140f72ce9e93c78fcad17a4a037cc43-20220614134552550.png 2x"
        data-sizes="auto"
        alt="./7140f72ce9e93c78fcad17a4a037cc43-20220614134552550.png"
        title="image-20210723160541606" /></p>
<p>DNS 名字空间(The DNS Name Space)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4a292d7e3924c82b2223338ffac1ed32-20220614134552532.png"
        data-srcset="./4a292d7e3924c82b2223338ffac1ed32-20220614134552532.png, ./4a292d7e3924c82b2223338ffac1ed32-20220614134552532.png 1.5x, ./4a292d7e3924c82b2223338ffac1ed32-20220614134552532.png 2x"
        data-sizes="auto"
        alt="./4a292d7e3924c82b2223338ffac1ed32-20220614134552532.png"
        title="image-20210723161151756" /></p>
<p>域名(Domain Name)
<strong>从本域往上，直到树根</strong>
<strong>中间使用“.”间隔不同的级别</strong>
例如：ustc.edu.cn
auto.ustc.edu.cn
www.auto. ustc.edu.cn
域的域名：可以用于表示一个域
主机的域名：一个域上的一个主机</p>
<p>域名的管理
一个域管理其下的子域
.jp 被划分为 ac.jp co.jp
.cn 被划分为 edu.cn com.cn
<strong>创建一个新的域，必须征得它所属域的同意</strong>
<strong>域与物理网络无关</strong>
<strong>域遵从组织界限，而不是物理网络</strong>
一个域的主机可以不在一个网络
一个网络的主机不一定在一个域
<strong>域的划分是逻辑的，而不是物理的</strong></p>
<h3 id="84-问题-2解析问题-名字服务器name-server">8.4 问题 2：解析问题-名字服务器(Name Server)</h3>
<p><strong>一个名字服务器的问题</strong>
<strong>可靠性问题：单点故障</strong>
<strong>扩展性问题：通信容量</strong>
<strong>维护问题：远距离的集中式数据库</strong></p>
<p><strong>区域(zone)</strong>
区域的划分有区域管理者自己决定
将 DNS 名字空间划分为互不相交的区域，每个区域都是 树的一部分
名字服务器：
每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record)
名字服务器允许被放置在区域之外，以保障可靠性</p>
<h4 id="841-名字空间划分为若干区域zone">8.4.1 名字空间划分为若干区域：Zone</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./8694ee78b6f0f4a32e0ea31128b39ed8-20220614134552541.png"
        data-srcset="./8694ee78b6f0f4a32e0ea31128b39ed8-20220614134552541.png, ./8694ee78b6f0f4a32e0ea31128b39ed8-20220614134552541.png 1.5x, ./8694ee78b6f0f4a32e0ea31128b39ed8-20220614134552541.png 2x"
        data-sizes="auto"
        alt="./8694ee78b6f0f4a32e0ea31128b39ed8-20220614134552541.png"
        title="image-20210723163720694" /></p>
<p><strong>权威 DNS 服务器：组织机构的 DNS 服务器， 提供组织机构服务器(如 Web 和 mail)可访问的主机和 IP 之间的映射</strong>
组织机构可以选择实现自己维护或由某个服务提供商来维护</p>
<h4 id="842-tld-服务器">8.4.2 TLD 服务器</h4>
<p>顶级域(TLD)服务器：负责顶级域名(如 com, org, net, edu 和 gov)和所有国家级的顶级域名(如 cn, uk, fr, ca, jp )
Network solutions 公司维护 com TLD 服务器
Educause 公司维护 edu TLD 服务器</p>
<h4 id="843-区域名字服务器维护资源记录">8.4.3 区域名字服务器维护资源记录</h4>
<p>资源记录(resource records)
作用：维护 域名-IP 地址(其它)的映射关系
位置：Name Server 的分布式数据库中
RR 格式: (domain_name, ttl, type,class,Value)
Domain_name: 域名
<strong>Ttl: time to live : 生存时间(权威记录，缓冲记录)</strong> <strong>缓冲是为了性能 删除是为了一致性</strong>
Class 类别 ：对于 Internet，值为 IN <strong>说明是 Internet 网</strong>
Value 值：可以是数字，域名或 ASCII 串 <strong>对应的 IP 地址</strong>
Type 类别：资源记录的类型—见下页</p>
<p>DNS 记录</p>
<p>DNS ：保存资源记录(RR)的分布式数据库
RR 格式：(name, value, type, ttl)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ecfefe38639862374d1fe8be920258e6-20220614134552550.png"
        data-srcset="./ecfefe38639862374d1fe8be920258e6-20220614134552550.png, ./ecfefe38639862374d1fe8be920258e6-20220614134552550.png 1.5x, ./ecfefe38639862374d1fe8be920258e6-20220614134552550.png 2x"
        data-sizes="auto"
        alt="./ecfefe38639862374d1fe8be920258e6-20220614134552550.png"
        title="image-20210723165002924" /></p>
<p>信息 1 (叫什么)
<strong>TYPE = NS Name 放的是子域的名字
Value 子域名字服务器(权威 DNS 服务器)的名字</strong></p>
<p>信息 2 (在哪)
<strong>Type = A Name 放的是名字(子域的名字)</strong>
<strong>Value 对应服务器的 IP 地址</strong></p>
<h3 id="85-dns-大致工作过程">8.5 DNS 大致工作过程</h3>
<p><strong>一台设备上网必备的 IP 信息</strong>
<strong>我的 IP 地址 我的子网掩码 我的 local name serve 我的 default getway(路由器)</strong></p>
<p>应用调用 解析器(resolver)
解析器作为客户 向 Name Server 发出查询报文 (封装在 UDP 段中)
Name Server 返回响应报文(name/ip)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./8b7d5db8bde58e6698a0baf28a8a22b6-20220614134552610.png"
        data-srcset="./8b7d5db8bde58e6698a0baf28a8a22b6-20220614134552610.png, ./8b7d5db8bde58e6698a0baf28a8a22b6-20220614134552610.png 1.5x, ./8b7d5db8bde58e6698a0baf28a8a22b6-20220614134552610.png 2x"
        data-sizes="auto"
        alt="./8b7d5db8bde58e6698a0baf28a8a22b6-20220614134552610.png"
        title="image-20210723165920149" /></p>
<h4 id="851-本地名字服务器local-name-server">8.5.1 本地名字服务器(Local Name Server)</h4>
<p>并不严格属于层次结构
每个 ISP (居民区的 ISP、公司、大学)都有一 个本地 DNS 服务器
也称为“默认名字服务器”
当一个主机发起一个 DNS 查询时，查询被送到 其本地 DNS 服务器
起着代理的作用，将查询转发到层次结构中</p>
<h4 id="852-名字服务器name-server">8.5.2 名字服务器(Name Server)</h4>
<p>名字解析过程
目标名字在 Local Name Server 中
情况 1：查询的名字在该区域内部
情况 2：缓存(cashing)</p>
<p>当与本地名字服务器不能解析名字时，联系根名字服务器 顺着根-TLD 一直找到 权威名字服务器</p>
<p>递归查询
<strong>名字解析负担都 放在当前联络的 名字服务器上</strong>
问题：根服务器 的负担太重
解决： 迭代查询 (iterated queries)</p>
<p>迭代查询</p>
<p>主机 cis.poly.edu 想知道主机 gaia.cs.umass.edu 的 IP 地址
<strong>根(及各级域名)服务器返回的不是查询结果，而 是下一个 NS 的地址</strong>
<strong>最后由权威名字服务器给出解析结果</strong>
当前联络的服务器给出可以联系的服务器的名字
“我不知道这个名字，但可以向这个服务器请求</p>
<h3 id="86-dns-协议报文">8.6 DNS 协议、报文</h3>
<p>DNS 协议：查询和响应报文的报文格式相同</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./75e3e7baffc0e1beb58287fc13d4af23-20220614134552632.png"
        data-srcset="./75e3e7baffc0e1beb58287fc13d4af23-20220614134552632.png, ./75e3e7baffc0e1beb58287fc13d4af23-20220614134552632.png 1.5x, ./75e3e7baffc0e1beb58287fc13d4af23-20220614134552632.png 2x"
        data-sizes="auto"
        alt="./75e3e7baffc0e1beb58287fc13d4af23-20220614134552632.png"
        title="image-20210723171209907" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./feffcfd3951666392118f568649872b3-20220614134552579.png"
        data-srcset="./feffcfd3951666392118f568649872b3-20220614134552579.png, ./feffcfd3951666392118f568649872b3-20220614134552579.png 1.5x, ./feffcfd3951666392118f568649872b3-20220614134552579.png 2x"
        data-sizes="auto"
        alt="./feffcfd3951666392118f568649872b3-20220614134552579.png"
        title="image-20210723171404280" /></p>
<p>提高性能：缓存</p>
<p>一旦名字服务器学到了一个映射，就将该映射 缓存起来
根服务器通常都在本地服务器中缓存着
使得根服务器不用经常被访问
目的：提高效率
可能存在的问题：如果情况变化，缓存结果和 权威资源记录不一致
解决方案：TTL(默认 2 天)</p>
<h3 id="87-问题-3维护问题新增一个域">8.7 问题 3：维护问题：新增一个域</h3>
<ul>
<li><strong>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</strong>
(Type = NS、 Type = A 相当于指针)</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域
的名字解析:名字-&gt;IP 地址
例子:在 com 域中建立一个“Network Utopia”</li>
<li>到注册登记机构注册域名 networkutopia.com
<ul>
<li>需要向该机构提供权威 DNS 服务器(基本的、和辅助的)的名字
和 IP 地址</li>
<li>登记机构在 com TLD 服务器中插入两条 RR 记录:
( networkutopia.com,dns1.networkutopia.com,NS )( dns1.networkutopia.com,212.212.212.1,A)</li>
</ul>
</li>
<li>在 networkutopia.com 的权威服务器中确保有
<ul>
<li>用于 Web 服务器的www.networkuptopia.com的类型为A的记录</li>
<li>用于邮件服务器 mail.networkutopia.com 的类型为 MX 的记录</li>
</ul>
</li>
</ul>
<p>攻击 DNS 总的说来，DNS 比较健壮</p>
<p>DDoS 攻击
对根服务器进行流量轰炸 攻击：发送大量 ping
没有成功
原因１：根目录服务器配置 了流量过滤器，防火墙
原因２：Local DNS 服务器 缓存了 TLD 服务器的 IP 地址, 因此无需查询根服务器</p>
<p>向 TLD 服务器流量轰炸攻击 ：发送大量查询
可能更危险
效果一般，大部分 DNS 缓存 了 TLD</p>
<p>重定向攻击
中间人攻击 截获查询，伪造回答，从而攻击 某个(DNS 回答指定的 IP)站点
DNS 中毒 发送伪造的应答给 DNS 服务器，希 望它能够缓存这个虚假的结果
技术上较困难：分布式截获和伪造 利用 DNS 基础设施进行 DDoS
伪造某个 IP 进行查询， 攻击这个 目标 IP
查询放大，响应报文比查询报文大
效果有限</p>
<p>流量是分布式 查询有几乎都有缓存，基本不需要根 ——&gt; 无根也基本安全</p>
<h2 id="9-p2p-应用">9 P2P 应用</h2>
<p>没有(或极少)一直运行的 服务器
任意端系统都可以直接通信
利用 peer 的服务能力
Peer 节点间歇上网，每次 IP 地址都有可能变化
例子:
文件分发 (BitTorrent)
流媒体(KanKan)
VoIP (Skype)</p>
<h3 id="91-文件分发-cs-vs-p2p">9.1 文件分发: C/S vs P2P</h3>
<p>问题: 从一台服务器分发文件(大小 F)到 N 个 peer 需要多少时间？</p>
<p>文件分发时间: C/S 模式</p>
<p>服务器传输： 都是由服务器 发送给 peer，服务器必须顺序 传输(上载)N 个文件拷贝:</p>
<ul>
<li><strong>发送一个 copy: F/us(上载)</strong></li>
<li><strong>发送 N 个 copy： NF/us (上载)</strong></li>
</ul>
<p>客户端: 每个客户端必须下 载一个文件拷贝</p>
<ul>
<li>dmin = 客户端最小的下载速率</li>
<li><strong>下载带宽最小的客户端下载的 时间：F/dmin (下载)</strong></li>
</ul>
<p><strong>采用 C-S 方法 将一个 F 大小的文件 分发给 N 个客户端耗时 Dc-s &gt; max{NF/us(随着 N 线性增长 ),F/dmin}</strong>
<strong>(瓶颈却决于服务器的性能和客户端性能的相对强弱)</strong></p>
<p>文件分发时间: P2P 模式</p>
<p>服务器传输：最少需要<strong>上载</strong>一份 拷贝</p>
<ul>
<li><strong>发送一个拷贝的时间：F/us (上载)</strong></li>
</ul>
<p>客户端: 每个客户端必须<strong>下载</strong>一 个拷贝</p>
<ul>
<li><strong>最小下载带宽客户单耗时: F/dmin(下载)</strong></li>
</ul>
<p>客户端: 所有客户端总体下载量 NF</p>
<ul>
<li><strong>最大上载带宽是：us(服务器的) + Sui(所有客户端的) (上载)</strong></li>
<li><strong>除了服务器可以上载，其他所有的 peer 节点都可以上载</strong></li>
</ul>
<p><strong>采用 P2P 方法 将一个 F 大小的文件 分发给 N 个客户端耗时 Dp2p &gt; max{F/us,F/dmin,NF/(us + Sui)}</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4e783354a30dcb13b36d38f12f8c20ac-20220614134552552.png"
        data-srcset="./4e783354a30dcb13b36d38f12f8c20ac-20220614134552552.png, ./4e783354a30dcb13b36d38f12f8c20ac-20220614134552552.png 1.5x, ./4e783354a30dcb13b36d38f12f8c20ac-20220614134552552.png 2x"
        data-sizes="auto"
        alt="./4e783354a30dcb13b36d38f12f8c20ac-20220614134552552.png"
        title="image-20210723173824123" /></p>
<p>C-S 线性
P2P 非线性 性能高 可拓展性强 难管理(动态性强)</p>
<p>非结构化 P2P 任意连接
DHT 结构化 P2P 如：环形、树 <strong>节点哈希 内容哈希 按一定规律存内容</strong></p>
<h3 id="92-p2p-文件共享">9.2 P2P 文件共享</h3>
<p>例子
Alice 在其笔记本电脑上 运行 P2P 客户端程序 间歇性地连接到 Internet，每次从其 ISP 得到新的 IP 地址 请求“双截棍.MP3” 应用程序显示其他有“ 双截棍.MP3” 拷贝的对 等方</p>
<p>Alice 选择其中一个对等方， 如 Bob. 文件从 Bob’s PC 传送到 Alice 的笔记本上：HTTP 当 Alice 下载时，其他用户也 可以从 Alice 处下载 Alice 的对等方既是一个 Web 客户端，也是一个瞬时 Web 服务器</p>
<p>所有的对等方都是服务器 = 可扩展性好！</p>
<h4 id="921-两大问题">9.2.1 两大问题</h4>
<p>如何定位所需资源
如何处理对等方的 加入与离开</p>
<p>可能的方案
集中
分散
半分散</p>
<h3 id="93-集中式目录">9.3 、集中式目录</h3>
<p>最初的“Napster”设计</p>
<ol>
<li>当对等方连接时，它告知
中心服务器： IP 地址 内容</li>
<li>Alice 查询 “双截棍 .MP3”</li>
<li>Alice 从 Bob 处请求文件</li>
</ol>
<p>** 单点故障 性能瓶颈 侵犯版权**
文件传输是分散的， 而定位内容则是高度集中的</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a3ef39adaf5942490eb803223e4814a9-20220614134552573.png"
        data-srcset="./a3ef39adaf5942490eb803223e4814a9-20220614134552573.png, ./a3ef39adaf5942490eb803223e4814a9-20220614134552573.png 1.5x, ./a3ef39adaf5942490eb803223e4814a9-20220614134552573.png 2x"
        data-sizes="auto"
        alt="./a3ef39adaf5942490eb803223e4814a9-20220614134552573.png"
        title="image-20210723205655842" /></p>
<h3 id="94-查询洪泛gnutella完全分布式">9.4 、查询洪泛：Gnutella(完全分布式)</h3>
<p><strong>全分布式</strong>
<strong>没有中心服务器</strong>
开放文件共享协议
<strong>许多 Gnutella 客户端 实现了 Gnutella 协议</strong>
类似 HTTP 有许多的 浏览器</p>
<p>覆盖网络：图
<strong>如果 X 和 Y 之间有一个 TCP 连接，则二者之间存在一条边</strong>
<strong>所有活动的对等方和边就是覆盖网络</strong>
边并不是物理链路
给定一个对等方，通常 所连接的节点少于 10 个</p>
<blockquote>
<p>在已有的 TCP 连接上发送查询报文
对等方转发查询报文
<strong>以反方向返回查询命中报文</strong></p>
</blockquote>
<h4 id="941-泛洪查询-flooding">9.4.1 泛洪查询 flooding</h4>
<p>我的客户端向所有邻居发出查询 所有邻居的客户端向其邻居发出查询 …
拥有资源的节点通过反向的方法将查询的结果发回来</p>
<p><strong>我的客户端就知道那个节点有资源——解决目录的问题——再向拥有资源的节点发出请求，得到资源</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b37b0798ee98efcba3bb1472309f8925-20220614134552615.png"
        data-srcset="./b37b0798ee98efcba3bb1472309f8925-20220614134552615.png, ./b37b0798ee98efcba3bb1472309f8925-20220614134552615.png 1.5x, ./b37b0798ee98efcba3bb1472309f8925-20220614134552615.png 2x"
        data-sizes="auto"
        alt="./b37b0798ee98efcba3bb1472309f8925-20220614134552615.png"
        title="image-20210723210354195" /></p>
<p>Gnutella：对等方加入(网络的建立)</p>
<ol>
<li>对等方 X 必须首先发现某些已经在覆盖网络中的其他对 等方：使用可用对等方列表 <strong>自己维持一张对等方列表(经常开机的对等方的 IP、死党列表)</strong> 联系维持列表的 Gnutella 站点</li>
<li>X 接着试图与该列表上的对等方建立 TCP 连接，直到与某个对等方 Y 建立连接</li>
<li>X 向 Y 发送一个 Ping 报文，Y 转发该 Ping 报文</li>
<li><strong>所有收到 Ping 报文的对等方以 Pong 报文响应 IP 地址、共享文件的数量及总字节数</strong></li>
<li><strong>X 收到许多 Pong 报文，然后它能建立其他 TCP 连接</strong></li>
</ol>
<h3 id="95-利用不匀称性kazaa混合体">9.5 、利用不匀称性：KaZaA(混合体)</h3>
<p><strong>每个对等方要么是一个组长，要么隶属于一个组长</strong></p>
<ul>
<li>对等方与其组长之间有 TCP 连接</li>
<li>组长对之间有 TCP 连接</li>
</ul>
<p>组长跟踪其所有的孩子的内容</p>
<p>组长与其他组长联系</p>
<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3370298f0d2317667419998ed3b6011b-20220614134552581.png"
        data-srcset="./3370298f0d2317667419998ed3b6011b-20220614134552581.png, ./3370298f0d2317667419998ed3b6011b-20220614134552581.png 1.5x, ./3370298f0d2317667419998ed3b6011b-20220614134552581.png 2x"
        data-sizes="auto"
        alt="./3370298f0d2317667419998ed3b6011b-20220614134552581.png"
        title="image-20210723211651908" /></p>
<h4 id="951-kazaa查询">9.5.1 KaZaA：查询</h4>
<p><strong>每个文件有一个散列标识码(唯一 Hash，上载时赋予)和一个描述符</strong>
客户端向其组长发送关键字查询
组长用匹配(描述)进行响应：
对每个匹配：元数据、散列标识码和 IP 地址
如果组长将查询转发给其他组长，其他组长也 以匹配进行响应
客户端选择要下载的文件
向拥有文件的对等方发送一个带散列标识码的 HTTP 请求</p>
<h4 id="952-kazaa-小技巧">9.5.2 Kazaa 小技巧</h4>
<p>请求排队</p>
<ul>
<li>限制并行上载的数量</li>
<li>确保每个被传输的文件从上载节点接收一定量的带宽</li>
</ul>
<p>激励优先权</p>
<ul>
<li>鼓励用户上载文件</li>
<li>加强系统的扩展性</li>
</ul>
<p>并行下载</p>
<ul>
<li>从多个对等方下载同一个文件的不同部分
<ul>
<li>HTTP 的字节范围首部</li>
<li>更快地检索一个文件</li>
</ul>
</li>
</ul>
<h4 id="953-distributed-hash-table-dht">9.5.3 Distributed Hash Table (DHT)</h4>
<p>** 哈希表 DHT 方案 环形 DHT 以及覆盖网络 Peer 波动**</p>
<h3 id="96-实际的例子p2p-文件分发-bittorrent">9.6 (实际的例子)P2P 文件分发： BitTorrent</h3>
<p><strong>文件被分为一个个块 256KB</strong>
<strong>每个节点有一个 bit map(hash)，用 map 标记是否具备，有则标识为 1 否则为 0</strong>
<strong>网络中的这些 peers 发送接收文件块，相互服务</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./225f7ee74bb22ea8b6984dc45f3dd502-20220614134552633.png"
        data-srcset="./225f7ee74bb22ea8b6984dc45f3dd502-20220614134552633.png, ./225f7ee74bb22ea8b6984dc45f3dd502-20220614134552633.png 1.5x, ./225f7ee74bb22ea8b6984dc45f3dd502-20220614134552633.png 2x"
        data-sizes="auto"
        alt="./225f7ee74bb22ea8b6984dc45f3dd502-20220614134552633.png"
        title="image-20210723203007411" /></p>
<p>Peer 加入 torrent:
<strong>一开始没有块(吸血鬼)，但是将会通 过其他节点处累积文件块</strong>
向跟踪服务器注册，获得 peer 节点列表，和部分 peer 节点构成邻居关系 (“连接 ”)
<strong>当 peer 下载时，该 peer 可以同时向其他节点提供上载服务</strong>
Peer 可能会变换用于交换块的 peer 节点
<strong>扰动 churn: peer 节点可能会上线或者下线</strong>
<strong>一旦一个 peer 拥有整个文件(种子)</strong>，它会(自私的)离开或者保留(利他主义)在 torrent 中</p>
<h4 id="961-bittorrent-请求发送文件块">9.6.1 BitTorrent: 请求，发送文件块</h4>
<p>请求块：
在任何给定时间，不同 peer 节点拥有一个文件块 的子集
周期性的，Alice 节点向 邻居询问他们拥有哪些块 的信息
<strong>Alice 向 peer 节点请求它 希望的块，稀缺的块(稀缺优先，对集体有利)</strong></p>
<p><strong>1、(集体提出)客户端优先请求稀缺的(稀缺优先，对集体有利)</strong>
<strong>2、(集体定的规则)优先向提供服务好的客户端服务(个人利益与集体利益绑定)</strong>
<strong>3、(造成个人遵守)客户端优先请求稀缺的 (利他等于利己)</strong></p>
<p>发送块：一报还一报 titfor-tat
<strong>Alice 向 4 个 peer 发送块，这些块向它自己提供最大带宽的服务</strong>
其他 peer 被 Alice 阻塞 (将不会 从 Alice 处获得服务)
<strong>每 10 秒重新评估(谁对它好)一次：前 4 位</strong>
<strong>每个 30 秒：随机选择其他 peer 节点，向这个节点发送块</strong>
“优化疏通” 这个节点
<strong>新选择的节点可以加入这个 top 4</strong></p>
<p>(1) Alice “优化疏通” Bob
(2) Alice 变成了 Bob 的前 4 位提供者; Bob 答谢 Alice
(3) Bob 变成了 Alice 的前 4 提供者</p>
<p><strong>更高的上载速率： 发现更好的交易伙伴，获得更快的文件传输速率!</strong></p>
<h2 id="10-cdn">10 CDN</h2>
<p>视频流化服务和 CDN：上下文</p>
<ul>
<li>视频流量：占据着互联网大部分的带宽
<ul>
<li>Netflix, YouTube: 占据 37%, 16% 的 ISP 下行流 量</li>
<li>~1B YouTube 用户, ~75M Netflix 用户</li>
</ul>
</li>
<li>挑战：规模性-如何服务者 ~1B 用户?
<ul>
<li>单个超级服务器无法提供服务(为什么)</li>
</ul>
</li>
<li>挑战：异构性
<ul>
<li>不同用户拥有不同的能力(例如：有线接入和移 动用户；带宽丰富和受限用户)</li>
</ul>
</li>
<li><strong>解决方案: 分布式的，应用层面的基础设施</strong></li>
</ul>
<blockquote>
<p>多媒体: 视频</p>
<p>视频：固定速度显示的图像序 列</p>
<ul>
<li>e.g. 24 images/sec</li>
</ul>
<p>网络视频特点：</p>
<ul>
<li>高码率：&gt;10x 于音频,高的网络带 宽需求</li>
<li>可以被压缩</li>
<li>90%以上的网络流量是视频</li>
</ul>
<p>数字化图像：像素的阵列</p>
<ul>
<li>每个像素被若干 bits 表示</li>
</ul>
<p>编码：使用图像内和图像间的 冗余来降低编码的比特数</p>
<ul>
<li>空间冗余(图像内)</li>
<li>时间冗余(相邻的图像间)</li>
</ul>
<p>CBR: (constant bit rate): 以固定速率编码</p>
<p>VBR: (variable bit rate): 视频编码速率随 时间的变化而变化</p>
</blockquote>
<h3 id="101-多媒体流化服务dash">10.1 多媒体流化服务：DASH</h3>
<p>DASH: Dynamic, Adaptive Streaming over HTTP 动态自适应</p>
<p>服务器:
将视频文件<strong>分割成多个块</strong> (流化)
每个块独立存储，<strong>编码于不同码率(8-10 种)</strong>
<strong>告示文件(manifest file): 提供不同块的 URL</strong> (自适应：自己选择)</p>
<p>客户端:
先获取告示文件
周期性地测量服务器到客户端的带宽
查询告示文件,在一个时刻请求一个块，HTTP 头部指定字 节范围
如果带宽足够，选择最大码率的视频块
会话中的不同时刻，可以切换请求不同的编码块 (取 决于当时的可用带宽)</p>
<p>“智能”客户端: 客户端自适应决定</p>
<ul>
<li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li>
<li><strong>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块)</strong></li>
<li>哪里去请求块 (可以向离自己近的服务器发送 URL，或 者向高可用带宽的服务器请求)</li>
</ul>
<p>挑战: 服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)?</p>
<h4 id="1011-选择-1-单个的大的超级服务中心megaserver">10.1.1 选择 1: 单个的、大的超级服务中心“megaserver”</h4>
<p>服务器到客户端路径上跳数较多，瓶颈链路的带宽 小导致停顿
“二八规律”决定了网络同时充斥着同一个视频的 多个拷贝，效率低(付费高、带宽浪费、效果差)
单点故障点，性能瓶颈
周边网络的拥塞</p>
<p>相当简单，但是这个方法不可扩展</p>
<h4 id="1012-选项-2-通过-cdncontent-distribution-network全网部署缓存节点存储服务内容就近为用户提供服务提高用户体验-内容加速服务">10.1.2 选项 2: 通过 CDN(content distribution network)，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验 (内容加速服务)</h4>
<ul>
<li>enter deep: 将 CDN 服务器<strong>深入到许多接入网</strong>
<ul>
<li><strong>更接近用户</strong>，数量多，离用户近，管理困难</li>
<li>Akamai, 1700 个位置</li>
</ul>
</li>
<li>bring home: <strong>部署在少数(10 个左右)关键位置(到用户的跳数较多)</strong>，如将服务器簇安装于 POP 附近(离若干 1stISP POP 较近)
<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>Limelight</li>
</ul>
</li>
</ul>
<p>CDN: <strong>在 CDN 节点中存储内容的多个拷贝</strong> 让内容靠近用户
e.g. Netflix stores copies of MadMen</p>
<p>用户从 CDN 中请求内容**(先从原服务器获取告知文件 manifest file，自适应选择块)**
(域名解析的重定向)重定向到最近的拷贝，请求内容
如果网络路径拥塞，可能选择不同的拷贝</p>
<p><strong>互联网络主机-主机之间的通信作为一种服务向用户提供</strong></p>
<h4 id="1013-ott-挑战-在拥塞的互联网上复制内容">10.1.3 OTT 挑战: 在拥塞的互联网上复制内容</h4>
<p>OTT(互联网公司越过运营商，发展基于开放互联网的各种视频及数据服务业务)，over the top</p>
<ul>
<li>从哪个 CDN 节点中获取内容？</li>
<li>用户在网络拥塞时的行为？</li>
<li>在哪些 CDN 节点中存储什么内容？</li>
</ul>
<p>案例学习: Netflix</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ee7024572c66bd6867d698e1b7c2d150-20220614134552625.png"
        data-srcset="./ee7024572c66bd6867d698e1b7c2d150-20220614134552625.png, ./ee7024572c66bd6867d698e1b7c2d150-20220614134552625.png 1.5x, ./ee7024572c66bd6867d698e1b7c2d150-20220614134552625.png 2x"
        data-sizes="auto"
        alt="./ee7024572c66bd6867d698e1b7c2d150-20220614134552625.png"
        title="image-20210724103248401" /></p>
<h2 id="11-tcp-套接字编程">11 TCP 套接字编程</h2>
<p>Socket 编程</p>
<p>应用进程使用传输层提供的服务能够交换报文，实现应用协议，实现应用
TCP/IP：应用进程使用 Socket API 访问传输服务
地点：界面上的 SAP(Socket) 方式：Socket API
<strong>目标: 学习如何构建能借助 sockets 进行通信的 C/S 应用程序</strong></p>
<p>socket: <strong>分布式应用进程之间的门</strong>，传输层协议提供的端到端服务接口</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./724efc9d80c02896a3fe80454e6edb8c-20220614134552625.png"
        data-srcset="./724efc9d80c02896a3fe80454e6edb8c-20220614134552625.png, ./724efc9d80c02896a3fe80454e6edb8c-20220614134552625.png 1.5x, ./724efc9d80c02896a3fe80454e6edb8c-20220614134552625.png 2x"
        data-sizes="auto"
        alt="./724efc9d80c02896a3fe80454e6edb8c-20220614134552625.png"
        title="image-20210724104344583" /></p>
<p>2 种传输层服务的 socket 类型:
TCP: 可靠的、**字节流**的服务
UDP: 不可靠(数据 UDP 数据报)服务</p>
<p>套接字：应用进程与端到端传输协议(TCP 或 UDP)之间 的门户
TCP 服务：从一个进程向另一个进程可靠地传输字节流</p>
<h3 id="111-过程">11.1 过程</h3>
<p>服务器首先运行，等待连接建立</p>
<p>1：服务器进程必须先处于运行状态
<strong>创建欢迎 socket</strong>
<strong>和本地端口捆绑</strong>
在欢迎 socket 上<strong>阻塞式等待</strong>接收用户的连接</p>
<p>客户端主动和服务器建立连接：</p>
<p>2：创建客户端本地套接字(隐式捆绑到本地 port)
指定服务器<strong>进程的 IP 地址和端口号</strong>，<strong>与服务器进程连接</strong></p>
<p>3 ：当与客户端连接请求到来时
<strong>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个新的 socket(与欢迎 socket 不 一样)，与客户端通信</strong>
允许服务器与多个客户端通信
使用源 IP 和源端口来区分不同的客户端</p>
<p>4：连接 API 调用有效时，客户端 P 与服务器建立了 TCP 连接</p>
<p>从应用程序的角度
TCP 在客户端和服务器进程之间 提供了可靠的、字节流(管道)服务</p>
<h3 id="112-cs-模式的应用样例">11.2 C/S 模式的应用样例</h3>
<ol>
<li>客户端从标准输入装置读 取一行字符，发送给服务 器</li>
<li>服务器从 socket 读取字符</li>
<li>服务器将字符转换成大写 ，然后返回给客户端</li>
<li>客户端从 socket 中读取一 行字符，然后打印出来</li>
</ol>
<p>实际上，这里描述了 C-S 之间交互的动作次序</p>
<p><strong>数据结构 sockaddr_in</strong>
IP 地址和 port 捆绑关系的数据结构(标示进程的端节点)</p>
<pre><code>struct sockaddr_in {
short sin_family; //AF_INET
u_short sin_port; // port
struct in_addr sin_addr ;// IP address, unsigned long
char sin_zero[8]; // align 校准
};
</code></pre>
<p><strong>数据结构 hostent</strong>
域名和 IP 地址的数据结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">hostent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">h_name</span><span class="p">;</span>	<span class="c1">//域名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="o">**</span><span class="n">h_aliases</span><span class="p">;</span>	<span class="o">/</span><span class="err">别名</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">h_addrtype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">h_length</span><span class="p">;</span> <span class="cm">/*地址长度*/</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">**</span><span class="n">h_addr_list</span><span class="p">;</span>	<span class="c1">//IP地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp"># define h_addr h_addr_list[0];
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="p">}</span>
</span></span></code></pre></div><p>作为调用域名解析函数时的参数 返回后，将 IP 地址拷贝到 sockaddr_in 的 IP 地址部分</p>
<h2 id="12-cs-socket-交互-tcp">12 C/S socket 交互: TCP</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4aab70aac1a4d85789cdbe1299abbe3b-20220614134552661.png"
        data-srcset="./4aab70aac1a4d85789cdbe1299abbe3b-20220614134552661.png, ./4aab70aac1a4d85789cdbe1299abbe3b-20220614134552661.png 1.5x, ./4aab70aac1a4d85789cdbe1299abbe3b-20220614134552661.png 2x"
        data-sizes="auto"
        alt="./4aab70aac1a4d85789cdbe1299abbe3b-20220614134552661.png"
        title="image-20210724125259562" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./aa9625b940d7f1bb89992e433cc91520-20220614134552654.png"
        data-srcset="./aa9625b940d7f1bb89992e433cc91520-20220614134552654.png, ./aa9625b940d7f1bb89992e433cc91520-20220614134552654.png 1.5x, ./aa9625b940d7f1bb89992e433cc91520-20220614134552654.png 2x"
        data-sizes="auto"
        alt="./aa9625b940d7f1bb89992e433cc91520-20220614134552654.png"
        title="image-20210724130333265" /></p>
<p>系统自己默认使用了 bind，自动分配</p>
<p>argv[1] 主机的名字 argv[2] 端口号 argv[0] 程序的名字</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./36bae2756eac7de1108ca291233adfef-20220614134552685.png"
        data-srcset="./36bae2756eac7de1108ca291233adfef-20220614134552685.png, ./36bae2756eac7de1108ca291233adfef-20220614134552685.png 1.5x, ./36bae2756eac7de1108ca291233adfef-20220614134552685.png 2x"
        data-sizes="auto"
        alt="./36bae2756eac7de1108ca291233adfef-20220614134552685.png"
        title="image-20210724130359275" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5ff2c6cebbc2c1cee02de431d54fe02a-20220614134552677.png"
        data-srcset="./5ff2c6cebbc2c1cee02de431d54fe02a-20220614134552677.png, ./5ff2c6cebbc2c1cee02de431d54fe02a-20220614134552677.png 1.5x, ./5ff2c6cebbc2c1cee02de431d54fe02a-20220614134552677.png 2x"
        data-sizes="auto"
        alt="./5ff2c6cebbc2c1cee02de431d54fe02a-20220614134552677.png"
        title="image-20210724130416518" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4a84db917c87f48bafecc3cf79c89864-20220614134553096.png"
        data-srcset="./4a84db917c87f48bafecc3cf79c89864-20220614134553096.png, ./4a84db917c87f48bafecc3cf79c89864-20220614134553096.png 1.5x, ./4a84db917c87f48bafecc3cf79c89864-20220614134553096.png 2x"
        data-sizes="auto"
        alt="./4a84db917c87f48bafecc3cf79c89864-20220614134553096.png"
        title="image-20210724130435777" /></p>
<h2 id="13-udp-套接字编程">13 UDP 套接字编程</h2>
<p>UDP: 在客户端和服务器之间 没有连接
• 没有握手
• 发送端在<strong>每一个报文中明确地指定目标的 IP 地址和端口号</strong>
• 服务器必须从收到的分组中<strong>提·取出发送端的 IP 地址和端口号</strong></p>
<p>UDP: 传送的数据可能乱序，也可能丢失</p>
<p>进程视角看 UDP 服务 UDP 为客户端和服务器提供<strong>不可靠的字节组</strong>的传送服务</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1736fbce3f78d740ff9ace69c027491e-20220614134552673.png"
        data-srcset="./1736fbce3f78d740ff9ace69c027491e-20220614134552673.png, ./1736fbce3f78d740ff9ace69c027491e-20220614134552673.png 1.5x, ./1736fbce3f78d740ff9ace69c027491e-20220614134552673.png 2x"
        data-sizes="auto"
        alt="./1736fbce3f78d740ff9ace69c027491e-20220614134552673.png"
        title="image-20210724132456460" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./cf44d856f30fad77ee1cf34303f2c0ba-20220614134552728.png"
        data-srcset="./cf44d856f30fad77ee1cf34303f2c0ba-20220614134552728.png, ./cf44d856f30fad77ee1cf34303f2c0ba-20220614134552728.png 1.5x, ./cf44d856f30fad77ee1cf34303f2c0ba-20220614134552728.png 2x"
        data-sizes="auto"
        alt="./cf44d856f30fad77ee1cf34303f2c0ba-20220614134552728.png"
        title="image-20210724141521790" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./256e8f56b603ef47686305e0b22056fa-20220614134552687.png"
        data-srcset="./256e8f56b603ef47686305e0b22056fa-20220614134552687.png, ./256e8f56b603ef47686305e0b22056fa-20220614134552687.png 1.5x, ./256e8f56b603ef47686305e0b22056fa-20220614134552687.png 2x"
        data-sizes="auto"
        alt="./256e8f56b603ef47686305e0b22056fa-20220614134552687.png"
        title="image-20210724141558002" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./033df8d997c41da2bd413e94343208c7-20220614134552751.png"
        data-srcset="./033df8d997c41da2bd413e94343208c7-20220614134552751.png, ./033df8d997c41da2bd413e94343208c7-20220614134552751.png 1.5x, ./033df8d997c41da2bd413e94343208c7-20220614134552751.png 2x"
        data-sizes="auto"
        alt="./033df8d997c41da2bd413e94343208c7-20220614134552751.png"
        title="image-20210724142042144" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3a0698dd237148a1624b3e07b677b22a-20220614134552723.png"
        data-srcset="./3a0698dd237148a1624b3e07b677b22a-20220614134552723.png, ./3a0698dd237148a1624b3e07b677b22a-20220614134552723.png 1.5x, ./3a0698dd237148a1624b3e07b677b22a-20220614134552723.png 2x"
        data-sizes="auto"
        alt="./3a0698dd237148a1624b3e07b677b22a-20220614134552723.png"
        title="image-20210724142103507" /></p>
<h2 id="14-第-2-章小结">14 第 2 章：小结</h2>
<p>应用程序体系结构
客户-服务器 P2P 混合</p>
<p>应用程序需要的服务品质描 述:
可靠性、带宽、延时、安全</p>
<p>Internet 传输层服务模式
可靠的、面向连接的服务： TCP
不可靠的数据报：UDP</p>
<p>流行的应用层协议:
HTTP
FTP
SMTP, POP, IMAP
DNS</p>
<p>Socket 编程</p>
<p>更重要的：学习协议的知识</p>
<p>应用层协议报文类型：请求/响应报文：
客户端请求信息或服务
服务器以数据、状态码进 行响应</p>
<p>报文格式：
首部：关于数据信息的字段
数据：被交换的信息</p>
<p>控制报文 vs. 数据报文
带内(一个 TCP 传两种报文)、带外 (两个 TCP)
集中式 vs. 分散式
无状态 vs. 维护状态
可靠的 vs. 不可靠的报文传输
在网络边缘处理复杂性</p>
<p>一个协议定义了在两个或多个通信实体之间交换报文的格式和 次序、以及就一条报文传输和接收或其他事件采取的动作</p>
<h1 id="第三层传输层-transmission-layer">第三层：传输层 Transmission layer</h1>
<h2 id="15-文章-31-概述和传输层服务">15 文章 3.1 概述和传输层服务</h2>
<p>传输服务和协议</p>
<ul>
<li>为运行在不同主机上的应 用进程提供逻辑通信</li>
<li>传输协议运行在端系统
<ul>
<li>发送方：将应用层的报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供应用选择
<ul>
<li>Internet: TCP(字节流的服务，不保证界限) 和 UDP</li>
</ul>
</li>
</ul>
<h3 id="151-传输层-vs-网络层">15.1 传输层 vs. 网络层</h3>
<ul>
<li>
<p>网络层服务：主机之间的逻辑通信</p>
</li>
<li>
<p>传输层服务：进程间的逻辑通信</p>
<ul>
<li>依赖于网络层的服务
<ul>
<li>延时、带宽</li>
</ul>
</li>
<li>并对网络层的服务进行增强
<ul>
<li>数据丢失、顺序混乱、 加密</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有些服务是可以加强的：不可靠 -&gt; 可靠；安全
但有些服务是不可以被加强的：带宽，延迟</p>
<h3 id="152-internet-传输层协议">15.2 Internet 传输层协议</h3>
<p>可靠的、保序的传输： TCP(字节流的服务)</p>
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
<p>不可靠、不保序的传输：UDP(数据包的服务)</p>
<ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的 IP 服务添加更多的其它额外服务</li>
</ul>
<p><strong>都不提供的服务： 延时保证 带宽保证</strong></p>
<h2 id="16-多路复用与解复用">16 多路复用与解复用</h2>
<p>多路复用/解复用(一个 TCP/UDP 实体上有很多应用进程借助其发送)</p>
<p>在发送方主机多路复用
从多个套接字接收来自多个进程的报文，<strong>根据套接字对应的 IP 地址和端口号</strong>等信息对报文段用头部加以封装 (该头部信息用于以后的<strong>解复用</strong>)</p>
<p>在接收方主机多路解复用
根据报文段的头部信息中的<strong>IP 地址和端口号将接收到的报文段发给正确的套接字</strong>(和对应的应用进程)</p>
<p>多路解复用工作原理</p>
<ul>
<li>解复用作用：TCP 或者 UDP 实体采 用哪些信息，将报文段的数据部分 交给正确的 socket，从而交给正确 的进程</li>
<li>主机收到 IP 数据报
<ul>
<li>每个数据报有源 IP 地址和目标地 址</li>
<li>每个数据报承载一个传输层报 文段</li>
<li>每个报文段有一个源端口号和 目标端口号 (特定应用有著名的端口号)</li>
</ul>
</li>
<li>主机联合使用 IP 地址和端口号将报文段发送给合适的套接字</li>
</ul>
<p>无连接(UDP)多路解复用</p>
<p>当创建 UDP 段采用端口号，可以指定： • 目标 IP 地址 • 目标端口号
当主机接收到 UDP 段时： • 检查 UDP 段中的目标端 口号 • 将 UDP 段交给具备那个端口号的套接字
<strong>目标 IP 地址，目标端口号一样发送给同一个进程</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0e8cf8c8bfdfab5f429b903cdb0169b2.png"
        data-srcset="./0e8cf8c8bfdfab5f429b903cdb0169b2.png, ./0e8cf8c8bfdfab5f429b903cdb0169b2.png 1.5x, ./0e8cf8c8bfdfab5f429b903cdb0169b2.png 2x"
        data-sizes="auto"
        alt="./0e8cf8c8bfdfab5f429b903cdb0169b2.png"
        title="image-20210725125946183" /></p>
<p>面向连接(TCP)的多路复用</p>
<p>TCP 套接字:四元组本 地标识：  源 IP 地址  源端口号  目的 IP 地址  目的端口号
解复用：接收主机用 这四个值来将数据报 定位到合适的套接字</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./80fd5e906dc07793ee2dd436cd9825f8.png"
        data-srcset="./80fd5e906dc07793ee2dd436cd9825f8.png, ./80fd5e906dc07793ee2dd436cd9825f8.png 1.5x, ./80fd5e906dc07793ee2dd436cd9825f8.png 2x"
        data-sizes="auto"
        alt="./80fd5e906dc07793ee2dd436cd9825f8.png"
        title="image-20210725125934798" /></p>
<p>socket 和 message</p>
<h2 id="17-无连接传输udp">17 无连接传输：UDP</h2>
<p>UDP: User Datagram Protocol 用户数据包协议
在 IP(主机到主机)所提供的基础上增加了一个多路复用/解复用(进程到进程)的服务</p>
<ul>
<li>
<p>“尽力而为”的服务，报文 段可能</p>
<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序(延迟不一样)</li>
</ul>
</li>
<li>
<p>无连接：</p>
<ul>
<li>UDP 发送端和接收端之间没有握手</li>
<li>每个 UDP 报文段都被独立地处理</li>
</ul>
</li>
<li>
<p>UDP 被用于:</p>
<ul>
<li>(实时)流媒体(丢失不敏感， 速率敏感、应用可控制 传输速率)</li>
<li>DNS</li>
<li>SNMP</li>
<li>事务性的应用(一次性往返搞定)</li>
</ul>
</li>
<li>
<p>在 UDP 上可行可靠传输:</p>
<ul>
<li><strong>在应用层增加可靠性</strong></li>
<li><strong>应用特定的差错恢复</strong></li>
</ul>
</li>
</ul>
<h3 id="171-udp用户数据报协议">17.1 UDP：用户数据报协议</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4cbd4debfaf203f366ffff3bb23a3fe9.png"
        data-srcset="./4cbd4debfaf203f366ffff3bb23a3fe9.png, ./4cbd4debfaf203f366ffff3bb23a3fe9.png 1.5x, ./4cbd4debfaf203f366ffff3bb23a3fe9.png 2x"
        data-sizes="auto"
        alt="./4cbd4debfaf203f366ffff3bb23a3fe9.png"
        title="image-20210725134800713" /></p>
<h3 id="172-为什么要有-udp">17.2 为什么要有 UDP?</h3>
<ol>
<li>
<p>不建立连接 (会增加延时)</p>
</li>
<li>
<p>简单：在发送端和接收端没有连接状态</p>
</li>
<li>
<p><strong>报文段的头部很小(开销小)</strong></p>
</li>
<li>
<p><strong>无拥塞控制和流量控制</strong>：UDP 可以尽可能快的发送报文段</p>
</li>
<li>
<p><strong>应用-&gt;传输的速率 = 主机-&gt;网络的速率 (忽略头部时)</strong></p>
</li>
</ol>
<p>UDP 校验和
目标： 检测在被传输报文段中的差错 (如比特反转)</p>
<p>发送方：
 将报文段的内容视为 16 比特的整数
 校验和：报文段的加法和(1 的补运算)
 发送方将校验和放在 UDP 的校验和字段</p>
<p>接收方：
 计算接收到的报文段的校验和
 检查计算出的校验和与校验和字段的内容是否相等：
 不相等––检测到差错
 <strong>相等––没有检测到差错 ，但也许还是有差错 (残存错误，为检测出来)</strong></p>
<h3 id="173-internet-校验和的例子">17.3 Internet 校验和的例子</h3>
<p>注意：当数字相加时，在最高位的进位要回卷(加到最低位上)，再加到结果上</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d8c4406356912c33f7ab7f686bcca063.png"
        data-srcset="./d8c4406356912c33f7ab7f686bcca063.png, ./d8c4406356912c33f7ab7f686bcca063.png 1.5x, ./d8c4406356912c33f7ab7f686bcca063.png 2x"
        data-sizes="auto"
        alt="./d8c4406356912c33f7ab7f686bcca063.png"
        title="image-20210725135335276" /></p>
<p> <strong>目标端：校验范围+校验和=1111111111111111 通过校验</strong>
 否则没有通过校验
 注：求和时，必须将进位回卷到结果上</p>
<h2 id="18-可靠数据传输的原理">18 可靠数据传输的原理</h2>
<p>可靠数据传输(rdt)的原理 rdt(Reliable Data Transfer)</p>
<p> rdt 在应用层、传输层和数据链路层都很重要
 是网络 Top 10 问题之一</p>
<p> 信道的不可靠特点决定了可靠数据传输协议( rdt )的复杂性</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./052231d204049a5bcef20f30a9cb65e5.png"
        data-srcset="./052231d204049a5bcef20f30a9cb65e5.png, ./052231d204049a5bcef20f30a9cb65e5.png 1.5x, ./052231d204049a5bcef20f30a9cb65e5.png 2x"
        data-sizes="auto"
        alt="./052231d204049a5bcef20f30a9cb65e5.png"
        title="image-20210725151016012" /></p>
<p> 渐增式地开发可靠数据传输协议( rdt )的发送方和接收方
 只考虑单向数据传输
 但控制信息是双向流动的！
 <strong>双向的数据传输问题实际上是 2 个单向数据传输问题的综合</strong>
 使用<strong>有限状态机 (FSM)</strong> 来描述发送方和接收方</p>
<h3 id="181-rdt10-在可靠信道上的可靠数据传输">18.1 Rdt1.0： 在可靠信道上的可靠数据传输</h3>
<p><strong>下层的信道是完全可靠的</strong></p>
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
<p>发送方和接收方的 FSM</p>
<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
<p>发送方：接收–封装–打走 接收方：解封装–交付 什么都不用干</p>
<h3 id="182-rdt20具有比特差错的信道">18.2 Rdt2.0：具有比特差错的信道</h3>
<p>下层信道可能会出错：将分组中的比特翻转
 用校验和来检测比特差错</p>
<p> 问题：怎样从差错中恢复：
 确认(ACK)：接收方显式地告诉发送方分组已被正确接收
 否定确认( NAK): 接收方显式地告诉发送方分组发生了差错
• 发送方收到 NAK 后，发送方重传分组</p>
<p> rdt2.0 中的新机制：采用差错控制编码进行差错检测
 发送方差错控制编码、缓存
 接收方使用编码检错
 接收方的反馈：控制报文(ACK，NAK)：接收方-&gt;发送方
 发送方收到反馈相应的动作</p>
<h4 id="1821-rdt20fsm-描述">18.2.1 Rdt2.0：FSM 描述</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a106c62114ef0d81a589bef24363426f.png"
        data-srcset="./a106c62114ef0d81a589bef24363426f.png, ./a106c62114ef0d81a589bef24363426f.png 1.5x, ./a106c62114ef0d81a589bef24363426f.png 2x"
        data-sizes="auto"
        alt="./a106c62114ef0d81a589bef24363426f.png"
        title="image-20210725152850739" /></p>
<p>发送方接收 nak (接收方检测出错) ，将之前封装的 package 重传，直到收到 ack 才开始下一轮的发送</p>
<h3 id="183-rdt20-的致命缺陷--rdt21">18.3 rdt2.0 的致命缺陷！-&gt; rdt2.1</h3>
<p>如果 ACK/NAK 出错？
 发送方不知道接收方发生了什么事情！
 <strong>发送方如何做？</strong>
 <strong>重传？可能重复</strong>
 <strong>不重传？可能死锁(或出 错)</strong>
 <strong>需要引入新的机制</strong>
 <strong>序号</strong></p>
<p>处理重复：
 发送方在每个分组中加 入序号
 如果 ACK/NAK 出错，发送方重传当前分组
 <strong>接收方丢弃(不发给上层)重复分组</strong>
<strong>接收方通过序号判断，是否重复接收同样的包，在进行下一次流程/发送 ack</strong></p>
<p><strong>停等协议: 发送方发送一个分组， 然后等待接收方的应答</strong></p>
<p>发送方：</p>
<ol>
<li>在分组中加入序列号
 两个序列号(0，1)就 足够了
 一次只发送一个未经确认 的分组</li>
<li>必须检测 ACK/NAK 是否 出错(需要 EDC )
状态数变成了两倍
必须记住当前分组的序列号为 0 还是 1</li>
</ol>
<p>接收方：</p>
<ol>
<li>必须检测接收到的分组是否是重复的
 状态会指示希望接收到的 分组的序号为 0 还是 1</li>
</ol>
<p>注意：接收方并不知道 发送方是否正确收到了 其 ACK/NAK</p>
<p><strong>rdt2.1 的运行</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0da0e5f875e1db5e9f0015a07e9c33b7.png"
        data-srcset="./0da0e5f875e1db5e9f0015a07e9c33b7.png, ./0da0e5f875e1db5e9f0015a07e9c33b7.png 1.5x, ./0da0e5f875e1db5e9f0015a07e9c33b7.png 2x"
        data-sizes="auto"
        alt="./0da0e5f875e1db5e9f0015a07e9c33b7.png"
        title="image-20210725154944808" /></p>
<p>接收方不知道它最后发送的 ACK/NAK 是否被正确地收到
 发送方不对收到的 ack/nak 给确认，<strong>没有所谓的确认的确认</strong>；
 接收方发送 ack，如果后面接收方收到的是：
 <strong>老分组 p0？则 ack 错误</strong>
 <strong>下一个分组？P1，ack 正确</strong></p>
<h3 id="184-rdt22无-nak-的协议">18.4 rdt2.2：无 NAK 的协议</h3>
<ul>
<li>功能同 rdt2.1，但只使用 ACK(ack 要编号)</li>
<li>接收方对最后正确接收的分组发 ACK，以替代 NAK
<ul>
<li>接收方必须显式地包含被正确接收分组的序号</li>
</ul>
</li>
<li><strong>当收到重复的 ACK(如：再次收到 ack0)时，发送方与收到 NAK 采取相同的动作：重传当前分组</strong></li>
<li>为后面的一次发送多个数据单位做一个准备
<ul>
<li>一次能够发送多个</li>
<li>每一个的应答都有：ACK，NACK；麻烦</li>
<li>使用对前一个数据单位的 ACK，代替本数据单位的 nak</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<p>NAK free</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./700d64a433b9a3bd32dc5b568d648ec3.png"
        data-srcset="./700d64a433b9a3bd32dc5b568d648ec3.png, ./700d64a433b9a3bd32dc5b568d648ec3.png 1.5x, ./700d64a433b9a3bd32dc5b568d648ec3.png 2x"
        data-sizes="auto"
        alt="./700d64a433b9a3bd32dc5b568d648ec3.png"
        title="image-20210725155525434" /></p>
<p><strong>rdt2.2 的运行</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7f9b0d1e744e1937bb07f66ddee51cab.png"
        data-srcset="./7f9b0d1e744e1937bb07f66ddee51cab.png, ./7f9b0d1e744e1937bb07f66ddee51cab.png 1.5x, ./7f9b0d1e744e1937bb07f66ddee51cab.png 2x"
        data-sizes="auto"
        alt="./7f9b0d1e744e1937bb07f66ddee51cab.png"
        title="image-20210725155546252" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./263b02acd434978f1ccf6c8fc1967b03.png"
        data-srcset="./263b02acd434978f1ccf6c8fc1967b03.png, ./263b02acd434978f1ccf6c8fc1967b03.png 1.5x, ./263b02acd434978f1ccf6c8fc1967b03.png 2x"
        data-sizes="auto"
        alt="./263b02acd434978f1ccf6c8fc1967b03.png"
        title="image-20210725155624953" /></p>
<p>1、No error 2、packet error 3、ack error</p>
<h3 id="185-rdt30具有比特差错和分组丢失的信道">18.5 rdt3.0：具有比特差错和分组丢失的信道</h3>
<p><strong>新的假设：下层信道可 能会丢失分组(数据或 ACK)</strong>
 会死锁
 机制还不够处理这种 状况：
• 检验和
• 序列号
• ACK
• 重传</p>
<ul>
<li>方法：发送方等待 ACK 一段合理的时间
发送端<strong>超时重传</strong>：如果到时没有 收到 ACK-&gt;重传</li>
<li>问题：如果分组(或 ACK )只 是被延迟了：
重传将会导致数据重复，但利用序列号已经可以处理这 个问题
接收方必须指明被正确接收的序列号</li>
<li>需要一个倒计数定时器</li>
</ul>
<p>链路层的 timeout 时间确定的 (比较集中)
传输层 timeout 时间是适应式的 (不太集中)</p>
<h4 id="1851-rdt30-的运行">18.5.1 rdt3.0 的运行</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./33c8fd7b3d5ea00c3dd9304fd26fcf9f.png"
        data-srcset="./33c8fd7b3d5ea00c3dd9304fd26fcf9f.png, ./33c8fd7b3d5ea00c3dd9304fd26fcf9f.png 1.5x, ./33c8fd7b3d5ea00c3dd9304fd26fcf9f.png 2x"
        data-sizes="auto"
        alt="./33c8fd7b3d5ea00c3dd9304fd26fcf9f.png"
        title="image-20210725161318287" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./46120ff247a054b68baa141eec446936.png"
        data-srcset="./46120ff247a054b68baa141eec446936.png, ./46120ff247a054b68baa141eec446936.png 1.5x, ./46120ff247a054b68baa141eec446936.png 2x"
        data-sizes="auto"
        alt="./46120ff247a054b68baa141eec446936.png"
        title="image-20210725161335326" /></p>
<p>1、no loss 2、packet loss 3、ACK loss <strong>4、premature timeout/ delayed ACK</strong></p>
<p> <strong>过早超时(延迟的 ACK)也能够正常工作；但是效率较低，一半的分组和确认是重复的；</strong>
 设置一个合理的超时时间也是比较重要的；</p>
<h4 id="1852-rdt30-的性能">18.5.2 rdt3.0 的性能</h4>
<p><strong>rdt3.0 可以工作，但链路容量比较大的情况下，性能很差</strong></p>
<ul>
<li>链路容量比较大，一次发一个 PDU 的不能够充分利用链路的传输能力</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./43c2ed9878440166b0bdac8fb70b2ddd.png"
        data-srcset="./43c2ed9878440166b0bdac8fb70b2ddd.png, ./43c2ed9878440166b0bdac8fb70b2ddd.png 1.5x, ./43c2ed9878440166b0bdac8fb70b2ddd.png 2x"
        data-sizes="auto"
        alt="./43c2ed9878440166b0bdac8fb70b2ddd.png"
        title="image-20210725171743570" /></p>
<ul>
<li>U sender：利用率 – 忙于发送的时间比例</li>
<li>每 30ms 发送 1KB 的分组 -&gt; 270kbps=33.75kB/s 的吞吐量(在 1 Gbps 链路上)</li>
<li>瓶颈在于：网络协议限制了物理资源的利用！</li>
</ul>
<h3 id="186-rdt30停-等操作-stop-wait">18.6 rdt3.0：停-等操作 stop-wait</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6c858583b84adfb0ca9f43598623d4f2.png"
        data-srcset="./6c858583b84adfb0ca9f43598623d4f2.png, ./6c858583b84adfb0ca9f43598623d4f2.png 1.5x, ./6c858583b84adfb0ca9f43598623d4f2.png 2x"
        data-sizes="auto"
        alt="./6c858583b84adfb0ca9f43598623d4f2.png"
        title="image-20210725171641105" /></p>
<p><strong>一次收发一个</strong></p>
<h3 id="187-流水线提高链路利用率">18.7 流水线：提高链路利用率</h3>
<p>pipeline</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./cd114fd080bb8ed27ffc6c5916207176.png"
        data-srcset="./cd114fd080bb8ed27ffc6c5916207176.png, ./cd114fd080bb8ed27ffc6c5916207176.png 1.5x, ./cd114fd080bb8ed27ffc6c5916207176.png 2x"
        data-sizes="auto"
        alt="./cd114fd080bb8ed27ffc6c5916207176.png"
        title="image-20210725175741034" /></p>
<p> 增加 n,能提高链路利用率
 但当达到某个 n,其 u=100%时,无法再通过增加 n，提高利用率
 瓶颈转移了-&gt;链路带宽</p>
<h4 id="1871-流水线协议管道化协议">18.7.1 流水线协议/管道化协议</h4>
<p>流水线：允许发送方在未得到对方确认的情况下一次发送多个 分组
 必须增加序号的范围:用多个 bit 表示分组的序号
 在发送方/接收方要有缓冲区
• 发送方缓冲：未得到确认，可能需要重传；
• 接收方缓存：上层用户取用数据的速率 ≠ 接收到的数据速率；接收到的数据可 能乱序，排序交付(可靠)</p>
<p>slide window</p>
<p>sw(sending window)</p>
<p>rw(receiving window)</p>
<p>=1</p>
<p>=1</p>
<p>stop-wait</p>
<p>流水线协议</p>
<p>&gt;1</p>
<p>=1</p>
<p>GBN</p>
<p>流水线协议</p>
<p>&gt;1</p>
<p>&gt;1</p>
<p>SR</p>
<p>两种通用的流水线协议：回退 N 步(GBN)和选择重传(SR)</p>
<h4 id="1872-发送缓冲区">18.7.2 发送缓冲区</h4>
<ul>
<li><strong>形式：内存中的一个区域，落入缓冲区的分组可以发送</strong></li>
<li><strong>功能：用于存放已发送，但是没有得到确认的分组</strong></li>
<li><strong>必要性：需要重发时可用</strong></li>
</ul>
<p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组</p>
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超 100%</li>
</ul>
<p>发送缓冲区中的分组</p>
<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去；</li>
<li><strong>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</strong></li>
</ul>
<h4 id="1873-发送窗口">18.7.3 发送窗口</h4>
<p>采用相对移动方式表示，分组不动
可缓冲范围移动，代表一段可以发送的权力</p>
<p><strong>发送窗口：发送缓冲区内容的一个范围</strong></p>
<ul>
<li>那些已发送但是未经确认分组的序号构成的空间</li>
</ul>
<p>发送窗口的最大值&lt;=发送缓冲区的值
一开始：没有发送任何一个分组</p>
<ul>
<li>后沿=前沿</li>
<li>之间为发送窗口的尺寸=0</li>
</ul>
<p>每发送一个分组，前沿前移一个单位</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./06337f2329c0bfb0423d459a01ad1ed0.png"
        data-srcset="./06337f2329c0bfb0423d459a01ad1ed0.png, ./06337f2329c0bfb0423d459a01ad1ed0.png 1.5x, ./06337f2329c0bfb0423d459a01ad1ed0.png 2x"
        data-sizes="auto"
        alt="./06337f2329c0bfb0423d459a01ad1ed0.png"
        title="image-20210725180820132" /></p>
<p>发送窗口前沿移动的极限：不能够超过<strong>发送缓冲区的大小</strong></p>
<p>发送窗口后沿移动
条件：收到老分组的确认
结果：发送缓冲区罩住新的分组，来了分组可以发送
移动的极限：不能够超过前沿</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3862c038e4369a4671a0698b709baf9c.png"
        data-srcset="./3862c038e4369a4671a0698b709baf9c.png, ./3862c038e4369a4671a0698b709baf9c.png 1.5x, ./3862c038e4369a4671a0698b709baf9c.png 2x"
        data-sizes="auto"
        alt="./3862c038e4369a4671a0698b709baf9c.png"
        title="image-20210725181322552" /></p>
<h4 id="1874-接收窗口">18.7.4 接收窗口</h4>
<p>slide window</p>
<p>sw (sending window)</p>
<p>rw (receiving window)</p>
<p>=1</p>
<p>=1</p>
<p>stop-wait</p>
<p>流水线协议</p>
<p>&gt;1</p>
<p>=1</p>
<p>GBN</p>
<p>流水线协议</p>
<p>&gt;1</p>
<p>&gt;1</p>
<p>SR</p>
<p><strong>两种通用的流水线协议：回退 N 步(GBN)和选择重传(SR)</strong></p>
<p>接收窗口 (receiving window)=接收缓冲区</p>
<ul>
<li>接收窗口用于控制哪些分组可以接收；
<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃；</li>
</ul>
</li>
<li><strong>接收窗口尺寸 Wr=1，则只能顺序接收；</strong></li>
<li><strong>接收窗口尺寸 Wr&gt;1 ，则可以乱序接收</strong>
<ul>
<li>但提交给上层的分组，要按序</li>
</ul>
</li>
</ul>
<p>例子：Wr ＝ 1，在 0 的位置；只有 0 号分组可以接收；向前滑动一个，罩在 1 的位置，如果来了第 2 号分组，则丢 弃。</p>
<p>接收窗口的滑动和发送确认</p>
<ul>
<li>滑动：
<ul>
<li>低序号的分组到来，接收窗口移动；</li>
<li>高序号分组乱序到，缓存但不交付(因为要实现 rdt，不允许失序)，不滑动</li>
</ul>
</li>
<li>发送确认：
<ul>
<li><strong>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认(累计确认)</strong></li>
<li><strong>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认(非累计确认)</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./072507181552011246a56c06344f1b10.png"
        data-srcset="./072507181552011246a56c06344f1b10.png, ./072507181552011246a56c06344f1b10.png 1.5x, ./072507181552011246a56c06344f1b10.png 2x"
        data-sizes="auto"
        alt="./072507181552011246a56c06344f1b10.png"
        title="image-20210725184310106" /></p>
<h4 id="1875-正常情况下的-2-个窗口互动">18.7.5 正常情况下的 2 个窗口互动</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b5c208c7c2011838c9f4c8788272ae0b.png"
        data-srcset="./b5c208c7c2011838c9f4c8788272ae0b.png, ./b5c208c7c2011838c9f4c8788272ae0b.png 1.5x, ./b5c208c7c2011838c9f4c8788272ae0b.png 2x"
        data-sizes="auto"
        alt="./b5c208c7c2011838c9f4c8788272ae0b.png"
        title="image-20210725184748257" /></p>
<h4 id="1876-异常情况下-gbn-的-2-窗口互动">18.7.6 异常情况下 GBN 的 2 窗口互动</h4>
<p>发送窗口</p>
<ul>
<li>
<p>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</p>
</li>
<li>
<p><strong>超时重发机制让发送端将发送窗口中的所有分组发送出去</strong></p>
</li>
<li>
<p>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围团(此时如果发送缓冲区有新的分组可以发送)</p>
</li>
</ul>
<p>接收窗口</p>
<ul>
<li>收到乱序分组，没有落入到接收窗口范界内，抛弃</li>
<li>(重复)发送老分组的确认，<strong>累计确认</strong></li>
</ul>
<h4 id="1877-异常情况下-sr-的-2-窗口互动">18.7.7 异常情况下 SR 的 2 窗口互动</h4>
<p>发送窗口</p>
<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li><strong>超时重发机制让发送端将超对的分组重新发送出去</strong></li>
<li>来了乱序分组的确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围(此时如果发送缓冲率有新的分组可以发送)</li>
</ul>
<p>接收窗口</p>
<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，<strong>单独确认</strong></li>
</ul>
<h4 id="1878-gbn-协议和-sr-协议的异同">18.7.8 GBN 协议和 SR 协议的异同</h4>
<p>相同之处  发送窗口&gt;1  一次能够可发送多个 未经确认的分组</p>
<p>不同之处</p>
<p>GBN :接收窗口尺寸=1</p>
<ul>
<li><strong>接收端：只能顺序接收</strong></li>
<li><strong>发送端：从表现来看，一旦一个 分组没有发成功，如：0,1,2,3,4 ; 假如 1 未成功，234 都发送出去 了，要返回 1 再发送；GB1(go back 1)</strong></li>
</ul>
<p>SR: 接收窗口尺寸&gt;1</p>
<ul>
<li><strong>接收端：可以乱序接收</strong></li>
<li><strong>发送端：发送 0,1,2,3,4，一旦 1 未成功，2,3,4,已发送，无需重发，选择性发送 1</strong></li>
</ul>
<p><strong>Go-back-N:</strong>
 发送端最多在流水线中有 N 个未确认的分组
 <strong>接收端只是发送累计型确认(cumulative ack)</strong>
 接收端如果发现 gap，不确认新到来的分组</p>
<p>发送端拥有对最老的 未确认分组的定时器
只需设置一个定时器
<strong>当定时器到时时，重传所有未确认分组</strong></p>
<p><strong>Selective Repeat:</strong>
 发送端最多在流水线中有 N 个未确认的分组
 接收方对每个到来的分组单独确认 individual ack (非累计确认)</p>
<p>发送方为每个未确认的分组保持一个定时器
当超时定时器到时，只是重发到时的未确认分组</p>
<h4 id="1879-运行中的-gbn">18.7.9 运行中的 GBN</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./149644b98092246e2bdf98a60ed1a237.png"
        data-srcset="./149644b98092246e2bdf98a60ed1a237.png, ./149644b98092246e2bdf98a60ed1a237.png 1.5x, ./149644b98092246e2bdf98a60ed1a237.png 2x"
        data-sizes="auto"
        alt="./149644b98092246e2bdf98a60ed1a237.png"
        title="image-20210725191547108" /></p>
<h4 id="18710-选择重传-sr-的运行">18.7.10 选择重传 SR 的运行</h4>
<p> 发送窗口的最大值(发送缓冲区)限制发送未确认分组的个数</p>
<p>发送方</p>
<blockquote>
<p>从上层接收数据：
 如果下一个可用于该分组的序 号可在发送窗口中，则发送
timeout(n):
 重新发送分组 n，重新设定定时器
ACK(n) in [sendbase,sendbase+N]:
 将分组 n 标记为已接收
 如 n 为最小未确认的分组序号， 将 base 移到下一个未确认序号</p>
</blockquote>
<p>接收方</p>
<blockquote>
<p>分组 n [rcvbase, rcvbase+N-1]
 发送 ACK(n)
 乱序：缓存
 有序：该分组及以前缓存的 序号连续的分组交付给上层 ，然后将窗口移到下一个仍 未被接收的分组
分组 n [rcvbase-N, rcvbase-1]
 ACK(n) 其它：
 忽略该分组</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./32a82ee7807c44ecc78addf728db1c18.png"
        data-srcset="./32a82ee7807c44ecc78addf728db1c18.png, ./32a82ee7807c44ecc78addf728db1c18.png 1.5x, ./32a82ee7807c44ecc78addf728db1c18.png 2x"
        data-sizes="auto"
        alt="./32a82ee7807c44ecc78addf728db1c18.png"
        title="image-20210725191937619" /></p>
<h4 id="18711-对比-gbn-和-sr">18.7.11 对比 GBN 和 SR</h4>
<p>GBN</p>
<p>SR</p>
<p>优点</p>
<p>简单，所需资源少(接收方一个 缓存单元)</p>
<p>出错时，重传一个代价小</p>
<p>缺点</p>
<p>一旦出错，回退 N 步代价大</p>
<p>复杂，所需要资源多(接收方多个 缓存单元)</p>
<p><strong>适用范围</strong></p>
<ul>
<li>出错率低：比较适合 GBN，出错非常罕见，没有必 要用复杂的 SR，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大**(延迟大、带宽大)**：比较适合 SR 而不 是 GBN，一点出错代价太大</li>
</ul>
<p><strong>窗口的最大尺寸</strong></p>
<p> GBN: 2^n -1
 SR:2^(n-1) 例
如：n=2; 序列号：0, 1, 2, 3
 GBN =3
 SR=2
SR 的例子：  接收方看不到二者的区别！  将重复数据误认为新数据 (a)</p>
<p>Q: 序号大小与窗口大小 之间的关系？</p>
<h2 id="19-面向连接的传输-tcp">19 面向连接的传输： TCP</h2>
<p>点对点：一个发送方，一个接收方</p>
<p>可靠的、按顺序的字节流：没有报文边界</p>
<p>管道化(流水线)：TCP 拥塞控制和流量控制设置窗口大小</p>
<p>发送和接收缓存</p>
<p>全双工数据：</p>
<ul>
<li>在同一连接中数据流双向 流动</li>
<li>MSS：最大报文段大小 MSS 的大小 + TCP 头部 + IP 头部 = 一个报文段</li>
</ul>
<p>面向连接：在数据交换之前，通过握 手(交换控制报文) 初始 化发送方、接收方的状态 变量</p>
<p>有流量控制：发送方不会淹没接收方</p>
<h3 id="191-tcp-报文段结构">19.1 TCP 报文段结构</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9153a93769b50b55d6c38a70b42ca4a3.png"
        data-srcset="./9153a93769b50b55d6c38a70b42ca4a3.png, ./9153a93769b50b55d6c38a70b42ca4a3.png 1.5x, ./9153a93769b50b55d6c38a70b42ca4a3.png 2x"
        data-sizes="auto"
        alt="./9153a93769b50b55d6c38a70b42ca4a3.png"
        title="image-20210726073703179" /></p>
<p><strong>序号：报文段首字节的在字节流的编号</strong></p>
<p><strong>确认号：1、期望从另一方收到的下一个字节的序号 2、累积确认</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./324df397ccb10b0e3c746980b59c81b9.png"
        data-srcset="./324df397ccb10b0e3c746980b59c81b9.png, ./324df397ccb10b0e3c746980b59c81b9.png 1.5x, ./324df397ccb10b0e3c746980b59c81b9.png 2x"
        data-sizes="auto"
        alt="./324df397ccb10b0e3c746980b59c81b9.png"
        title="image-20210726074323701" /></p>
<h4 id="1911-tcp-序号和确认号">19.1.1 TCP 序号和确认号</h4>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fPifywE9-1627286415551)(C:\Users\20662\AppData\Roaming\Typora\typora-user-images\image-20210726075010148.png)]</p>
<h4 id="1912-tcp-往返延时rtt和超时">19.1.2 TCP 往返延时(RTT)和超时</h4>
<p>怎样设置 TCP 超时？
比 RTT 要长 ，但 RTT 是变化的
太短：太早超时 ，不必要的重传
太长：对报文段丢失反应太慢，消极</p>
<p>怎样估计 RTT？
SampleRTT：测量从报文段发出到 收到确认的时间  如果有重传，忽略此次测量
SampleRTT 会变化，因此估计的 RTT 应该比较平滑  对几个最近的测量值求平均，而 不是仅用当前的 SampleRTT</p>
<p>EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT
 <strong>指数加权移动平均</strong>
 <strong>过去样本的影响呈指数衰减</strong>
 推荐值：a = 0.125</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./75825b7661be4d6adfeecbcc9d406b5a.png"
        data-srcset="./75825b7661be4d6adfeecbcc9d406b5a.png, ./75825b7661be4d6adfeecbcc9d406b5a.png 1.5x, ./75825b7661be4d6adfeecbcc9d406b5a.png 2x"
        data-sizes="auto"
        alt="./75825b7661be4d6adfeecbcc9d406b5a.png"
        title="image-20210726075613747" /></p>
<h4 id="1913-设置超时">19.1.3 设置超时</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6269cd4352d44b9715e66829636ef4de.png"
        data-srcset="./6269cd4352d44b9715e66829636ef4de.png, ./6269cd4352d44b9715e66829636ef4de.png 1.5x, ./6269cd4352d44b9715e66829636ef4de.png 2x"
        data-sizes="auto"
        alt="./6269cd4352d44b9715e66829636ef4de.png"
        title="image-20210726075813845" /></p>
<h3 id="192-tcp可靠数据传输">19.2 TCP：可靠数据传输</h3>
<p>TCP 在 IP 不可靠服务的基础上 建立了 rdt
 管道化的报文段 • GBN or SR</p>
<p> <strong>累积确认(像 GBN)</strong>
 <strong>单个重传定时器(像 GBN)</strong>
 <strong>是否可以接受乱序的，没有规范</strong></p>
<p>通过以下事件<strong>触发重传</strong>
 <strong>超时(只重发那个最早的未确认段：SR)</strong>
 <strong>重复的确认</strong>
• 例子：收到了 ACK50,之后又收到 3 个 ACK50</p>
<p>首先考虑简化的 TCP 发送方：  忽略重复的确认  忽略流量控制和拥塞控 制</p>
<h4 id="1921-tcp-发送方事件">19.2.1 TCP 发送方事件：</h4>
<p>从应用层接收数据：
 用 nextseq 创建报文段
 序号 nextseq 为报文段首字节的字节流编号
 如果还没有运行，启动定时器</p>
<p>超时：
 <strong>重传后沿最老的报文段</strong>
 <strong>重新启动定时器</strong></p>
<p>收到确认：
 如果是对尚未确认的报文段确认
 更新已被确认的报文序号
 如果当前还有未被确认的报文段，重新启动定时器 (发完，就关掉定时器)</p>
<p>TCP 重传</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./35ec1419db17a380f49031dffdb4ea93.png"
        data-srcset="./35ec1419db17a380f49031dffdb4ea93.png, ./35ec1419db17a380f49031dffdb4ea93.png 1.5x, ./35ec1419db17a380f49031dffdb4ea93.png 2x"
        data-sizes="auto"
        alt="./35ec1419db17a380f49031dffdb4ea93.png"
        title="image-20210726081314233" /></p>
<p>ACK 丢失 过早超时 对顺序收到的最高字节确认</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./092ee57de65465240c5e02fcde5fd5dd.png"
        data-srcset="./092ee57de65465240c5e02fcde5fd5dd.png, ./092ee57de65465240c5e02fcde5fd5dd.png 1.5x, ./092ee57de65465240c5e02fcde5fd5dd.png 2x"
        data-sizes="auto"
        alt="./092ee57de65465240c5e02fcde5fd5dd.png"
        title="image-20210726082045415" /></p>
<p><strong>产生 TCP ACK 的建议</strong></p>
<p>接收方的事件</p>
<p>TCP 接收方动作</p>
<p>所期望序号的报文段按序到达。 所有在期望序号之前的数据都已经被确认</p>
<p>延迟的 ACK(提高效率，少发一个 ACK)。对另一个按序报文段的到达最多等待 500ms。如果下一个报文段<strong>在这个时间间隔内没有到达</strong>，则发送一个 ACK。</p>
<p>有期望序号的报文段到达。 另一个按序报文段等待发送 ACK</p>
<p><strong>立即发送单个累积 ACK，以确认两个按序报文段。</strong></p>
<p>比期望序号大的报文段乱序到达。 检测出数据流中的间隔</p>
<p>立即发送重复的 ACK，<strong>指明下一个期待字节的序号</strong></p>
<p>能部分或完全填充接收数据间隔 的报文段到达</p>
<p>若该报文段起始于间隔(gap)的低端， 则立即发送 ACK(给确认。反映下一段的需求)。</p>
<h3 id="193-快速重传">19.3 快速重传</h3>
<p>超时周期往往太长：
在重传丢失报文段之前的延时太长</p>
<p>通过重复的 ACK 来检测 报文段丢失
 发送方通常连续发送大量 报文段
 如果报文段丢失，通常会引起多个重复的 ACK</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d9ce350b5e83e87cacd0f2063a98a74a.png"
        data-srcset="./d9ce350b5e83e87cacd0f2063a98a74a.png, ./d9ce350b5e83e87cacd0f2063a98a74a.png 1.5x, ./d9ce350b5e83e87cacd0f2063a98a74a.png 2x"
        data-sizes="auto"
        alt="./d9ce350b5e83e87cacd0f2063a98a74a.png"
        title="image-20210726083307463" /></p>
<p>如果发送方收到同一数据 的 3 个冗余 ACK，重传最 小序号的段：
 <strong>快速重传：在定时器过时之前重发报文段</strong></p>
<p> 它假设跟在被确认的数据 后面的数据丢失了</p>
<p>• 第一个 ACK 是正常的；</p>
<p>• 收到第二个该段的 ACK，表 示接收方收到一个该段后的乱序段；</p>
<p>• 收到第 3，4 个该段的 ack，表 示接收方收到该段之后的 2 个 ，3 个乱序段，可能性非常大段丢失了</p>
<p><strong>三重 ACK 接收后的快速重传</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d1f81d9d7b9e8face02b0783432400cf.png"
        data-srcset="./d1f81d9d7b9e8face02b0783432400cf.png, ./d1f81d9d7b9e8face02b0783432400cf.png 1.5x, ./d1f81d9d7b9e8face02b0783432400cf.png 2x"
        data-sizes="auto"
        alt="./d1f81d9d7b9e8face02b0783432400cf.png"
        title="image-20210726083418896" /></p>
<h3 id="194-tcp-流量控制">19.4 TCP 流量控制</h3>
<p>流量控制
接收方控制发送方，不让发送方发送的太多、太快以至于让 接收方的缓冲区溢出</p>
<p>接收方在其向发送方的 TCP 段 头部的 rwnd 字段“通告”其空闲 buffer 大小</p>
<ul>
<li>RcvBuffer 大小通过 socket 选项 设置 (典型默认大小为 4096 字 节)</li>
<li>很多操作系统自动调整 RcvBuffer</li>
</ul>
<p>发送方限制未确认(“inflight”)字节的个数 ≤ 接收 方发送过来的 rwnd 值</p>
<p>保证接收方不会被淹没</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e37df9e0aa1b7a9a0d73bd0265ae3560.png"
        data-srcset="./e37df9e0aa1b7a9a0d73bd0265ae3560.png, ./e37df9e0aa1b7a9a0d73bd0265ae3560.png 1.5x, ./e37df9e0aa1b7a9a0d73bd0265ae3560.png 2x"
        data-sizes="auto"
        alt="./e37df9e0aa1b7a9a0d73bd0265ae3560.png"
        title="image-20210726115906902" /></p>
<p>RcvWindow = 缓冲区空间 - 已经接收到未读取的空间</p>
<h3 id="195-tcp-连接管理">19.5 TCP 连接管理</h3>
<p>在正式交换数据之前，发送方和接收方握手建立通 信关系:
 <strong>同意建立连接(每一方都知道对方愿意建立连接)</strong>
 <strong>同意连接参数</strong></p>
<h4 id="1951-同意建立连接">19.5.1 同意建立连接</h4>
<p>在网络中，2 次握手建 立连接总是可行吗？
 变化的延迟(连接请求的段没有丢，但可能超时)
 由于丢失造成的重传 (e.g. req_conn(x))
 报文乱序
 相互看不到对方</p>
<p>2 次握手的失败场景：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./fb6e1019ffa5d3c80061c984cd00bceb.png"
        data-srcset="./fb6e1019ffa5d3c80061c984cd00bceb.png, ./fb6e1019ffa5d3c80061c984cd00bceb.png 1.5x, ./fb6e1019ffa5d3c80061c984cd00bceb.png 2x"
        data-sizes="auto"
        alt="./fb6e1019ffa5d3c80061c984cd00bceb.png"
        title="image-20210726121120744" /></p>
<p>1、可能发送半连接(只在服务器维护了连接)
2、老的数据被当成新的数据接收了 <strong>seq x 和 x + 1</strong></p>
<p>TCP 3 次握手</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f5ed149946b1fb4e8a488f62c9a18f4d.png"
        data-srcset="./f5ed149946b1fb4e8a488f62c9a18f4d.png, ./f5ed149946b1fb4e8a488f62c9a18f4d.png 1.5x, ./f5ed149946b1fb4e8a488f62c9a18f4d.png 2x"
        data-sizes="auto"
        alt="./f5ed149946b1fb4e8a488f62c9a18f4d.png"
        title="image-20210726121321781" /></p>
<p><strong>解决方案：变化的初始序号+双方确认对方的序号 (3 次握手)</strong></p>
<p>第一次：seq 第二次：ACK + seq 第三次：ACK</p>
<h4 id="1952-次握手解决半连接和接收老数据问题">19.5.2 次握手解决：半连接和接收老数据问题</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./91293c78578f457673a07b676ac1223e.png"
        data-srcset="./91293c78578f457673a07b676ac1223e.png, ./91293c78578f457673a07b676ac1223e.png 1.5x, ./91293c78578f457673a07b676ac1223e.png 2x"
        data-sizes="auto"
        alt="./91293c78578f457673a07b676ac1223e.png"
        title="image-20210726121605926" /></p>
<p><strong>二次握手：可能发送半连接(只在服务器维护了连接)</strong>
<strong>三次握手：客户端在第三次握手拒绝连接请求 服务器二次握手后的连接请求</strong></p>
<p><strong>二次握手：老的数据被当成新的数据接收了</strong>
<strong>三次握手：未建立连接(无半连接)，故将发来的数据丢掉</strong></p>
<p>扔掉：连接不存在， 没建立起来；连接的 序号不在当前连接的 范围之内</p>
<p><strong>若一个数据滞留时间足够长导致</strong>
<strong>在 TCP 第二次连接(两个三次握手后)到来，这个数据包大概率也会被丢弃，因为 seq 不一样，而 seq 又与时间有关</strong></p>
<h4 id="1953-tcp-关闭连接">19.5.3 TCP: 关闭连接</h4>
<ul>
<li><strong>客户端，服务器分别关闭它自己这一侧的连接</strong>
<ul>
<li><strong>发送 FIN bit = 1 的 TCP 段</strong></li>
</ul>
</li>
<li><strong>一旦接收到 FIN，用 ACK 回应</strong>
<ul>
<li><strong>接到 FIN 段，ACK 可以和它自己发出的 FIN 段一起发 送</strong></li>
</ul>
</li>
<li><strong>可以处理同时的 FIN 交换</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./04383298ef0c571cce55379818bfa185.png"
        data-srcset="./04383298ef0c571cce55379818bfa185.png, ./04383298ef0c571cce55379818bfa185.png 1.5x, ./04383298ef0c571cce55379818bfa185.png 2x"
        data-sizes="auto"
        alt="./04383298ef0c571cce55379818bfa185.png"
        title="image-20210726124018451" /></p>
<h2 id="20-拥塞控制原理">20 拥塞控制原理</h2>
<p>拥塞:
 非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力”
 与流量控制不同
 拥塞的表现:
 <strong>分组丢失 (路由器缓冲区溢出)</strong>
 <strong>分组经历比较长的延迟(在路由器的队列中排队)</strong>
 网络中前 10 位的问题!</p>
<h3 id="201-拥塞的原因代价-场景-1">20.1 拥塞的原因/代价: 场景 1</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a8380cd10510ac6be738916bebbe64d9.png"
        data-srcset="./a8380cd10510ac6be738916bebbe64d9.png, ./a8380cd10510ac6be738916bebbe64d9.png 1.5x, ./a8380cd10510ac6be738916bebbe64d9.png 2x"
        data-sizes="auto"
        alt="./a8380cd10510ac6be738916bebbe64d9.png"
        title="image-20210726125936998" /></p>
<h3 id="202-拥塞的原因代价-场景-2">20.2 拥塞的原因/代价: 场景 2</h3>
<p> 一个路由器，有限的缓冲
 分组丢失时，发送端重传
应用层的输入=应用层输出: λ(in) = λ(out)
传输层的输入包括重传: λ(in‘) &gt;= λ(in)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./939dffeff779683850d2b9facd80eaea.png"
        data-srcset="./939dffeff779683850d2b9facd80eaea.png, ./939dffeff779683850d2b9facd80eaea.png 1.5x, ./939dffeff779683850d2b9facd80eaea.png 2x"
        data-sizes="auto"
        alt="./939dffeff779683850d2b9facd80eaea.png"
        title="image-20210726130345272" /></p>
<p>理想化: 发送端有完美的信息
发送端知道什么时候路由器的缓冲是可用的
 只在缓冲可用时发送
 不会丢失: λ(in‘’) = λ(in)</p>
<p>理想化: 掌握丢失信息 分组可以丢失，在路由器由 于缓冲器满而被丢弃  如果知道分组丢失了，发 送方重传分组</p>
<p>现实情况: 重复  分组可能丢失，由于缓冲器 满而被丢弃  发送端最终超时，发送第 2 个拷贝，2 个分组都被传出</p>
<p>现实情况: 重复  分组可能丢失，由于缓冲器 满而被丢弃  发送端最终超时，发送第 2 个拷贝，2 个分组都传到</p>
<p>拥塞的“代价”:
 为了达到一个有效输出，网络需要做更多的工作(重传)
 没有必要的重传，链路中包括了多个分组的拷贝
 是那些没有丢失，经历的时间比较长(拥塞状态)但是 超时的分组
 降低了的“goodput”</p>
<p><strong>输出比输入少原因：1)重传的丢失分组；2) 没有必要重传的重复分组</strong></p>
<h3 id="203-拥塞的原因代价-场景-3">20.3 拥塞的原因/代价: 场景 3</h3>
<p>1、4 个发送端 2、多重路径 3、超时／重传</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./28bf9bbf39ce5648de0fac7b505fd2e9.png"
        data-srcset="./28bf9bbf39ce5648de0fac7b505fd2e9.png, ./28bf9bbf39ce5648de0fac7b505fd2e9.png 1.5x, ./28bf9bbf39ce5648de0fac7b505fd2e9.png 2x"
        data-sizes="auto"
        alt="./28bf9bbf39ce5648de0fac7b505fd2e9.png"
        title="image-20210726131141125" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4ebae43f126a12203fb95ca6651877c7.png"
        data-srcset="./4ebae43f126a12203fb95ca6651877c7.png, ./4ebae43f126a12203fb95ca6651877c7.png 1.5x, ./4ebae43f126a12203fb95ca6651877c7.png 2x"
        data-sizes="auto"
        alt="./4ebae43f126a12203fb95ca6651877c7.png"
        title="image-20210726131409102" /></p>
<p>又一个拥塞的代价:
 当分组丢失时，<strong>任何“关于这个分组的上游传输能力” 都被浪费了</strong></p>
<h3 id="204-拥塞控制方法">20.4 拥塞控制方法</h3>
<p>2 种常用的拥塞控制方法:</p>
<p>端到端拥塞控制:
 没有来自网络的显式反馈
 <strong>端系统根据延迟和丢失事件推断是否有拥塞</strong>
 TCP 采用的方法</p>
<p>网络辅助的拥塞控制:
 <strong>路由器提供给端系统以反馈信息</strong>
 单个 bit 置位，显示有拥塞 (SNA, DECbit, TCP/IP ECN, ATM)
 显式提供发送端可以采用的速率</p>
<h3 id="205-案例学习-atm-abr-拥塞控制">20.5 案例学习: ATM ABR 拥塞控制</h3>
<p>ABR: available bit rate:
 “弹性服务”
 <strong>如果发送端的路径“轻载 ” 发送方使用可用带宽</strong>
 <strong>如果发送方的路径拥塞了 发送方限制其发送的速度到一个 最小保障速率 上</strong></p>
<p><strong>RM (资源管理) 信元:</strong>
 由发送端发送,在数据信元中间隔插入
 RM 信元中的比特被交换机设置 (“网络辅助”) 有无拥塞
 <strong>NI bit: no increase in rate (轻微拥塞)速率不要增加了</strong>
 <strong>CI bit: congestion indication 拥塞指示</strong>
 发送端发送的 RM 信元被接收端返回, 接收端不做任何 改变</p>
<p>在 RM 信元中的 2 个字节 ER (explicit rate)字段 多大带宽
 <strong>拥塞的交换机可能会降低信元中 ER 的值</strong>
 <strong>发送端发送速度因此是 最低的可支持速率(交换机)</strong></p>
<p>数据信元中的 EFCI bit: 被拥塞的交换机设置成 1
 如果在管理信元 RM 前面的数据信元 EFCI 被设置成了 1, 接收端在 返回的 RM 信元中设置 CI bit</p>
<p>总结：网络提供一些信息，包括一些标志位的置位以及字段 (为两主机间的通信提供多大的带宽)</p>
<h2 id="21-tcp-拥塞控制">21 TCP 拥塞控制</h2>
<h3 id="211-tcp-拥塞控制机制">21.1 TCP 拥塞控制：机制</h3>
<p>端到端的拥塞控制机制
 路由器不向主机有关拥塞的反馈信息
• 路由器的负担较轻
• <strong>符合网络核心简单的 TCP/IP 架构原则</strong></p>
<p> <strong>端系统根据自身得到的信息</strong> ，判断是否发生拥塞，从而 采取动作</p>
<p>拥塞控制的几个问题
 如何检测拥塞
 轻微拥塞
 拥塞
 控制策略
 在拥塞发送时如何动 作，降低速率
• 轻微拥塞，如何降低
• 拥塞时，如何降低
 在拥塞缓解时如何动 作，增加速率</p>
<h3 id="212-tcp-拥塞控制拥塞感知">21.2 TCP 拥塞控制：拥塞感知</h3>
<p>发送端如何探测到拥塞?</p>
<ol>
<li>
<p>某个段超时了(丢失事件 )：拥塞
 超时时间到，某个段的确认没有来
 <strong>原因 1：网络拥塞(某个路由器缓冲区没空间了，被丢弃)概率大</strong>
 <strong>原因 2：出错被丢弃了(各级错误，没有通过校验，被丢弃)概率小</strong>
 一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</p>
</li>
<li>
<p><strong>有关某个段的 3 次重复 ACK：轻微拥塞</strong>
 段的第 1 个 ack，正常，确认绿段，期待红段
 段的第 2 个重复 ack，意味着红段的后一段收到了，蓝段乱序到达
 段的第 2、3、4 个 ack 重复，意味着红段的后第 2、3、4 个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大(后面 3 个段都到了， 红段都没到)
 <strong>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</strong></p>
</li>
</ol>
<h3 id="213-tcp-拥塞控制速率控制方法">21.3 TCP 拥塞控制：速率控制方法</h3>
<p>如何控制发送端发送的速率
 <strong>维持一个拥塞窗口的值：CongWin (主要手段)</strong>
 发送端限制 <strong>已发送但是未确认</strong> 的数据量**(的上限)<strong>: LastByteSent-LastByteAcked &lt;= CongWin
 从而</strong>粗略地控制**发送方的往网络中注入的速率</p>
<p><strong>RTT 往返延时</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./03ca849ceb1b6cb807634a8ea33ef522.png"
        data-srcset="./03ca849ceb1b6cb807634a8ea33ef522.png, ./03ca849ceb1b6cb807634a8ea33ef522.png 1.5x, ./03ca849ceb1b6cb807634a8ea33ef522.png 2x"
        data-sizes="auto"
        alt="./03ca849ceb1b6cb807634a8ea33ef522.png"
        title="image-20210726150610364" /></p>
<p>如何控制发送端发送的速率
 CongWin 是动态的，是感知到的网络拥塞程度的函数
 <strong>超时或者 3 个重复 ack，CongWin↓(下降)</strong>
• 超时时：<strong>CongWin 降为 1MSS</strong>，<strong>进入 SS 阶段</strong>然后再倍增到 CongWin(原) / 2(每个 RTT)，从而<strong>进入 CA 阶段</strong>
• 3 个重复 ack ：CongWin 降为 CongWin/2,CA 阶段
 否则(正常收到 Ack，没有发送以上情况)：CongWin 跃跃欲试 ↑ (上升)
• <strong>SS 阶段：加倍增加(每个 RTT)</strong>
• <strong>CA 阶段：线性增加(每个 RTT)</strong></p>
<h3 id="214-tcp-拥塞控制和流量控制的联合动作">21.4 TCP 拥塞控制和流量控制的联合动作</h3>
<p>联合控制的方法:
 发送端控制发送但是未确认的量同时也不能够超过接收 窗口，满足流量控制要求
 <strong>SendWin=min{CongWin, RecvWin}</strong>
 同时满足 拥塞控制和流量控制要求</p>
<h3 id="215-拥塞控制策略">21.5 拥塞控制策略</h3>
<p> 慢启动
 AIMD：线性增、乘性减少
 超时事件后的保守策略</p>
<h4 id="2151-tcp-慢启动">21.5.1 TCP 慢启动</h4>
<p>连接刚建立, CongWin = 1 MSS</p>
<ul>
<li>如: MSS = 1460bytes &amp; RTT = 200 msec  初始速率 = 58.4kbps</li>
</ul>
<p>可用带宽可能&raquo; MSS/RTT</p>
<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
<p>当连接开始时，指数性增加发送速率，直到发生丢失的事件</p>
<ul>
<li>1、启动初值很低 2、但是速度很快</li>
</ul>
<p>当连接开始时，指数性增 加(每个 RTT)发送速率 直到发生丢失事件
 每一个 RTT， CongWin 加倍
 每收到一个 ACK 时， CongWin 加 1(why)
 慢启动阶段：只要不超时或 3 个重复 ack，一个 RTT， CongWin 加倍</p>
<p>总结: 初始速率很慢，但是加速却是指数性的  指数增加，SS 时间很短，长期来看可以忽略</p>
<h4 id="2152-tcp-拥塞控制aimd">21.5.2 TCP 拥塞控制：AIMD</h4>
<p>乘性减: 丢失事件后将 CongWin 降为 1(ss 阶段通常可忽略，故相当于直接减少到 CongWin/2 )，将 CongWin/2 作为阈值，进入慢启动阶段(倍增直到 CongWin/2)</p>
<p>加性增： <strong>当 CongWin &gt;阈值时</strong>，一个 RTT 如没有发生丢失事件，将 CongWin 加 1MSS : 探 测</p>
<p>当收到 3 个重复的 ACKs:</p>
<ul>
<li>CongWin 减半</li>
<li>窗口(缓冲区大小)之后 线性增长</li>
</ul>
<p>当超时事件发生时:</p>
<ul>
<li>CongWin 被设置成 1 MSS，进入 SS 阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值(上次发 生拥塞的窗口的一半)时 ，再线性增加</li>
</ul>
<h3 id="216-总结-tcp-拥塞控制">21.6 总结: TCP 拥塞控制</h3>
<p>出现丢失，Threshold 设置成 CongWin 的 1/2</p>
<ul>
<li>
<p>当 CongWin ＜ Threshold, 发送端处于慢启动阶段( slow-start), 窗口指数性增长.</p>
</li>
<li>
<p>当 CongWin &gt; Threshold, 发送端处于拥塞避免阶段 (congestion-avoidance), 窗口线性增长.</p>
</li>
<li>
<p>当收到三个重复的 ACKs (triple duplicate ACK), Threshold 设置成 CongWin/2， CongWin=Threshold+3.</p>
</li>
<li>
<p>当超时事件发生时 timeout, Threshold=CongWin/2 CongWin=1 MSS，进入 SS 阶段</p>
</li>
</ul>
<h4 id="2161-tcp-发送端拥塞控制">21.6.1 TCP 发送端拥塞控制</h4>
<p>状态转换</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./bbbbb4b6baa55f084793cbf14b736f1d.png"
        data-srcset="./bbbbb4b6baa55f084793cbf14b736f1d.png, ./bbbbb4b6baa55f084793cbf14b736f1d.png 1.5x, ./bbbbb4b6baa55f084793cbf14b736f1d.png 2x"
        data-sizes="auto"
        alt="./bbbbb4b6baa55f084793cbf14b736f1d.png"
        title="image-20210726153615143" /></p>
<h3 id="217-tcp-吞吐量">21.7 TCP 吞吐量</h3>
<p>TCP 的平均吞吐量是多少，使用窗口 window 尺寸 W 和 RTT 来 描述?
 忽略慢启动阶段，假设发送端总有数据传输</p>
<p>W：发生丢失事件时的窗口尺寸(单位：字节)
 <strong>平均窗口尺寸(#in-flight 字节)：3/4W</strong>
 <strong>平均吞吐量：一个 RTT 时间吞吐 3/4W， avg TCP thruput = 3/4 * (W/RTT) bytes/sec</strong></p>
<h3 id="218-tcp-公平性">21.8 TCP 公平性</h3>
<p><strong>公平性目标</strong>: 如果 <strong>K 个 TCP 会话</strong>分享一个链路带宽为 R 的 瓶颈，每一个会话的有效带宽为 <strong>R/K</strong></p>
<p>2 个竞争的 TCP 会话:
 加性增加，斜率为 1, 吞吐量增加
 乘性减，吞吐量比例减少</p>
<p><strong>往返延迟相同时，TCP 会话竞争的最终，双方的 有效的带宽 将收敛到 链路带宽 的一半。</strong>
<strong>所以相互竞争时 应用建立的 TCP 会话越多，占有带宽一般越大。</strong></p>
<p>公平性和 UDP
 多媒体应用通常不是用 TCP
 应用发送的数据速率希望 不受拥塞控制的节制
使用 UDP:  音视频应用泵出数据的速率是恒定的, 忽略数据的丢失  研究领域: TCP 友好性</p>
<p>公平性和并行 TCP 连接
 2 个主机间可以打开多个并行的 TCP 连接
 Web 浏览器</p>
<ul>
<li>例如: 带宽为 R 的链路支持了 9 个连接;
<ul>
<li>如果新的应用要求建 1 个 TCP 连接,获得带宽 R/10</li>
<li>如果新的应用要求建 11 个 TCP 连接,获得带宽 R/2</li>
</ul>
</li>
</ul>
<h2 id="22-第三章-总结">22 第三章 总结</h2>
<ul>
<li>
<p>传输层提供的服务</p>
<ul>
<li>应用进程间的逻辑通信
<ul>
<li>Vs 网络层提供的是主机到主机的通信服务</li>
</ul>
</li>
<li>互联网上传输层协议：UDP TCP
<ul>
<li>特性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多路复用和解复用</p>
<ul>
<li>端口：传输层的 SAP</li>
<li>无连接的多路复用和解复用</li>
<li>面向连接的多路复用和解复用</li>
</ul>
</li>
<li>
<p>实例 1：无连接传输层协议 UDP</p>
<ul>
<li>多路复用解复用</li>
<li>UDP 报文格式</li>
<li>检错机制：校验和</li>
</ul>
</li>
<li>
<p>可靠数据传输原理</p>
<ul>
<li>问题描述</li>
<li>停止等待协议
<ul>
<li>Rdt1.0 rdt2.0,2.1 ,2.2 Rdt 3.0</li>
</ul>
</li>
<li>流水线协议
<ul>
<li>GBN</li>
<li>SR(Selective Repeat)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实例 2：面向连接的 传输层协议-TCP</p>
<ul>
<li>概述：TCP 特性</li>
<li>报文段格式
<ul>
<li>序号，超时机制及时间</li>
</ul>
</li>
<li>TCP 可靠传输机制</li>
<li>重传，快速重传</li>
<li>流量控制</li>
<li>连接管理
<ul>
<li>三次握手</li>
<li>对称连接释放</li>
</ul>
</li>
<li>拥塞控制原理
<ul>
<li>网络辅助的拥塞控制</li>
<li>端到端的拥塞控制</li>
</ul>
</li>
<li>TCP 的拥塞控制
<ul>
<li>AIMD</li>
<li>慢启动</li>
<li>超时之后的保守策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四章网络层数据平面-network-layer-data-plane">第四章：网络层：数据平面 Network layer: data plane</h1>
<h2 id="23-导论">23 导论</h2>
<p> 数据平面
 控制平面</p>
<h2 id="24-网络层服务">24 网络层服务</h2>
<p> 在发送主机和接收主机对之间 传送段**(segment)**
 在发送端将段封装到数据报中
 在接收端，将段上交给传输层 实体
 网络层协议存在于每一个主机 和路由器
 路由器检查每一个经过它的 IP 数据报的头部</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./image-20211001100723126.png"
        data-srcset="./image-20211001100723126.png, ./image-20211001100723126.png 1.5x, ./image-20211001100723126.png 2x"
        data-sizes="auto"
        alt="./image-20211001100723126.png"
        title="image-20211001100723126" /></p>
<h3 id="241-网络层的关键功能">24.1 网络层的关键功能</h3>
<p>网络层功能：
 转发: 将分组从路由器的输入接口转发到合适的输出接口
 路由: 使用路由算法来决定分组从发送主机到目标接收主机的路径
 路由选择算法
 路由选择协议</p>
<p><strong>旅行的类比：</strong></p>
<ul>
<li><strong>转发: 通过单个路口的过程</strong> —— 数据平面</li>
<li><strong>路由: 从源到目的的路由路径规划过程</strong> —— 控制平面</li>
</ul>
<h3 id="242-网络层数据平面控制平面">24.2 网络层：数据平面、控制平面</h3>
<ul>
<li>
<p>数据平面</p>
<ul>
<li>本地，每个路由器功能</li>
<li><strong>决定从路由器输入端口到达的分组如何转发到输出端口</strong></li>
<li>转发功能：
<ul>
<li>传统方式：基于目标 地址+转发表</li>
<li><strong>SDN 方式：基于多个字段+流表</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制平面</p>
<ul>
<li>网络范围内的逻辑</li>
<li><strong>决定数据报如何在路由器之间 路由，决定数据报从源到目标主机之间的端到端路径</strong></li>
<li>2 个控制平面方法:
<ul>
<li><strong>传统的路由算法: 在路由器中被实现 —— 功能单一：根据目标的 IP 地址进行转发</strong></li>
<li><strong>software-defined networking (SDN): 在远程的服务器中实现</strong>
软件定义网 —— 匹配很多字段，功能更多：泛洪、转发、修改字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2421-传统方式每-路由器per-router控制平面">24.2.1 传统方式：每-路由器(Per-router)控制平面</h4>
<p><strong>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</strong>
<strong>紧耦合，难以修改</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./be833803f93d76f59f53761649e405cd.png"
        data-srcset="./be833803f93d76f59f53761649e405cd.png, ./be833803f93d76f59f53761649e405cd.png 1.5x, ./be833803f93d76f59f53761649e405cd.png 2x"
        data-sizes="auto"
        alt="./be833803f93d76f59f53761649e405cd.png"
        title="image-20211001102609192" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9d34310d4423b0f2037e47f092a368f3.png"
        data-srcset="./9d34310d4423b0f2037e47f092a368f3.png, ./9d34310d4423b0f2037e47f092a368f3.png 1.5x, ./9d34310d4423b0f2037e47f092a368f3.png 2x"
        data-sizes="auto"
        alt="./9d34310d4423b0f2037e47f092a368f3.png"
        title="image-20211001102633237" /></p>
<h4 id="2422-sdn-方式逻辑集中的控制平面">24.2.2 SDN 方式：逻辑集中的控制平面</h4>
<p><strong>一个不同的(通常是远程的)控制器与本地控制代理(CAs) 交互</strong>
网络操作系统运行在集中的控制器上</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c78cc1b17c4ea3e0a493ba6ec2fcf0c8.png"
        data-srcset="./c78cc1b17c4ea3e0a493ba6ec2fcf0c8.png, ./c78cc1b17c4ea3e0a493ba6ec2fcf0c8.png 1.5x, ./c78cc1b17c4ea3e0a493ba6ec2fcf0c8.png 2x"
        data-sizes="auto"
        alt="./c78cc1b17c4ea3e0a493ba6ec2fcf0c8.png"
        title="image-20211001102716772" /></p>
<h3 id="243-网络服务模型">24.3 网络服务模型</h3>
<p>Q: 从发送方主机到接收方主机传输数据报的“通道” ，网络提供什么样的服务模型？</p>
<ul>
<li>对于单个数据报的服务:
<ul>
<li>可靠传送</li>
<li>延迟保证，如：少于 40ms 的延迟</li>
</ul>
</li>
<li>对于数据报流的服务:
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟差</li>
</ul>
</li>
</ul>
<h3 id="244-连接建立">24.4 连接建立</h3>
<p> 在某些网络架构中是第三个重要的功能
 ATM, frame relay, X.25</p>
<p> 在分组传输之前，在两个主机之间，在通过一些 路由器所构成的路径上建立一个网络层连接
 涉及到路由器</p>
<p> <strong>网络层和传输层连接服务区别:</strong>
 <strong>网络层: 在 2 个主机之间，涉及到路径上的一些路由器</strong> —— 有连接
 <strong>传输层: 在 2 个进程之间，很可能只体现在端系统上 (TCP 连接)</strong> —— 面向连接</p>
<h3 id="245-一些网络层服务模型">24.5 一些网络层服务模型</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f22fd97d02b40b2d9f8bd93fc0623dfa.png"
        data-srcset="./f22fd97d02b40b2d9f8bd93fc0623dfa.png, ./f22fd97d02b40b2d9f8bd93fc0623dfa.png 1.5x, ./f22fd97d02b40b2d9f8bd93fc0623dfa.png 2x"
        data-sizes="auto"
        alt="./f22fd97d02b40b2d9f8bd93fc0623dfa.png"
        title="image-20211001103624022" /></p>
<h2 id="25-路由器组成">25 路由器组成</h2>
<h3 id="251-路由器结构概况-传统">25.1 路由器结构概况 (传统)</h3>
<p>高层面(非常简化的)通用路由器体系架构</p>
<ul>
<li>路由：运行路由选择算法／协议 (RIP, OSPF, BGP) - 生成 路由表</li>
<li>转发：从输入到输出链路交换数据报 - 根据路由表进行分组的转发</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2187f875eb60335d5efd9fe24902d2bc.png"
        data-srcset="./2187f875eb60335d5efd9fe24902d2bc.png, ./2187f875eb60335d5efd9fe24902d2bc.png 1.5x, ./2187f875eb60335d5efd9fe24902d2bc.png 2x"
        data-sizes="auto"
        alt="./2187f875eb60335d5efd9fe24902d2bc.png"
        title="image-20211001103919273" /></p>
<h3 id="252-输入端口功能">25.2 输入端口功能</h3>
<p>输入端口有个队列</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a8603374f57b545767e800b073c34ce6.png"
        data-srcset="./a8603374f57b545767e800b073c34ce6.png, ./a8603374f57b545767e800b073c34ce6.png 1.5x, ./a8603374f57b545767e800b073c34ce6.png 2x"
        data-sizes="auto"
        alt="./a8603374f57b545767e800b073c34ce6.png"
        title="image-20211001104327835" /></p>
<h4 id="2521-输入端口缓存">25.2.1 输入端口缓存</h4>
<ul>
<li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队
<ul>
<li><strong>排队延迟以及由于输入缓存溢出造成丢失!</strong></li>
</ul>
</li>
<li>Head-of-the-Line (HOL) blocking: 排在队头的数据报 阻止了队列中其他数据报向前移动</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a68967ad61c33aadc079a1c27cbc867f.png"
        data-srcset="./a68967ad61c33aadc079a1c27cbc867f.png, ./a68967ad61c33aadc079a1c27cbc867f.png 1.5x, ./a68967ad61c33aadc079a1c27cbc867f.png 2x"
        data-sizes="auto"
        alt="./a68967ad61c33aadc079a1c27cbc867f.png"
        title="image-20211001104653702" /></p>
<h3 id="253-交换结构">25.3 交换结构</h3>
<p> 将分组从输入缓冲区传输到合适的输出端口
 交换速率：分组可以按照该速率从输入传输到输 出
 运行速度经常是输入/输出链路速率的若干倍
 N 个输入端口：交换机构的交换速度是输入线路速度的 N 倍比较理 想，才不会成为瓶颈
 3 种典型的交换机构</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5cd50facb490edd329e60ab688d75639.png"
        data-srcset="./5cd50facb490edd329e60ab688d75639.png, ./5cd50facb490edd329e60ab688d75639.png 1.5x, ./5cd50facb490edd329e60ab688d75639.png 2x"
        data-sizes="auto"
        alt="./5cd50facb490edd329e60ab688d75639.png"
        title="image-20211001104817961" /></p>
<h4 id="2531-通过内存交换">25.3.1 通过内存交换</h4>
<p>第一代路由器:</p>
<ul>
<li>在 CPU 直接控制下的交换，采用传统的计算机</li>
<li><strong>分组被拷贝到系统内存，CPU 从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</strong></li>
<li><strong>转发速率被内存的带宽限制(数据报通过 BUS 两遍)</strong></li>
<li>一次只能转发一个分组</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6465e141f3154fc1f86562de90bafee7.png"
        data-srcset="./6465e141f3154fc1f86562de90bafee7.png, ./6465e141f3154fc1f86562de90bafee7.png 1.5x, ./6465e141f3154fc1f86562de90bafee7.png 2x"
        data-sizes="auto"
        alt="./6465e141f3154fc1f86562de90bafee7.png"
        title="image-20211001104907438" /></p>
<h4 id="2532-通过总线交换">25.3.2 通过总线交换</h4>
<ul>
<li>数据报通过共享总线，从输入端
<ul>
<li>转发到输出端口</li>
</ul>
</li>
<li><strong>总线竞争: 交换速度受限于总线带宽</strong></li>
<li>1 次处理一个分组</li>
<li>1 Gbps bus, Cisco 1900； 32 Gbps bus, Cisco 5600；
对于接 入或企业级路由器，速度足够( 但不适合区域或骨干网络)</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5d95950da9427c923bbfa45287756319.png"
        data-srcset="./5d95950da9427c923bbfa45287756319.png, ./5d95950da9427c923bbfa45287756319.png 1.5x, ./5d95950da9427c923bbfa45287756319.png 2x"
        data-sizes="auto"
        alt="./5d95950da9427c923bbfa45287756319.png"
        title="image-20211001104959142" /></p>
<h4 id="2533-通过互联网络crossbar-等的交换">25.3.3 通过互联网络(crossbar 等)的交换</h4>
<p><strong>同时并发转发多个分组，克服总线带宽限制</strong></p>
<ul>
<li>Banyan(榕树〉网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口 A 到达，转给端口 Y;控制器短接相应的两个总线</li>
<li>高级设计:将数据报分片为固定长度的信元，通过交换网络交换</li>
<li>Cisco12000:以 60Gbps 的交换速率通过互联网络</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e8c385b4314f97d32f9abd8c8016a149.png"
        data-srcset="./e8c385b4314f97d32f9abd8c8016a149.png, ./e8c385b4314f97d32f9abd8c8016a149.png 1.5x, ./e8c385b4314f97d32f9abd8c8016a149.png 2x"
        data-sizes="auto"
        alt="./e8c385b4314f97d32f9abd8c8016a149.png"
        title="image-20211001105151671" /></p>
<h3 id="254-输出端口">25.4 输出端口</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./fddf65f3445691da9bf6ab9555ede219.png"
        data-srcset="./fddf65f3445691da9bf6ab9555ede219.png, ./fddf65f3445691da9bf6ab9555ede219.png 1.5x, ./fddf65f3445691da9bf6ab9555ede219.png 2x"
        data-sizes="auto"
        alt="./fddf65f3445691da9bf6ab9555ede219.png"
        title="image-20211001105403564" /></p>
<p> 当数据报从交换机构的到达速度比传输速率快 就需要输出端口缓存</p>
<p> 由调度规则选择排队的数据报进行传输</p>
<p>优先权调度-谁会获得最优性能， 网络中立？</p>
<h4 id="2541-输出端口排队">25.4.1 输出端口排队</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./44548ec5683bedb4dbe3a5e2c9659a68.png"
        data-srcset="./44548ec5683bedb4dbe3a5e2c9659a68.png, ./44548ec5683bedb4dbe3a5e2c9659a68.png 1.5x, ./44548ec5683bedb4dbe3a5e2c9659a68.png 2x"
        data-sizes="auto"
        alt="./44548ec5683bedb4dbe3a5e2c9659a68.png"
        title="image-20211001105440439" /></p>
<ul>
<li>假设交换速率 Rswitch 是 Rline 的 N 倍(N：输入端口的数量)</li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组(当通 过交换网络到达的速率超过输出速率则缓存)</li>
<li><strong>排队带来延迟，由于输出端口缓存溢出则丢弃数据报！</strong></li>
</ul>
<h4 id="2542-需要多少缓存">25.4.2 需要多少缓存?</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./847a7f0fec26549713336549c128275f.png"
        data-srcset="./847a7f0fec26549713336549c128275f.png, ./847a7f0fec26549713336549c128275f.png 1.5x, ./847a7f0fec26549713336549c128275f.png 2x"
        data-sizes="auto"
        alt="./847a7f0fec26549713336549c128275f.png"
        title="image-20211001105910410" /></p>
<h3 id="255-调度机制">25.5 调度机制</h3>
<p><strong>调度: 选择下一个要通过链路传输的分组</strong></p>
<ul>
<li>FIFO (first in first out) scheduling: 按照分组到来的次序发送
<ul>
<li>现实例子?</li>
<li>丢弃策略: 如果分组到达一个满的队列，哪个分组将会 被抛弃?
<ul>
<li>tail drop: 丢弃刚到达的分组</li>
<li>priority: 根据优先权丢失/移除分组</li>
<li>random: 随机地丢弃/移除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2551-调度策略优先权">25.5.1 调度策略：优先权</h4>
<p>优先权调度：发送最高优先 权的分组</p>
<ul>
<li>多类，不同类别有不同的 优先权
<ul>
<li>类别可能依赖于标记或者其 他的头部字段, e.g. IP source/dest, port numbers, ds，etc.</li>
<li>先传高优先级的队列中的分 组，除非没有</li>
<li>高(低)优先权中的分组传 输次序：FIFO</li>
<li>现实生活中的例子?</li>
</ul>
</li>
</ul>
<p>有红的不传绿的</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./034edad2f268634fc2202b8e9f8cbc71.png"
        data-srcset="./034edad2f268634fc2202b8e9f8cbc71.png, ./034edad2f268634fc2202b8e9f8cbc71.png 1.5x, ./034edad2f268634fc2202b8e9f8cbc71.png 2x"
        data-sizes="auto"
        alt="./034edad2f268634fc2202b8e9f8cbc71.png"
        title="image-20211001110210112" /></p>
<h4 id="2552-调度策略其他的">25.5.2 调度策略：其他的</h4>
<p>Round Robin (RR) scheduling:
 多类
 <strong>循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类</strong>
 现实例子?</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a6fc6e34bd9f71d1baad9d1b53e79a63.png"
        data-srcset="./a6fc6e34bd9f71d1baad9d1b53e79a63.png, ./a6fc6e34bd9f71d1baad9d1b53e79a63.png 1.5x, ./a6fc6e34bd9f71d1baad9d1b53e79a63.png 2x"
        data-sizes="auto"
        alt="./a6fc6e34bd9f71d1baad9d1b53e79a63.png"
        title="image-20211001111117490" /></p>
<p>Weighted Fair Queuing (WFQ):
 一般化的 Round Robin
 *_在一段时间内，每个队列得到的服务时间是： Wi /(XIGMA(Wi )) _t ，和权重成正比__
 每个类在每一个循环中获得不同权重的服务量
 现实例子</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2435da272ad05cf31b8aae4d88ed64c8.png"
        data-srcset="./2435da272ad05cf31b8aae4d88ed64c8.png, ./2435da272ad05cf31b8aae4d88ed64c8.png 1.5x, ./2435da272ad05cf31b8aae4d88ed64c8.png 2x"
        data-sizes="auto"
        alt="./2435da272ad05cf31b8aae4d88ed64c8.png"
        title="image-20211001111153165" /></p>
<h2 id="26-ip-internet-protocol">26 IP: Internet Protocol</h2>
<p>互联网的网络层
主机,路由器中的网络层功能：</p>
<p>IP 协议主要实现的是数据平面的转发功能</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./339487436d102e422527d83831323a89.png"
        data-srcset="./339487436d102e422527d83831323a89.png, ./339487436d102e422527d83831323a89.png 1.5x, ./339487436d102e422527d83831323a89.png 2x"
        data-sizes="auto"
        alt="./339487436d102e422527d83831323a89.png"
        title="image-20211001111457486" /></p>
<h3 id="261-ip-数据报格式">26.1 IP 数据报格式</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ae031e6c39641b9940c56c7c029e2c2b.png"
        data-srcset="./ae031e6c39641b9940c56c7c029e2c2b.png, ./ae031e6c39641b9940c56c7c029e2c2b.png 1.5x, ./ae031e6c39641b9940c56c7c029e2c2b.png 2x"
        data-sizes="auto"
        alt="./ae031e6c39641b9940c56c7c029e2c2b.png"
        title="image-20211001111652067" /></p>
<p>、</p>
<p><strong>16-bit identifier flgs fragment offset —— 分片/重组使用</strong></p>
<h3 id="262-ip-分片和重组fragmentation--reassembly">26.2 IP 分片和重组(Fragmentation &amp; Reassembly)</h3>
<ul>
<li><strong>网络链路有 MTU (最大传输单元) –链路层帧所携带的最大数据长度</strong>
<ul>
<li><a href="https://blog.csdn.net/qq_42248536/article/details/88819222" target="_blank" rel="noopener noreffer">不同的链路类型</a> —— <strong>Access 链路</strong>、<strong>Trunk 链路</strong>、</li>
<li>不同的 MTU</li>
</ul>
</li>
<li>大的 IP 数据报在网络上被分片 (“fragmented”)
<ul>
<li>一个数据报被分割成若干个小 的数据报
<ul>
<li>相同的 ID</li>
<li>不同的偏移量</li>
<li>最后一个分片标记为 0</li>
</ul>
</li>
<li>“重组”只在最终的目标主机进行</li>
<li>IP 头部的信息被用于标识，排序相关分片</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a318de99e5ea82415631d4ba2a97cf0c.png"
        data-srcset="./a318de99e5ea82415631d4ba2a97cf0c.png, ./a318de99e5ea82415631d4ba2a97cf0c.png 1.5x, ./a318de99e5ea82415631d4ba2a97cf0c.png 2x"
        data-sizes="auto"
        alt="./a318de99e5ea82415631d4ba2a97cf0c.png"
        title="image-20211001133625648" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./77c038e16bf4925ee327ce088825b66f.png"
        data-srcset="./77c038e16bf4925ee327ce088825b66f.png, ./77c038e16bf4925ee327ce088825b66f.png 1.5x, ./77c038e16bf4925ee327ce088825b66f.png 2x"
        data-sizes="auto"
        alt="./77c038e16bf4925ee327ce088825b66f.png"
        title="image-20211001133700562" /></p>
<p>flagflag —— 标识后面还有没有</p>
<h3 id="263-ip-编址-引论">26.3 IP 编址: 引论</h3>
<ul>
<li>IP 地址: 32 位标示，对 主机或者路由器的接口编址</li>
<li>接口: 主机/路由器和物 理链路的连接处
<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也有可能有多个接口</li>
<li>IP 地址和每一个接口关联</li>
</ul>
</li>
<li>一个 IP 地址和一个接口相关联</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6bfca57619e7b3c34bd3187e4999a207.png"
        data-srcset="./6bfca57619e7b3c34bd3187e4999a207.png, ./6bfca57619e7b3c34bd3187e4999a207.png 1.5x, ./6bfca57619e7b3c34bd3187e4999a207.png 2x"
        data-sizes="auto"
        alt="./6bfca57619e7b3c34bd3187e4999a207.png"
        title="image-20211001135955479" /></p>
<h4 id="2631-子网subnets">26.3.1 子网(Subnets)</h4>
<ul>
<li><strong>IP 地址:</strong>
<ul>
<li>子网部分(高位 bits)</li>
<li>主机部分(低位 bits)</li>
</ul>
</li>
<li><strong>什么是子网(subnet) ?</strong>
<ul>
<li><strong>一个子网内的节点(主 机或者路由器)它们的 IP 地址的高位部分相同 ，这些节点构成的网络的一部分叫做子网</strong></li>
<li><strong>无需路由器介入，子网内各主机可以在物理上相互直接到达</strong> —— 只需要交换机即可，一跳可达</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./378ea8f49c71ff8c8862c9def09ee754.png"
        data-srcset="./378ea8f49c71ff8c8862c9def09ee754.png, ./378ea8f49c71ff8c8862c9def09ee754.png 1.5x, ./378ea8f49c71ff8c8862c9def09ee754.png 2x"
        data-sizes="auto"
        alt="./378ea8f49c71ff8c8862c9def09ee754.png"
        title="image-20211001142106457" /></p>
<p><strong>长途链路 —— 点到点的形式 中国到日本的链路</strong>
<strong>计算机局域网 —— 多点连接的方式</strong></p>
<p>方法：
 <strong>要判断一个子网, 将每一个接口从主机或者路由 器上分开,构成了一个个网络的孤岛</strong>
 <strong>每一个孤岛(网络)都 是一个都可以被称之为 subnet.</strong></p>
<p>子网掩码：11111111 11111111 11111111 00000000
Subnet mask: /24</p>
<h4 id="2632-ip-地址分类">26.3.2 IP 地址分类</h4>
<p> Class A：126 networks ，16 million hosts
 Class B：16382networks ，64 K hosts
 Class C：2 million networks ，254 host
 Class D：multicast
 Class E：reserved for future
全 0 全 1 不用</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./814c2ef8b564bf1e7de8045c34293b7a.png"
        data-srcset="./814c2ef8b564bf1e7de8045c34293b7a.png, ./814c2ef8b564bf1e7de8045c34293b7a.png 1.5x, ./814c2ef8b564bf1e7de8045c34293b7a.png 2x"
        data-sizes="auto"
        alt="./814c2ef8b564bf1e7de8045c34293b7a.png"
        title="image-20211001142823822" /></p>
<h4 id="2633-特殊-ip-地址">26.3.3 特殊 IP 地址</h4>
<ul>
<li>一些约定：
<ul>
<li><strong>子网部分: 全为 0—本网络</strong> <strong>127 Loopback —— 回路地址</strong></li>
<li><strong>主机部分: 全为 0—本主机</strong></li>
<li><strong>主机部分: 全为 1–广播地址，这个网络的所有主机</strong></li>
<li><strong>全为 1——在本地网络广播</strong></li>
</ul>
</li>
<li>特殊 IP 地址</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2ce2ff222e94db7ac7ea61e33e9a6f94.png"
        data-srcset="./2ce2ff222e94db7ac7ea61e33e9a6f94.png, ./2ce2ff222e94db7ac7ea61e33e9a6f94.png 1.5x, ./2ce2ff222e94db7ac7ea61e33e9a6f94.png 2x"
        data-sizes="auto"
        alt="./2ce2ff222e94db7ac7ea61e33e9a6f94.png"
        title="image-20211001142922347" /></p>
<h4 id="2634-内网专用ip-地址">26.3.4 内网(专用)IP 地址</h4>
<ul>
<li><strong>专用地址：地址空间的一部份供专用地址使用</strong></li>
<li>永远不会被当做公用地址来分配, 不会与公用地址重复
<ul>
<li>只在局部网络中有意义，区分不同的设备</li>
</ul>
</li>
<li><strong>路由器不对目标地址是专用地址的分组进行转发</strong></li>
<li>专用地址范围
<ul>
<li><strong>Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0</strong></li>
<li><strong>Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0</strong></li>
<li><strong>Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0</strong></li>
</ul>
</li>
</ul>
<h4 id="2635-ip-编址-cidr">26.3.5 IP 编址: CIDR</h4>
<p>CIDR: Classless InterDomain Routing (无类域间路由)</p>
<ul>
<li>子网部分可以在任意的位置</li>
<li>地址格式: a.b.c.d/x, 其中 x 是 地址中子网号的长度</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3860e099f0da1a17919f6041206cd13a.png"
        data-srcset="./3860e099f0da1a17919f6041206cd13a.png, ./3860e099f0da1a17919f6041206cd13a.png 1.5x, ./3860e099f0da1a17919f6041206cd13a.png 2x"
        data-sizes="auto"
        alt="./3860e099f0da1a17919f6041206cd13a.png"
        title="image-20211001143934822" /></p>
<h4 id="2636-子网掩码subnet-mask">26.3.6 子网掩码(subnet mask)</h4>
<ul>
<li>32bits ,0 or 1 in each bito
<ul>
<li>1: bit 位置表示子网部分</li>
<li>0:bit 位置表示主机部分</li>
</ul>
</li>
<li>原始的 A、B、C 类网络的子网掩码分别是
<ul>
<li>A:255.0.0.0 : 11111111 00000000 00000000 00000000</li>
<li>B:255,255.0.0:11111111 11111111 0000000 00000000</li>
<li>C:255,255,255.0:11111111 11111111 11111111 00000000</li>
</ul>
</li>
<li>CIDR 下的子网掩码例子:
<ul>
<li>1111111111111111 11111100 0o0000oo</li>
</ul>
</li>
<li>另外的一种表示子网掩码的表达方式
<ul>
<li>/#</li>
<li>例:/22:表示前面 22 个 bit 为子网部分</li>
</ul>
</li>
</ul>
<h4 id="2637-转发表和转发算法">26.3.7 转发表和转发算法</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d4fb2848aa7ee07d5f6e8f81c3a37782.png"
        data-srcset="./d4fb2848aa7ee07d5f6e8f81c3a37782.png, ./d4fb2848aa7ee07d5f6e8f81c3a37782.png 1.5x, ./d4fb2848aa7ee07d5f6e8f81c3a37782.png 2x"
        data-sizes="auto"
        alt="./d4fb2848aa7ee07d5f6e8f81c3a37782.png"
        title="image-20211001144206732" /></p>
<ul>
<li>获得 IP 数据报的目标地址</li>
<li>对于转发表中的每一个表项
<ul>
<li>如 (IP Des addr) &amp; (mask)== destination, 则按照表项 对应的接口转发该数据报</li>
<li>如果都没有找到,则使用默认表项转发数据报</li>
</ul>
</li>
</ul>
<h3 id="264-如何获得一个-ip-地址-主机">26.4 如何获得一个 IP 地址 主机</h3>
<p>Q: 主机如何获得一个 IP 地址?</p>
<ul>
<li>系统管理员将地址配置在一个文件中
<ul>
<li>Wintel: control-panel-&gt;network- &gt;configuration-&gt;tcp/ip-&gt;properties</li>
<li>UNIX: /etc/rc.config</li>
</ul>
</li>
<li><strong>DHCP: Dynamic Host Configuration Protocol: 从服务器中动态获得一个 IP 地址</strong>
<ul>
<li>“plug-and-play</li>
</ul>
</li>
</ul>
<h4 id="2641-dhcp-dynamic-host-configuration-protocol">26.4.1 DHCP: Dynamic Host Configuration Protocol</h4>
<ul>
<li>目标:允许主机在加入网络的时候，动态地从服务器那里获得 IP 地址:
<ul>
<li><strong>可以更新对主机在用 IP 地址的租用期-租期快到了</strong></li>
<li><strong>重新启动时，允许重新使用以前用过的 IP 地址</strong></li>
<li><strong>支持移动用户加入到该网络(短期在网)</strong></li>
</ul>
</li>
<li>DHCP 工作概况:
<ul>
<li>主机广播“DHCP discover”报文[可选]</li>
<li>DHCP 服务器用“DHCP offer”提供报文响应[可选]</li>
<li>主机请求 IP 地址:发送“DHCP request”报文</li>
<li>DHCP 服务器发送地址:“DHCP ack”报文</li>
</ul>
</li>
</ul>
<h4 id="2642-dhcp-client-server-scenario">26.4.2 DHCP client-server scenario</h4>
<p><strong>第二次是因为可能有多个 DHCP 服务器，要确认用哪一个</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./406f1128a28809bf5f2714938381d3d0.png"
        data-srcset="./406f1128a28809bf5f2714938381d3d0.png, ./406f1128a28809bf5f2714938381d3d0.png 1.5x, ./406f1128a28809bf5f2714938381d3d0.png 2x"
        data-sizes="auto"
        alt="./406f1128a28809bf5f2714938381d3d0.png"
        title="image-20211001144822831" /></p>
<h4 id="2643-dhcp-不仅仅是-ip-addresses">26.4.3 DHCP: 不仅仅是 IP addresses</h4>
<p>DHCP 返回:</p>
<ul>
<li>IP 地址</li>
<li>第一跳路由器的 IP 地址(默认网关)</li>
<li>DNS 服务器的域名和 IP 地址</li>
<li>子网掩码 (指示地址部分的网络号和主机号)</li>
</ul>
<h4 id="2644-dhcp-实例">26.4.4 DHCP: 实例</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./aee14d459ce9099990c8ea45fdf3be1b.png"
        data-srcset="./aee14d459ce9099990c8ea45fdf3be1b.png, ./aee14d459ce9099990c8ea45fdf3be1b.png 1.5x, ./aee14d459ce9099990c8ea45fdf3be1b.png 2x"
        data-sizes="auto"
        alt="./aee14d459ce9099990c8ea45fdf3be1b.png"
        title="image-20211001145225819" /></p>
<p>第一次握手</p>
<p>联网笔记本需要获取自己的 IP 地址，第一跳路由器地址和 DNS 服务器:采用 DHCP 协议
DHCP 请求被封装在 UDP 段中,封装在 IP 数据报中，封装在以太网的帧中
以太网帧在局域网范围内广播(dest: FFFFFFFFFFFF)
被运行 DHCP 服务的路由器收到
以太网帧解封装成 IP，IP 解封装成 UDP，解封装成 DHCP</p>
<p>DHCP 服务器生成 DHCP ACK,包含客户端的 IP 地址，第一跳路由器的 IP 地址和 DNS 域名服务器的 IP 地址
DHCP 服务器封装的报文所在的帧转发到客户端，在客户端解封装成 DHCP 报文
客户端知道它自己的 IP 地址，DNS 服务器的名字和 IP 地址，第一跳路由器的 IP 地址</p>
<p>第二次握手 略</p>
<h3 id="265-如何获得一个-ip-地址-机构">26.5 如何获得一个 IP 地址 机构</h3>
<p>Q: 如何获得一个网络的子网部分?
A: 从 ISP 获得地址块中分配一个小地址块</p>
<p>ISP’s block 11001000 00010111 00010000 00000000 200.23.16.0/20
Organization 0 11001000 00010111 00010000 00000000 200.23.16.0/23
Organization 1 11001000 00010111 00010010 00000000 200.23.18.0/23
Organization 2 11001000 00010111 00010100 00000000 200.23.20.0/23
… …… …. ….
Organization 7 11001000 00010111 00011110 00000000 200.23.30.0/23</p>
<h4 id="2651-层次编址-路由聚集route-aggregation-聚集">26.5.1 层次编址: 路由聚集(route aggregation) 聚集</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e5d9e10e7a5aa6f43ad4854d6586d10e.png"
        data-srcset="./e5d9e10e7a5aa6f43ad4854d6586d10e.png, ./e5d9e10e7a5aa6f43ad4854d6586d10e.png 1.5x, ./e5d9e10e7a5aa6f43ad4854d6586d10e.png 2x"
        data-sizes="auto"
        alt="./e5d9e10e7a5aa6f43ad4854d6586d10e.png"
        title="image-20211001145630149" /></p>
<h4 id="2652-层次编址-特殊路由信息more-specific-routes">26.5.2 层次编址: 特殊路由信息(more specific routes)</h4>
<p><strong>匹配冲突时候，采取的是最长前缀匹配</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b0c5dcb9362273552c32939034d17682.png"
        data-srcset="./b0c5dcb9362273552c32939034d17682.png, ./b0c5dcb9362273552c32939034d17682.png 1.5x, ./b0c5dcb9362273552c32939034d17682.png 2x"
        data-sizes="auto"
        alt="./b0c5dcb9362273552c32939034d17682.png"
        title="image-20211001150738412" /></p>
<h3 id="266-ip-编址-如何获得一块地址-isp">26.6 IP 编址: 如何获得一块地址 ISP</h3>
<p>Q: 一个 ISP 如何获得一个地址块?
A: ICANN: Internet Corporation for Assigned Names and Numbers</p>
<ul>
<li>分配地址</li>
<li>管理 DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<h3 id="267-nat-network-address-translation-网络地址转换内网">26.7 NAT: Network Address Translation 网络地址转换(内网)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./95156b806ca3ddc622d66d7dee0ffb99.png"
        data-srcset="./95156b806ca3ddc622d66d7dee0ffb99.png, ./95156b806ca3ddc622d66d7dee0ffb99.png 1.5x, ./95156b806ca3ddc622d66d7dee0ffb99.png 2x"
        data-sizes="auto"
        alt="./95156b806ca3ddc622d66d7dee0ffb99.png"
        title="image-20211001150949929" /></p>
<ul>
<li>动机: 本地网络只有一个有效 IP 地址: 分配更多地址
<ul>
<li><strong>不需要从 ISP 分配一块地址，可用一个 IP 地址用于所有的(局域网)设备–省钱</strong></li>
<li><strong>可以在局域网改变设备的地址情况下而无须通知 外界</strong></li>
<li><strong>可以改变 ISP(地址变化)而不需要改变内部的 设备地址</strong></li>
<li><strong>局域网内部的设备没有明确的地址，对外是不可 见的–安全</strong></li>
</ul>
</li>
</ul>
<p><strong>实现: NAT 路由器必须:</strong></p>
<ul>
<li><strong>外出数据包：替换源地址和端口号为 NAT IP 地址 和新的端口号，</strong>
目标 IP 和端口不变 …远端的 C/S 将会用 NAP IP 地址，新端口号作为目标地址</li>
<li>记住每个转换替换对(在 NAT 转换表中)
<strong>… 源 IP，端口 vs NAP IP ，新端口</strong></li>
<li><strong>进入数据包：替换目标 IP 地址和端口号，</strong>
采用存储在 NAT 表中的 mapping 表项，用(源 IP，端口)</li>
</ul>
<p><strong>实际上就是用外网的某个 IP 代替内网里面的网络号，</strong>
<strong>出去的时候替换 原来 IP 和 端口号</strong>
<strong>进来的时候替换 目标 IP 和 端口号</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f0dbe7ab6581836c09dbb66012e7858c.png"
        data-srcset="./f0dbe7ab6581836c09dbb66012e7858c.png, ./f0dbe7ab6581836c09dbb66012e7858c.png 1.5x, ./f0dbe7ab6581836c09dbb66012e7858c.png 2x"
        data-sizes="auto"
        alt="./f0dbe7ab6581836c09dbb66012e7858c.png"
        title="image-20211001152133538" /></p>
<h4 id="2671-nat-穿越问题略">26.7.1 NAT 穿越问题(略)</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./bfb82b4dc8d75c3713eeabe67415d02d.png"
        data-srcset="./bfb82b4dc8d75c3713eeabe67415d02d.png, ./bfb82b4dc8d75c3713eeabe67415d02d.png 1.5x, ./bfb82b4dc8d75c3713eeabe67415d02d.png 2x"
        data-sizes="auto"
        alt="./bfb82b4dc8d75c3713eeabe67415d02d.png"
        title="image-20211001152533723" /></p>
<ul>
<li>
<p>客户端需要连接地址为 10.0.0.1 的服务器</p>
<ul>
<li>服务器地址 10.0.0.1 LAN 本地地址 (客户端不能够使用其作为目标地址)</li>
<li>整网只有一个外部可见地址: 138.76.29.7</li>
</ul>
</li>
<li>
<p><strong>方案 1: 静态配置 NAT：转发 进来的对服务器特定端口连接 请求</strong></p>
<ul>
<li>e.g., (123.76.29.7, port 2500) 总是转发到 10.0.0.1 port 25000</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4332c5a73a3599755850a09b7694a09a.png"
        data-srcset="./4332c5a73a3599755850a09b7694a09a.png, ./4332c5a73a3599755850a09b7694a09a.png 1.5x, ./4332c5a73a3599755850a09b7694a09a.png 2x"
        data-sizes="auto"
        alt="./4332c5a73a3599755850a09b7694a09a.png"
        title="image-20211001152723380" /></p>
</li>
<li>
<p><strong>方案 2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许 NATted 主机可以:</strong> 动态分配端口</p>
<ul>
<li> 获知网络的公共 IP 地址 (138.76.29.7)</li>
<li> 列举存在的端口映射</li>
<li> 增/删端口映射 (在租用时间内 )</li>
</ul>
</li>
<li>
<p>i.e., 自动化静态 NAT 端口映射配 置</p>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b08c3b12a7567d0ad7eec0fdb5660957.png"
        data-srcset="./b08c3b12a7567d0ad7eec0fdb5660957.png, ./b08c3b12a7567d0ad7eec0fdb5660957.png 1.5x, ./b08c3b12a7567d0ad7eec0fdb5660957.png 2x"
        data-sizes="auto"
        alt="./b08c3b12a7567d0ad7eec0fdb5660957.png"
        title="image-20211001152732177" /></p>
<ul>
<li><strong>方案 3: 中继 (used in Skype)</strong>
<ul>
<li> NAT 后面的服务器建立和中继的连接</li>
<li> 外部的客户端链接到中继</li>
<li> 中继在 2 个连接之间桥接</li>
</ul>
</li>
</ul>
<h3 id="268-ipv6">26.8 IPv6</h3>
<h4 id="2681-ipv6动机">26.8.1 IPv6：动机</h4>
<ul>
<li>初始动机: 32-bit 地址空间将会被很快用完</li>
<li>另外的动机:
<ul>
<li>头部格式改变帮助加速处理和转发 、
<ul>
<li>TTL-1</li>
<li>头部 checksum</li>
<li>分片</li>
</ul>
</li>
<li>头部格式改变帮助 QoS</li>
</ul>
</li>
</ul>
<p>IPv6 数据报格式:</p>
<ul>
<li>固定的 40 字节头部</li>
<li>数据报传输过程中，不允许分片</li>
</ul>
<h4 id="2682-ipv6-头部-cont">26.8.2 IPv6 头部 (Cont)</h4>
<p>Priority: 标示流中数据报的优先级
Flow Label: 标示数据报在一个“flow.” ( “flow”的概念没有被严格的定义)
Next header: 标示上层协议</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./779b154b0e1476906f2fd11a95636ca3.png"
        data-srcset="./779b154b0e1476906f2fd11a95636ca3.png, ./779b154b0e1476906f2fd11a95636ca3.png 1.5x, ./779b154b0e1476906f2fd11a95636ca3.png 2x"
        data-sizes="auto"
        alt="./779b154b0e1476906f2fd11a95636ca3.png"
        title="image-20211001153026504" /></p>
<h4 id="2683-和-ipv4-的其它变化">26.8.3 和 IPv4 的其它变化</h4>
<ul>
<li>Checksum: 被移除掉，降低在每一段中的处理 速度</li>
<li>Options: 允许，但是在头部之外, 被 “Next Header” 字段标示</li>
<li>ICMPv6: ICMP 的新版本
<ul>
<li>附加了报文类型, e.g. “Packet Too Big”</li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
<h4 id="2684-从-ipv4-到-ipv6-的平移">26.8.4 从 IPv4 到 IPv6 的平移</h4>
<ul>
<li>不是所有的路由器都能够同时升级的
<ul>
<li>没有一个标记日 “flag days”</li>
<li>在 IPv4 和 IPv6 路由器混合时，网络如何运转?</li>
</ul>
</li>
<li><strong>隧道: 在 IPv4 路由器之间传输的 IPv4 数据报中携 带 IPv6 数据报</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c694f1907285271c2453dc48f2f0e765.png"
        data-srcset="./c694f1907285271c2453dc48f2f0e765.png, ./c694f1907285271c2453dc48f2f0e765.png 1.5x, ./c694f1907285271c2453dc48f2f0e765.png 2x"
        data-sizes="auto"
        alt="./c694f1907285271c2453dc48f2f0e765.png"
        title="image-20211001153350960" /></p>
<h4 id="2685-隧道tunneling">26.8.5 隧道(Tunneling)</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./33eea8efd738ae3ea3ad48977bd61a2c.png"
        data-srcset="./33eea8efd738ae3ea3ad48977bd61a2c.png, ./33eea8efd738ae3ea3ad48977bd61a2c.png 1.5x, ./33eea8efd738ae3ea3ad48977bd61a2c.png 2x"
        data-sizes="auto"
        alt="./33eea8efd738ae3ea3ad48977bd61a2c.png"
        title="image-20211001153500951" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3879f7b6055200f98ff9b1e263fe9dd3.png"
        data-srcset="./3879f7b6055200f98ff9b1e263fe9dd3.png, ./3879f7b6055200f98ff9b1e263fe9dd3.png 1.5x, ./3879f7b6055200f98ff9b1e263fe9dd3.png 2x"
        data-sizes="auto"
        alt="./3879f7b6055200f98ff9b1e263fe9dd3.png"
        title="image-20211001153521591" /></p>
<h4 id="2686-ipv6-应用">26.8.6 IPv6: 应用</h4>
<ul>
<li>Google: 8% 的客户通过 IPv6 访问谷歌服务</li>
<li>NIST: 全美国 1/3 的政府域支持 IPv6</li>
<li>估计还需要很长时间进行部署
<ul>
<li>20 年以上!</li>
<li>看看过去 20 年来应用层面的变化: WWW, Facebook, streaming media, Skype, …</li>
<li>为什么?</li>
</ul>
</li>
</ul>
<h2 id="27-通用转发和-sdn">27 通用转发和 SDN</h2>
<h3 id="271-网络层功能为例的数据平面和控制平面">27.1 网络层功能为例的数据平面和控制平面</h3>
<p><strong>网络层功能：</strong></p>
<ul>
<li>转发： 对于从某个端口 到来的分组转发到合适的 输出端口</li>
<li>路由： 决定分组从源端 到目标端的路径
<ul>
<li>路由算法</li>
</ul>
</li>
</ul>
<p><strong>类比: 旅行</strong></p>
<ul>
<li>转发： 一个多岔路口的进入和转出过程</li>
<li>路由: 规划从源到目标的旅行路径</li>
</ul>
<p><strong>数据平面</strong> <strong>细节</strong></p>
<ul>
<li>本地的、每个路由器的 功能</li>
<li>决定某个从某个端口进 入的分组从从哪个端口 输出</li>
<li>转发功能</li>
</ul>
<p><strong>控制平面</strong> <strong>整体</strong></p>
<ul>
<li>网络范围的逻辑</li>
<li>决定分组端到端穿行于各个路 由器的路径</li>
</ul>
<h3 id="272-每个路由器per-route的控制平面-传统">27.2 每个路由器(Per Route)的控制平面 (传统)</h3>
<p><strong>每个路由器上都有实现路由算法元件(它们之间需要相互交 互)- 形成传统 IP 实现方式的控制平面</strong></p>
<p><strong>控制平面式分布式的，由各个路由器的各自完成，难于管理</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1946cdfc7fc8e3ec0a03f2cde5fba98d.png"
        data-srcset="./1946cdfc7fc8e3ec0a03f2cde5fba98d.png, ./1946cdfc7fc8e3ec0a03f2cde5fba98d.png 1.5x, ./1946cdfc7fc8e3ec0a03f2cde5fba98d.png 2x"
        data-sizes="auto"
        alt="./1946cdfc7fc8e3ec0a03f2cde5fba98d.png"
        title="image-20211001154409133" /></p>
<h4 id="2721-数量众多功能各异的中间盒">27.2.1 数量众多、功能各异的中间盒</h4>
<ul>
<li>路由器的网络层功能：
<ul>
<li>IP 转发：对于到来的分组按照路由表决定如何转发，数 据平面</li>
<li>路由：决定路径，计算路由表；处在控制平面</li>
</ul>
</li>
<li>还有其他种类繁多网络设备(中间盒)：
<ul>
<li>交换机；防火墙；NAT；IDS；负载均衡设备</li>
<li>未来：不断增加的需求和相应的网络设备</li>
<li><strong>需要不同的设备去实现不同的网络功能</strong>
<ul>
<li><strong>每台设备集成了控制平面和数据平面的功能</strong></li>
<li><strong>控制平面分布式地实现了各种控制平面功能</strong></li>
<li><strong>升级和部署网络设备非常困难</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2722-网络设备控制平面的实现方式特点">27.2.2 网络设备控制平面的实现方式特点</h4>
<ul>
<li>
<p><strong>互联网网络设备：传统方式都是通过分布式，每台 备的方法来实现数据平面和控制平面功能</strong></p>
<ul>
<li>垂直集成：每台路由器或其他网络设备，包括：
<ul>
<li>1)硬件、在私有的操作系统；</li>
<li>2)互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li>
<li>从上到下都由一个厂商提供(代价大、被设备上“绑架”“)</li>
</ul>
</li>
<li>每个设备都实现了数据平面和控制平面的事情
<ul>
<li>控制平面的功能是分布式实现的</li>
</ul>
</li>
<li>设备基本上只能(分布式升级困难)按照固定方式工作， 控制逻辑固化。不同的网络功能需要不同的 “middleboxes”：防火墙、负载均衡设备、NAT boxes, .</li>
</ul>
</li>
<li>
<p>(数据+控制平面)集成&gt;(控制逻辑)分布-&gt;固化</p>
<ul>
<li>代价大；升级困难；管理困难等</li>
</ul>
</li>
</ul>
<h4 id="2723-传统方式实现网络功能的问题">27.2.3 传统方式实现网络功能的问题</h4>
<ul>
<li>问题：
<ul>
<li><strong>垂直集成&gt;昂贵、不便于创新的生态</strong></li>
<li><strong>分布式、固化设备功能==网络设备种类繁多</strong>
<ul>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级 特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设 备：管理困难</li>
<li>要增加新的网络功能，需要设计、实现以及部署新的 特定设备，设备种类繁多</li>
</ul>
</li>
</ul>
</li>
<li>~2005: 开始重新思考网络控制平面的处理方式
<ul>
<li>集中：远程的控制器集中实现控制逻辑</li>
<li>远程：数据平面和控制平面的分离</li>
</ul>
</li>
</ul>
<h3 id="273-sdn逻辑上集中的控制平面-新">27.3 SDN：逻辑上集中的控制平面 (新)</h3>
<p>一个不同的(通常是远程)控制器和 CA 交互，控制器决定分组 转发的逻辑(可编程)，CA 所在设备执行逻辑。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./df35085c6c69082f142bd3cbe2b0a27b.png"
        data-srcset="./df35085c6c69082f142bd3cbe2b0a27b.png, ./df35085c6c69082f142bd3cbe2b0a27b.png 1.5x, ./df35085c6c69082f142bd3cbe2b0a27b.png 2x"
        data-sizes="auto"
        alt="./df35085c6c69082f142bd3cbe2b0a27b.png"
        title="image-20211001155320593" /></p>
<h4 id="2731-sdn-的主要思路">27.3.1 SDN 的主要思路</h4>
<ul>
<li>网络设备数据平面和控制平面分离</li>
<li>数据平面-分组交换机
<ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽 象成：按照流表(由控制平面设置的控制逻辑)进行 PDU (帧、分组)的动作(包括转发、丢弃、拷贝、泛洪、阻 塞)</li>
<li>统一化设备功能：SDN 交换机(分组交换机)，执行控制 逻辑</li>
</ul>
</li>
<li>控制平面-控制器+网络应用
<ul>
<li>分离、集中</li>
<li>计算和下发控制逻辑：流表</li>
</ul>
</li>
</ul>
<h4 id="2732-sdn-控制平面和数据平面分离的优势">27.3.2 SDN 控制平面和数据平面分离的优势</h4>
<ul>
<li><strong>水平集成控制平面</strong>的<strong>开放实现</strong>(而非私有实 现)，创造出好的产业生态，促进发展
<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用 app 可由不同 厂商生产，专业化，引入竞争形成良好生态</li>
</ul>
</li>
<li><strong>集中式</strong>实现控制逻辑，网络<strong>管理容易</strong>：
<ul>
<li>集中式控制器了解网络状况，编程简单，传统方式困难</li>
<li>避免路由器的误配置</li>
</ul>
</li>
<li><strong>基于流表的匹配+行动的工作方式允许“可编程的”分组交换机</strong>
<ul>
<li>实现流量工程等高级特性</li>
<li>在此框架下实现各种新型(未来)的网络设备</li>
</ul>
</li>
</ul>
<h4 id="2733-类比-主框架到-pc-的演变">27.3.3 类比: 主框架到 PC 的演变</h4>
<p><strong>要买硬件 就要买操作系统 就要买专用的软件</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b3e96d001d8b46e45c722118a1940657.png"
        data-srcset="./b3e96d001d8b46e45c722118a1940657.png, ./b3e96d001d8b46e45c722118a1940657.png 1.5x, ./b3e96d001d8b46e45c722118a1940657.png 2x"
        data-sizes="auto"
        alt="./b3e96d001d8b46e45c722118a1940657.png"
        title="image-20211001155703049" /></p>
<h3 id="274-流量工程-传统路由比较困难">27.4 流量工程: 传统路由比较困难</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9ba0869aac905e552dcc3145e975bd25.png"
        data-srcset="./9ba0869aac905e552dcc3145e975bd25.png, ./9ba0869aac905e552dcc3145e975bd25.png 1.5x, ./9ba0869aac905e552dcc3145e975bd25.png 2x"
        data-sizes="auto"
        alt="./9ba0869aac905e552dcc3145e975bd25.png"
        title="image-20211001160320932" /></p>
<p><strong>Q: 网管如果需要 u 到 z 的流量走 uvwz,x 到 z 的流量走 xwyz，怎么办？</strong></p>
<p>A: <strong>需要定义链路的代价</strong>，流量路由算法以此运算**( IP 路由面向目标，无法操作)** (或者需要新的路由算法)!</p>
<p>链路权重只是控制旋钮，错！</p>
<h4 id="2741-流量工程困难">27.4.1 流量工程：困难</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b68b52698b86e3d2940bb19941d441ee.png"
        data-srcset="./b68b52698b86e3d2940bb19941d441ee.png, ./b68b52698b86e3d2940bb19941d441ee.png 1.5x, ./b68b52698b86e3d2940bb19941d441ee.png 2x"
        data-sizes="auto"
        alt="./b68b52698b86e3d2940bb19941d441ee.png"
        title="image-20211001160555463" /></p>
<p>Q: 如果网管需要将 u 到 z 的流量分成 2 路：uvwz 和 uxyz ( 负载均衡)，怎么办?(IP 路由面向目标)</p>
<p>A: 无法完成(在原有体系下只有使用新的路由选择算法 ，而在全网部署新的路由算法是个大的事情)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./196c1ed5efe720f257d4ce527aac2064.png"
        data-srcset="./196c1ed5efe720f257d4ce527aac2064.png, ./196c1ed5efe720f257d4ce527aac2064.png 1.5x, ./196c1ed5efe720f257d4ce527aac2064.png 2x"
        data-sizes="auto"
        alt="./196c1ed5efe720f257d4ce527aac2064.png"
        title="image-20211001160622576" /></p>
<p>Q:如果需要 w 对蓝色的和红色的流量采用不同的路由，怎么办？</p>
<p>A: 无法操作 (基于目标的转发，采用 LS, DV 路由)</p>
<h4 id="2742-sdn-特点">27.4.2 SDN 特点</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ba5cf7bef38510bb3c62a90cab268801.png"
        data-srcset="./ba5cf7bef38510bb3c62a90cab268801.png, ./ba5cf7bef38510bb3c62a90cab268801.png 1.5x, ./ba5cf7bef38510bb3c62a90cab268801.png 2x"
        data-sizes="auto"
        alt="./ba5cf7bef38510bb3c62a90cab268801.png"
        title="image-20211001160657605" /></p>
<h3 id="275-sdn-架构">27.5 SDN 架构</h3>
<h4 id="2751-sdn-架构-数据平面交换机">27.5.1 SDN 架构: 数据平面交换机</h4>
<p>数据平面交换机</p>
<ul>
<li>快速，简单，商业化交换设备 采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li><strong>基于南向 API(例如 OpenFlow )，SDN 控制器访问基于流的交换机</strong>
<ul>
<li>定义了哪些可以被控制哪些不能</li>
</ul>
</li>
<li>也定义了和控制器的协议 (e.g., OpenFlow)</li>
</ul>
<h4 id="2752-sdn-架构-sdn-控制器">27.5.2 SDN 架构: SDN 控制器</h4>
<p>SDN 控制器(网络 OS):</p>
<ul>
<li>维护网络状态信息</li>
<li><strong>通过上面的北向 API 和网络 控制应用交互</strong> 向上</li>
<li><strong>通过下面的南向 API 和网络 交换机交互</strong> 向下</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、 容错性以及鲁棒性采用分布式方法</li>
</ul>
<h4 id="2753-sdn-架构-控制应用">27.5.3 SDN 架构: 控制应用</h4>
<p>网络控制应用:</p>
<ul>
<li>控制的大脑： 采用下层提供 的服务(SDN 控制器提供的 API)，实现网络功能
<ul>
<li>路由器 交换机</li>
<li>接入控制 防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供 ，与控制器厂商以通常上不 同，与分组交换机厂商也可 以不同</li>
</ul>
<h4 id="2754-通用转发和-sdn">27.5.4 通用转发和 SDN</h4>
<p>每个路由器包含一个流表(被逻辑上集中的控制器计算和分发)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./039652a494b6a5c8fb939ac188dc3511.png"
        data-srcset="./039652a494b6a5c8fb939ac188dc3511.png, ./039652a494b6a5c8fb939ac188dc3511.png 1.5x, ./039652a494b6a5c8fb939ac188dc3511.png 2x"
        data-sizes="auto"
        alt="./039652a494b6a5c8fb939ac188dc3511.png"
        title="image-20211001161538845" /></p>
<h3 id="276-openflow-协议">27.6 OpenFlow 协议</h3>
<p>通用 flow-bascd 基于流的匹配+行动(c.g,DpcnFlow)</p>
<p><strong>OpenFlow</strong>，一种网络通信协议，属于<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" target="_blank" rel="noopener noreffer">数据链路层</a>，<strong>能够控制网上交换器或<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="noopener noreffer">路由器</a>的转发平面(forwarding plane)，借此改变网络数据包所走的网络路径。</strong></p>
<blockquote>
<p>OpenFlow 能够启动远程的控制器，经由<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2%E5%99%A8/8534019" target="_blank" rel="noopener noreffer">网络交换器</a>，决定网络数据包要由何种路径通过<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2%E6%9C%BA/2105356" target="_blank" rel="noopener noreffer">网络交换机</a>。这个协议的发明者，将它当成<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener noreffer">软件定义网络</a>(Software-defined networking)的启动器。 [1]</p>
<p>OpenFlow 允许从远程控制网络交换器的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="noopener noreffer">数据包</a>转送表，透过新增、修改与移除数据包控制规则与行动，来改变数据包转送的路径。比起用<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E8%A1%A8" target="_blank" rel="noopener noreffer">访问控制表</a>(ACLs) 和路由协议，允许更复杂的流量管理。同时，OpenFlow 允许不同供应商用一个简单，开源的协议去远程管理交换机(通常提供专有的接口和描述语言)。</p>
<p>OpenFlow<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreffer">协议</a>用来描述控制器和交换机之间交互所用信息的标准，以及控制器和交换机的接口标准。协议的核心部分是用于 OpenFlow 协议信息结构的集合。</p>
<p>OpenFlow<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81" target="_blank" rel="noopener noreffer">协议支持</a>三种信息类型：Controller-to-Switch，Asynchronous 和 Symmetric，每一个类型都有多个子类型。Controller-to-Switch 信息由控制器发起并且直接用于检测交换机的状态。Asynchronous 信息由交换机发起并通常用于更新控制器的网络事件和改变交换机的状态。Symmetric 信息可以在没有请求的情况下由控制器或交换机发起。</p>
</blockquote>
<h4 id="2761-openflow-数据平面抽象">27.6.1 OpenFlow 数据平面抽象</h4>
<ul>
<li><strong>流: 由分组(帧)头部字段所定义</strong></li>
<li>通用转发: 简单的分组处理规则
<ul>
<li>模式: 将分组头部字段和流表进行匹配</li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、 将匹配的分组发送给控制器</li>
<li>优先权 Priority: 几个模式匹配了，优先采用哪个，消除歧 义</li>
<li>计数器 Counters: #bytes 以及 #packets</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7c53f08e49dfc248544a116336af7f86.png"
        data-srcset="./7c53f08e49dfc248544a116336af7f86.png, ./7c53f08e49dfc248544a116336af7f86.png 1.5x, ./7c53f08e49dfc248544a116336af7f86.png 2x"
        data-sizes="auto"
        alt="./7c53f08e49dfc248544a116336af7f86.png"
        title="image-20211001161610989" /></p>
<h4 id="2762-openflow-流表的表项结构">27.6.2 OpenFlow: 流表的表项结构</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./05284a65f00f913003a25ab764d9261c.png"
        data-srcset="./05284a65f00f913003a25ab764d9261c.png, ./05284a65f00f913003a25ab764d9261c.png 1.5x, ./05284a65f00f913003a25ab764d9261c.png 2x"
        data-sizes="auto"
        alt="./05284a65f00f913003a25ab764d9261c.png"
        title="image-20211001161724509" /></p>
<h4 id="2763-例子-基于目标的转发">27.6.3 例子 基于目标的转发</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3e51db0e1a59cea21643c7c43de036d6.png"
        data-srcset="./3e51db0e1a59cea21643c7c43de036d6.png, ./3e51db0e1a59cea21643c7c43de036d6.png 1.5x, ./3e51db0e1a59cea21643c7c43de036d6.png 2x"
        data-sizes="auto"
        alt="./3e51db0e1a59cea21643c7c43de036d6.png"
        title="image-20211001161743836" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2419c0fba1cf7302707f8024077e7482.png"
        data-srcset="./2419c0fba1cf7302707f8024077e7482.png, ./2419c0fba1cf7302707f8024077e7482.png 1.5x, ./2419c0fba1cf7302707f8024077e7482.png 2x"
        data-sizes="auto"
        alt="./2419c0fba1cf7302707f8024077e7482.png"
        title="image-20211001161759335" /></p>
<h4 id="2764-openflow-抽象">27.6.4 OpenFlow 抽象</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c0a692e42dc890ab72ce8db4d5953bf5.png"
        data-srcset="./c0a692e42dc890ab72ce8db4d5953bf5.png, ./c0a692e42dc890ab72ce8db4d5953bf5.png 1.5x, ./c0a692e42dc890ab72ce8db4d5953bf5.png 2x"
        data-sizes="auto"
        alt="./c0a692e42dc890ab72ce8db4d5953bf5.png"
        title="image-20211001161825639" /></p>
<h4 id="2765-openflow-例子">27.6.5 OpenFlow 例子</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f00506c8e3de83b79ce473681afc7a53.png"
        data-srcset="./f00506c8e3de83b79ce473681afc7a53.png, ./f00506c8e3de83b79ce473681afc7a53.png 1.5x, ./f00506c8e3de83b79ce473681afc7a53.png 2x"
        data-sizes="auto"
        alt="./f00506c8e3de83b79ce473681afc7a53.png"
        title="image-20211001161835426" /></p>
<p>问题: 转发表(基于目标的转发)和 流表(通用转发)是如何计算出 来的？ 答案: 通过控制平面(下一章)</p>
<h1 id="第五章网络层控制平面-network-layer-control-plane">第五章：网络层：控制平面 Network layer: control plane</h1>
<h2 id="28-导论">28 导论</h2>
<h2 id="29-网络层功能">29 网络层功能</h2>
<p>回顾:2 个网络层功能:</p>
<ul>
<li><strong>转发:将分组从路由器的一数据平面</strong>
<strong>个输入端口移到合适的输出端口</strong></li>
<li><strong>路由:确定分组从源到目标控制平面的路径</strong></li>
</ul>
<p>2 种构建网络控制平面功能的方法:</p>
<ul>
<li>
<p><strong>每个路由器控制功能实现(传统)</strong></p>
</li>
<li>
<p><strong>逻辑上集中的控制功能实现(software defined networking)</strong></p>
</li>
</ul>
<h3 id="291-传统方式每-路由器per-router控制平面">29.1 传统方式：每-路由器(Per-router)控制平面</h3>
<p>在每一个路由器中的单独路由器算法元件，在控制平面进行 交互</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./dd261410935cd7d90578b4cd17650274.png"
        data-srcset="./dd261410935cd7d90578b4cd17650274.png, ./dd261410935cd7d90578b4cd17650274.png 1.5x, ./dd261410935cd7d90578b4cd17650274.png 2x"
        data-sizes="auto"
        alt="./dd261410935cd7d90578b4cd17650274.png"
        title="image-20211001182236954" /></p>
<h4 id="2911-sdn-方式逻辑上集中的控制平面">29.1.1 SDN 方式：逻辑上集中的控制平面</h4>
<p>一个不同的(通常是远程的)控制器与本地控制代理(CAs) 交互.</p>
<p>上发状态，下发流表</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./08c042243ec3cbbe32218079cbb0ff81.png"
        data-srcset="./08c042243ec3cbbe32218079cbb0ff81.png, ./08c042243ec3cbbe32218079cbb0ff81.png 1.5x, ./08c042243ec3cbbe32218079cbb0ff81.png 2x"
        data-sizes="auto"
        alt="./08c042243ec3cbbe32218079cbb0ff81.png"
        title="image-20211001182317151" /></p>
<h2 id="30-路由选择算法">30 路由选择算法</h2>
<p> link state  distance vector</p>
<h3 id="301-路由route的概念">30.1 路由(route)的概念</h3>
<ul>
<li>
<p><strong>路由:按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径</strong></p>
<ul>
<li>较好路径: 按照某种指标较小的路径</li>
<li>指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均</li>
<li>采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视</li>
</ul>
</li>
<li>
<p><strong>以网络为单位进行路由(路由信息通告+路由计算)</strong> <strong>一个子网 一个子网 进行路由</strong></p>
<ul>
<li>网络为单位进行路由，路由信息传输、计算和匹配的代价低</li>
<li>前提条件是：一个网络所有节点地址前缀相同，且物理上聚集</li>
<li>路由就是：计算网络 到其他网络如何走的问题</li>
</ul>
</li>
<li>
<p><strong>网络到网络的路由= 路由器-路由器之间路由</strong></p>
<ul>
<li>网络对应的路由器 到 其他网络对应的路由器的路由</li>
<li><strong>在一个网络中：路由器-主机之间的通信，链路层解决</strong></li>
</ul>
</li>
<li>
<p>到了这个路由器就是到了这个网络</p>
</li>
</ul>
<h4 id="3011-网络的图抽象">30.1.1 网络的图抽象</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a53da651b9640588f8d18840b1abc1c4.png"
        data-srcset="./a53da651b9640588f8d18840b1abc1c4.png, ./a53da651b9640588f8d18840b1abc1c4.png 1.5x, ./a53da651b9640588f8d18840b1abc1c4.png 2x"
        data-sizes="auto"
        alt="./a53da651b9640588f8d18840b1abc1c4.png"
        title="image-20211001184712732" /></p>
<p><strong>N = 路由器集合 = { u, v, w, x, y, z }</strong>
<strong>E = 链路集合 ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) } 边有代价</strong></p>
<h4 id="3012-图抽象边和路径的代价">30.1.2 图抽象：边和路径的代价</h4>
<p>• c(x,x’) = 链路的代价 (x,x’) - e.g., c(w,z) = 5
•代价可能总为１
•或是 链路带宽的倒数
•或是 拥塞情况的倒数</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ff6d2c282ca07b2375a7565d627f56e0.png"
        data-srcset="./ff6d2c282ca07b2375a7565d627f56e0.png, ./ff6d2c282ca07b2375a7565d627f56e0.png 1.5x, ./ff6d2c282ca07b2375a7565d627f56e0.png 2x"
        data-sizes="auto"
        alt="./ff6d2c282ca07b2375a7565d627f56e0.png"
        title="image-20211001184806495" /></p>
<p>路由的输入：拓扑、边的代价、源节点
输出的输出：源节点的汇集树</p>
<h4 id="3013-最优化原则optimality-principle">30.1.3 最优化原则(optimality principle)</h4>
<ul>
<li>汇集树(sink tree) —— Dijkstra 算法、Bellman-Ford 算法
<ul>
<li><strong>此节点到所有其它节点的最优路径形成的树</strong> <strong>(源节点)</strong> 到源节点的最短距离</li>
<li><strong>路由选择算法就是为所有路由器找到并使用汇集树</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7c8992a7b6d18844f699113e59773734.png"
        data-srcset="./7c8992a7b6d18844f699113e59773734.png, ./7c8992a7b6d18844f699113e59773734.png 1.5x, ./7c8992a7b6d18844f699113e59773734.png 2x"
        data-sizes="auto"
        alt="./7c8992a7b6d18844f699113e59773734.png"
        title="image-20211001184954715" /></p>
<h3 id="302-路由的原则">30.2 路由的原则</h3>
<p>路由选择算法的原则</p>
<ul>
<li>正确性(correctness):算法必须是正确的和完整的,使分 组一站一站接力，正确发向目标站；完整：目标所有的 站地址，在路由表中都能找到相应的表项；没有处理不 了的目标站地址；</li>
<li>简单性(simplicity):算法在计算机上应简单：最优但复杂 的算法，时间上延迟很大，不实用，不应为了获取路由 信息增加很多的通信量；</li>
<li>健壮性(robustness):算法应能适应通信量和网络拓扑的 变化：通信量变化，网络拓扑的变化算法能很快适应； 不向很拥挤的链路发数据，不向断了的链路发送数据；</li>
<li>稳定性(stability)：产生的路由不应该摇摆</li>
<li>公平性(fairness)：对每一个站点都公平</li>
<li>最优性(optimality)：某一个指标的最优，时间上，费用 上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ul>
<h4 id="3021-路由算法分类">30.2.1 路由算法分类</h4>
<p>全局或者局部路由信息?</p>
<p>全局:
 所有的路由器拥有完整的拓和边的代价的信息
 <strong>“link state” 算法</strong></p>
<p>分布式:
 路由器只知道与它有物理连接 关系的邻居路由器，和到相应 邻居路由器的代价值
 叠代地与邻居交换路由信息、 计算路由信息
 <strong>“distance vector” 算法</strong></p>
<p>静态或者动态的?</p>
<ul>
<li><strong>静态:</strong>
<strong> 路由随时间变化缓慢</strong>
<strong>非自适应算法(non-adaptive algorithm)： 不能适应网络拓扑和通信量的变化,路由表是事先计算好的</strong></li>
<li><strong>动态:</strong>
<strong> 路由变化很快</strong>
<strong> 周期性更新</strong>
<strong> 根据链路代价的变化而变化</strong>
<strong>自适应路由选择(adaptive algorithm)：能适应网络拓扑和通信量的变化</strong> —— 网络拓扑状态和边的代价状态</li>
</ul>
<h3 id="303-路由选择算法-link-state-全局">30.3 路由选择算法 link state (全局)</h3>
<h4 id="3031-ls-路由的工作过程">30.3.1 LS 路由的工作过程</h4>
<p>配置 LS 路由选择算法的路由工作过程</p>
<ul>
<li>各点通过各种渠道获得整个网络拓扑, 网络中所有链路代价等信息**(这部分和算法没关系，属于协议和实现)**</li>
<li>使用 LS 路由算法,计算本站点到其它站点的最优路径(汇集树),得到路由表</li>
<li>按照此路由表转发分组(datagram 方式)
<ul>
<li>严格意义上说不是路由的一个步骤</li>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./61c56b5de8bdf2a07871ce6c6195857b.png"
        data-srcset="./61c56b5de8bdf2a07871ce6c6195857b.png, ./61c56b5de8bdf2a07871ce6c6195857b.png 1.5x, ./61c56b5de8bdf2a07871ce6c6195857b.png 2x"
        data-sizes="auto"
        alt="./61c56b5de8bdf2a07871ce6c6195857b.png"
        title="image-20211001224205074" /></p>
<h4 id="3032-链路状态路由选择link-state-routing">30.3.2 链路状态路由选择(link state routing)</h4>
<p>LS 路由的基本工作过程</p>
<ol>
<li>
<p><strong>发现相邻节点,获知对方网络地址</strong></p>
</li>
<li>
<p><strong>测量到相邻节点的代价(延迟,开销)</strong></p>
</li>
<li>
<p><strong>组装一个 LS 分组,描述它到相邻节点的代价情况</strong></p>
</li>
<li>
<p><strong>将分组通过扩散的方法发到所有其它路由器 以上 4 步让每个路由器获得拓扑和边代价</strong></p>
</li>
<li>
<p><strong>通过 Dijkstra 算法找出最短路径(这才是路由算法)</strong></p>
<ol>
<li>
<p>每个节点独立算出来到其他节点(路由器=网络)的最 短路径</p>
</li>
<li>
<p>迭代算法：第 k 步能够知道本节点到 k 个其他节点的最 短路径</p>
</li>
</ol>
</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener noreffer">200. 岛屿数量</a> —— 类似泛洪 FloodFill 算法</p>
<ol>
<li>发现相邻节点,获知对方网络地址
 <strong>一个路由器上电之后,向所有线路发送 HELLO 分组</strong>
 <strong>其它路由器收到 HELLO 分组,回送应答,在应答分组中,告知自己的名字(全局唯一)</strong>
 <strong>在 LAN 中,通过广播 HELLO 分组,获得其它路由器的信息, 可以认为引入一个人工节点</strong></li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e0a031689c455d642e303d3f23bd81a7.png"
        data-srcset="./e0a031689c455d642e303d3f23bd81a7.png, ./e0a031689c455d642e303d3f23bd81a7.png 1.5x, ./e0a031689c455d642e303d3f23bd81a7.png 2x"
        data-sizes="auto"
        alt="./e0a031689c455d642e303d3f23bd81a7.png"
        title="image-20211001224742043" /></p>
<ol start="2">
<li>
<p>测量到相邻节点的代价(延迟,开销)
 <strong>实测法,发送一个分组要求对方立即响应</strong>
 回送一个 ECHO 分组
 通过测量时间可以估算出延迟情况</p>
</li>
<li>
<p>组装一个分组,描述相邻节点的情况
 <strong>发送者名称</strong>
 序号,年龄
 列表: 给出它相邻节点,和它到相邻节点的延迟</p>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f41fe151766b1f01fb88ba65205c148a.png"
        data-srcset="./f41fe151766b1f01fb88ba65205c148a.png, ./f41fe151766b1f01fb88ba65205c148a.png 1.5x, ./f41fe151766b1f01fb88ba65205c148a.png 2x"
        data-sizes="auto"
        alt="./f41fe151766b1f01fb88ba65205c148a.png"
        title="image-20211001230058910" /></p>
<ol start="4">
<li>
<p>将分组通过扩散的方法发到所有其它路由器</p>
<ul>
<li>
<p><strong>顺序号:用于控制无穷的扩散,每个路由器都记录( 源路由器,顺序号),发现重复的或老的就不扩散</strong></p>
<ul>
<li>具体问题 1: 循环使用问题</li>
<li>具体问题 2: 路由器崩溃之后序号从 0 开始</li>
<li>具体问题 3:序号出现错误</li>
</ul>
</li>
<li>
<p><strong>解决问题的办法:年龄字段(age)</strong></p>
<ul>
<li><strong>生成一个分组时,年龄字段不为 0</strong></li>
<li><strong>每个一个时间段,AGE 字段减 1</strong></li>
<li><strong>AGE 字段为 0 的分组将被抛弃</strong></li>
</ul>
</li>
<li>
<p>关于扩散分组的数据结构
 <strong>Source</strong> :从哪个节点收到 LS 分组
 <strong>Seq,Age</strong>:序号,年龄
 <strong>Send flags</strong>:发送标记,必须向指定的哪些相邻站点转发 LS 分组
 <strong>ACK flags</strong>:本站点必须向哪些相邻站点发送应答
 <strong>DATA</strong>:来自 source 站点的 LS 分组</p>
</li>
<li>
<p>节点 B 的数据结构</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d0f3bf31d29d2607db657ec4c62229b8.png"
        data-srcset="./d0f3bf31d29d2607db657ec4c62229b8.png, ./d0f3bf31d29d2607db657ec4c62229b8.png 1.5x, ./d0f3bf31d29d2607db657ec4c62229b8.png 2x"
        data-sizes="auto"
        alt="./d0f3bf31d29d2607db657ec4c62229b8.png"
        title="image-20211002003536511" /></p>
</li>
</ul>
</li>
<li>
<p>通过 Dijkstra 算法找出最短路径</p>
<ol>
<li>路由器获得各站点 LS 分组和整个网络的拓扑</li>
<li>通过 Dijkstra 算法计算出到其它各路由器的最短 路径(汇集树)</li>
<li>将计算结果安装到路由表中</li>
</ol>
</li>
</ol>
<h4 id="3033-ls-路由选择算法的工作原理">30.3.3 LS 路由选择算法的工作原理</h4>
<ul>
<li>
<p>LS (link state) 的应用情况</p>
<ul>
<li>OSPF 协议是一种 LS 协议,被用于 Internet 上</li>
<li>IS-IS(intermediate system- intermediate system): 被用于 Internet 主干中, Netware</li>
</ul>
</li>
<li>
<p>符号标记:
c(i,j): 从节点 i 到 j 链路代价(初始状态下非相邻节点之间的 链路代价为 ∞)
D(v): 从源节点到节点 V 的当前路径代价(节点的代价)
p(v): 从源到节点 V 的路径前序节点
N’: 当前已经知道最优路径的的节点集合(永久节点的集合)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./363bfee7ceaaf83e917d0ba1713ea15b.png"
        data-srcset="./363bfee7ceaaf83e917d0ba1713ea15b.png, ./363bfee7ceaaf83e917d0ba1713ea15b.png 1.5x, ./363bfee7ceaaf83e917d0ba1713ea15b.png 2x"
        data-sizes="auto"
        alt="./363bfee7ceaaf83e917d0ba1713ea15b.png"
        title="image-20211002003950243" /></p>
</li>
<li>
<p>LS 路由选择算法的工作原理</p>
<ul>
<li>节点标记: 每一个节点使用(D(v),p(v)) 如： (3,B)标记
<ul>
<li>D(v)从源节点由已知最优路径到达本节点的距离</li>
<li>P(v)前序节点来标注</li>
</ul>
</li>
<li>2 类节点
<ul>
<li>临时节点(tentative node) :还没有找到从源 节点到此节点的最优路径的节点</li>
<li>永久节点(permanent node) N’:已经找到了从 源节点到此节点的最优路径的节点</li>
</ul>
</li>
</ul>
</li>
<li>
<p> 初始化</p>
<ul>
<li> 除了源节点外,所有节点都为临时节点</li>
<li> 节点代价除了与源节点代价相邻的节点外,都为 ∞</li>
</ul>
</li>
<li>
<p> <strong>从所有临时节点中找到一个节点代价最小的临时节点,将 之变成永久节点(当前节点)W —— 选择</strong></p>
</li>
<li>
<p> <strong>对此节点的所有在临时节点集合中的邻节点(V) —— 更新</strong></p>
<ul>
<li> 如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W)</li>
<li> 否则，不重新标注</li>
</ul>
</li>
<li>
<p> <strong>开始一个新的循环 —— 循环</strong></p>
</li>
</ul>
<p>例子:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c959801d9668d2438a7e35240362d321.png"
        data-srcset="./c959801d9668d2438a7e35240362d321.png, ./c959801d9668d2438a7e35240362d321.png 1.5x, ./c959801d9668d2438a7e35240362d321.png 2x"
        data-sizes="auto"
        alt="./c959801d9668d2438a7e35240362d321.png"
        title="image-20211002004447848" /></p>
<p>Dijkstra 算法的例子</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tnnTCzZk-1633167453948)(C:\Users\20662\AppData\Roaming\Typora\typora-user-images\image-20211002004517248.png)]</p>
<h4 id="3034-dijkstra-算法的讨论">30.3.4 Dijkstra 算法的讨论</h4>
<p>算法复杂度: n 节点
 每一次迭代: 需要检查所有不在永久集合 N 中节点
 n(n+1)/2 次比较: O(n2 )
 有很有效的实现: O(nlogn)
可能的震荡：
 e.g.,链路代价=链路承载的流量
路径改变次数过多</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./64dcf013e9c3dc20431c8901a4001610.png"
        data-srcset="./64dcf013e9c3dc20431c8901a4001610.png, ./64dcf013e9c3dc20431c8901a4001610.png 1.5x, ./64dcf013e9c3dc20431c8901a4001610.png 2x"
        data-sizes="auto"
        alt="./64dcf013e9c3dc20431c8901a4001610.png"
        title="image-20211002005838258" /></p>
<h3 id="304-路由选择算法-distance-vector-分布式">30.4 路由选择算法 distance vector (分布式)</h3>
<h4 id="3041-距离矢量路由选择distance-vector-routing">30.4.1 距离矢量路由选择(distance vector routing)</h4>
<p>动态路由算法之一</p>
<p>DV 算法历史及应用情况</p>
<ul>
<li>1957 Bellman, 1962 Ford Fulkerson</li>
<li>用于 ARPANET, Internet(RIP) DECnet , Novell, ApplTalk</li>
</ul>
<p>距离矢量路由选择的基本思想 <strong>以每个点为中心 更新路由表</strong></p>
<ul>
<li>各路由器维护一张路由表,结构如图(其它代价)</li>
<li>各路由器与相邻路由器交换路由表(待续) <strong>邻居与邻居交换代价</strong></li>
<li>根据获得的路由信息,更新路由表(待续) <strong>每个节点算出代价值，改变路径，更新路由表</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2013883af3fb9473e06dc1152b313c2c.png"
        data-srcset="./2013883af3fb9473e06dc1152b313c2c.png, ./2013883af3fb9473e06dc1152b313c2c.png 1.5x, ./2013883af3fb9473e06dc1152b313c2c.png 2x"
        data-sizes="auto"
        alt="./2013883af3fb9473e06dc1152b313c2c.png"
        title="image-20211002010557843" /></p>
<ul>
<li>代价及相邻节点间代价的获得
<ul>
<li><strong>跳数(hops), 延迟(delay),队列长度</strong></li>
<li><strong>相邻节点间代价的获得：通过实测</strong></li>
</ul>
</li>
<li>路由信息的更新
<ul>
<li><strong>根据实测 得到本节点 A 到相邻站点的代价(如:延迟)</strong></li>
<li><strong>根据各相邻站点声称它们到目标站点 B 的代价</strong></li>
<li><strong>计算出本站点 A 经过各相邻站点到目标站点 B 的代价</strong></li>
<li><strong>找到一个最小的代价，和相应的下一个节点 Z，到达节点 B 经过此节点 Z，并且代价为 A-Z-B 的代价</strong></li>
<li><strong>其它所有的目标节点同样的计算方法</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9cd85029c08e4c884483d30cd965e491.png"
        data-srcset="./9cd85029c08e4c884483d30cd965e491.png, ./9cd85029c08e4c884483d30cd965e491.png 1.5x, ./9cd85029c08e4c884483d30cd965e491.png 2x"
        data-sizes="auto"
        alt="./9cd85029c08e4c884483d30cd965e491.png"
        title="image-20211002010843273" /></p>
<h4 id="3042-距离矢量路由例子-1">30.4.2 距离矢量路由：例子 1</h4>
<ul>
<li>以当前节点 J 为例,相邻节点 A,I,H,K</li>
<li>J 测得到 A,I,H,K 的延迟为 8ms,10ms,12ms,6ms</li>
<li>通过交换 DV, 从 A,I,H,K 获得到 它们到 G 的延迟为 18ms,31ms,6ms,31ms</li>
<li>因此从 J 经过 A,I,H,K 到 G 的延迟 为 26ms,41ms,18ms, 37ms</li>
<li>将到 G 的路由表项更新为 18ms, 下一跳为：H</li>
<li>其它目标一样，除了本节点 J</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e3f9dac61a66e8fcbe2bb04e341c0297.png"
        data-srcset="./e3f9dac61a66e8fcbe2bb04e341c0297.png, ./e3f9dac61a66e8fcbe2bb04e341c0297.png 1.5x, ./e3f9dac61a66e8fcbe2bb04e341c0297.png 2x"
        data-sizes="auto"
        alt="./e3f9dac61a66e8fcbe2bb04e341c0297.png"
        title="image-20211002012113751" /></p>
<h4 id="3043-距离矢量算法">30.4.3 距离矢量算法</h4>
<p>递归风车</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d8cd4030baa62f0dd0bd811e3cd20fc7.png"
        data-srcset="./d8cd4030baa62f0dd0bd811e3cd20fc7.png, ./d8cd4030baa62f0dd0bd811e3cd20fc7.png 1.5x, ./d8cd4030baa62f0dd0bd811e3cd20fc7.png 2x"
        data-sizes="auto"
        alt="./d8cd4030baa62f0dd0bd811e3cd20fc7.png"
        title="image-20211002012204557" /></p>
<h4 id="3044-bellman-ford-例子httpswwwbilibilicomvideobv14x411h7x9fromsearchseid2324818079252436290spm_id_from33333700">30.4.4 <a href="https://www.bilibili.com/video/BV14x411H7x9?from=search&amp;seid=2324818079252436290&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener noreffer">Bellman-Ford 例子</a></h4>
<p>SPFA —— 优化后的 Bellman-Ford</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./194a983871ebbce8c127dfa94aaa7157.png"
        data-srcset="./194a983871ebbce8c127dfa94aaa7157.png, ./194a983871ebbce8c127dfa94aaa7157.png 1.5x, ./194a983871ebbce8c127dfa94aaa7157.png 2x"
        data-sizes="auto"
        alt="./194a983871ebbce8c127dfa94aaa7157.png"
        title="image-20211002012336956" /></p>
<ul>
<li>Dx (y) = 节点 x 到 y 代价最小值的估计
<ul>
<li>x 节点维护距离矢量 Dx = [Dx (y): y є N ]</li>
</ul>
</li>
<li>节点 x:
<ul>
<li>知道到所有邻居 v 的代价: c(x,v)</li>
<li>收到并维护一个它邻居的距离矢量集</li>
<li>对于每个邻居, x 维护 Dv = [Dv (y): y є N ]</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9c289b5b56934a69532a6b890742dfee.png"
        data-srcset="./9c289b5b56934a69532a6b890742dfee.png, ./9c289b5b56934a69532a6b890742dfee.png 1.5x, ./9c289b5b56934a69532a6b890742dfee.png 2x"
        data-sizes="auto"
        alt="./9c289b5b56934a69532a6b890742dfee.png"
        title="image-20211002012514899" /></p>
<h4 id="3045-距离矢量算法特点和问题">30.4.5 距离矢量算法特点和问题</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3d0c1301affad527db33136a0f3a1996.png"
        data-srcset="./3d0c1301affad527db33136a0f3a1996.png, ./3d0c1301affad527db33136a0f3a1996.png 1.5x, ./3d0c1301affad527db33136a0f3a1996.png 2x"
        data-sizes="auto"
        alt="./3d0c1301affad527db33136a0f3a1996.png"
        title="image-20211002012604939" /></p>
<ul>
<li>
<p>DV 的无穷计算问题</p>
<ul>
<li>DV 的特点
<ul>
<li>好消息传的快 坏消息传的慢</li>
</ul>
</li>
<li>好消息的传播以每一个交换周期前进一个路由器 的速度进行
<ul>
<li>好消息:某个路由器接入或有更短的路径</li>
<li>举例
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6be5d1fec9a0ced6887d5b7581ff7b38.png"
        data-srcset="./6be5d1fec9a0ced6887d5b7581ff7b38.png, ./6be5d1fec9a0ced6887d5b7581ff7b38.png 1.5x, ./6be5d1fec9a0ced6887d5b7581ff7b38.png 2x"
        data-sizes="auto"
        alt="./6be5d1fec9a0ced6887d5b7581ff7b38.png"
        title="image-20211002012712585" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>DV 的无穷计算问题</p>
<ul>
<li>坏消息的传播速度非常慢(无穷计算问题)</li>
<li>例子:
<ul>
<li>第一次交换之后, B 从 C 处获得信息,C 可以到达 A(C-A, 要经过 B 本身),但是路径是 2,因此 B 变成 3,从 C 处走</li>
<li>第二次交换,C 从 B 处获得消息, B 可以到达 A,路径为 3, 因此,C 到 A 从 B 走,代价为 3</li>
<li>无限此之后, 到 A 的距离变成 INF,不可达</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./dc9e19fec59ae5785e94396cc4cb684c.png"
        data-srcset="./dc9e19fec59ae5785e94396cc4cb684c.png, ./dc9e19fec59ae5785e94396cc4cb684c.png 1.5x, ./dc9e19fec59ae5785e94396cc4cb684c.png 2x"
        data-sizes="auto"
        alt="./dc9e19fec59ae5785e94396cc4cb684c.png"
        title="image-20211002012915419" /></p>
<h4 id="3046-水平分裂split-horizon算法">30.4.6 水平分裂(split horizon)算法</h4>
<ul>
<li>一种对无穷计算问题的解决办法 —— 结局坏消息传的慢的问题
<ul>
<li><strong>C 知道要经过 B 才能到达 A，所以 C 向 B 报告它到 A 的距离 为 INF；C 告诉 D 它到 A 的真实距离</strong></li>
<li>D 告诉 E,它到 A 的距离,但 D 告诉 C 它通向 A 的距离为 INF</li>
<li>第一次交换: B 通过测试发现到 A 的路径为 INF,而 C 也告 诉 B 到 A 的距离为 INF,因此,B 到 A 的距离为 INF</li>
<li>第二次交换: C 从 B 和 D 那里获知,到 A 的距离为 INF,因此 将它到 A 的距离为 INF</li>
<li>……坏消息以一次交换一个节点的速度传播</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1825b2abb63bb526a6e1c7e7c74af0b5.png"
        data-srcset="./1825b2abb63bb526a6e1c7e7c74af0b5.png, ./1825b2abb63bb526a6e1c7e7c74af0b5.png 1.5x, ./1825b2abb63bb526a6e1c7e7c74af0b5.png 2x"
        data-sizes="auto"
        alt="./1825b2abb63bb526a6e1c7e7c74af0b5.png"
        title="image-20211002112809523" /></p>
<p>告诉 B 无穷，D 真实值</p>
<h4 id="3047-距离矢量算法例子">30.4.7 距离矢量算法例子</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c5ff8cc1cf63ad5c7ca83aebf297ac70.png"
        data-srcset="./c5ff8cc1cf63ad5c7ca83aebf297ac70.png, ./c5ff8cc1cf63ad5c7ca83aebf297ac70.png 1.5x, ./c5ff8cc1cf63ad5c7ca83aebf297ac70.png 2x"
        data-sizes="auto"
        alt="./c5ff8cc1cf63ad5c7ca83aebf297ac70.png"
        title="image-20211002113230006" /></p>
<h3 id="305-ls-和-dv-算法的比较">30.5 LS 和 DV 算法的比较</h3>
<p><strong>消息复杂度(DV 胜出)</strong> O(NE)</p>
<p><strong>收敛时间(LS 胜出)</strong> O(NlogN)</p>
<p><strong>健壮性(LS 胜出)</strong> 节点之间影响较小</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a3ee27f4910197b9041948c06e7b1e4f.png"
        data-srcset="./a3ee27f4910197b9041948c06e7b1e4f.png, ./a3ee27f4910197b9041948c06e7b1e4f.png 1.5x, ./a3ee27f4910197b9041948c06e7b1e4f.png 2x"
        data-sizes="auto"
        alt="./a3ee27f4910197b9041948c06e7b1e4f.png"
        title="image-20211002113320727" /></p>
<h2 id="31-因特网中自治系统内部的路由选择-实际的内部的">31 因特网中自治系统内部的路由选择 (实际的、内部的)</h2>
<h3 id="311-rip--routing-information-protocol">31.1 RIP ( Routing Information Protocol)</h3>
<p>在 1982 年发布的 BSD-UNIX 中实现</p>
<ul>
<li><strong>Distance vector 算法</strong></li>
<li>距离矢量:每条链路 cost=1，# of hops (max = 15 hops) 跳数</li>
<li>DV 每隔 30 秒和邻居交换 DV，通告</li>
<li>每个通告包括：最多 25 个目标子网</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e0d0b56dcf61ebd800fcc3d381e6daee.png"
        data-srcset="./e0d0b56dcf61ebd800fcc3d381e6daee.png, ./e0d0b56dcf61ebd800fcc3d381e6daee.png 1.5x, ./e0d0b56dcf61ebd800fcc3d381e6daee.png 2x"
        data-sizes="auto"
        alt="./e0d0b56dcf61ebd800fcc3d381e6daee.png"
        title="image-20211002144643968" /></p>
<h4 id="3111-rip-通告advertisements">31.1.1 RIP 通告(advertisements)</h4>
<ul>
<li>DV: 在邻居之间每 30 秒交换通告报文
<ul>
<li>定期，而且在改变路由的时候发送通告报文</li>
<li>在对方的请求下可以发送通告报文</li>
</ul>
</li>
<li>每一个通告: 至多 AS 内部的 25 个目标网络的 DV
<ul>
<li>目标网络+跳数
一次公告最多 25 个 子网 最大跳数为 16</li>
</ul>
</li>
</ul>
<h4 id="3112-rip-例子">31.1.2 RIP: 例子</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./cccb6afb0d5bfb9300d986d87aff0df7.png"
        data-srcset="./cccb6afb0d5bfb9300d986d87aff0df7.png, ./cccb6afb0d5bfb9300d986d87aff0df7.png 1.5x, ./cccb6afb0d5bfb9300d986d87aff0df7.png 2x"
        data-sizes="auto"
        alt="./cccb6afb0d5bfb9300d986d87aff0df7.png"
        title="image-20211002161034218" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ad712284d1ac227f868746c1f03e20bb.png"
        data-srcset="./ad712284d1ac227f868746c1f03e20bb.png, ./ad712284d1ac227f868746c1f03e20bb.png 1.5x, ./ad712284d1ac227f868746c1f03e20bb.png 2x"
        data-sizes="auto"
        alt="./ad712284d1ac227f868746c1f03e20bb.png"
        title="image-20211002161049443" /></p>
<h4 id="3113-rip-链路失效和恢复">31.1.3 RIP: 链路失效和恢复</h4>
<p>如果 180 秒没有收到通告信息–&gt;邻居或者链路失效</p>
<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告 (如果路由变化的话)</li>
<li>链路失效快速(?)地在整网中传输</li>
<li>使用毒性逆转(poison reverse)阻止 ping-pong 回路 ( 不可达的距离：跳数无限 = 16 段)</li>
</ul>
<h4 id="3114-rip-进程处理">31.1.4 RIP 进程处理</h4>
<ul>
<li>RIP 以应用进程的方式实现：route-d (daemon)</li>
<li>通告报文通过 UDP 报文传送，周期性重复</li>
<li>网络层的协议使用了传输层的服务，以应用层实体的 方式实现</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f9149169422e6e91c8ca4f3c64744bd9.png"
        data-srcset="./f9149169422e6e91c8ca4f3c64744bd9.png, ./f9149169422e6e91c8ca4f3c64744bd9.png 1.5x, ./f9149169422e6e91c8ca4f3c64744bd9.png 2x"
        data-sizes="auto"
        alt="./f9149169422e6e91c8ca4f3c64744bd9.png"
        title="image-20211002161616471" /></p>
<h3 id="312-ospf-open-shortest-path-first">31.2 OSPF (Open Shortest Path First)</h3>
<ul>
<li>“open”: 标准可公开获得</li>
<li><strong>使用 LS 算法</strong>
<ul>
<li>LS 分组在网络中(一个 AS 内部)分发</li>
<li>全局网络拓扑、代价在每一个节点中都保持</li>
<li>路由计算采用 Dijkstra 算法</li>
</ul>
</li>
<li>OSPF 通告信息中携带：每一个邻居路由器一个表项</li>
<li>通告信息会传遍 AS 全部(通过泛洪)
<ul>
<li>在 IP 数据报上直接传送 OSPF 报文 (而不是通过 UDP 和 TCP)</li>
</ul>
</li>
<li>IS-IS 路由协议：几乎和 OSPF 一样</li>
</ul>
<h4 id="3121-ospf-高级-特性在-rip-中的没有的">31.2.1 OSPF “高级” 特性(在 RIP 中的没有的)</h4>
<ul>
<li>安全:所有的 OSPF 报文都是经过认证的(防止恶意的攻击)</li>
<li>允许有多个代价相同的路径存在(在 RIP 协议中只有一个)</li>
<li>对于每一个链路，对于不同的 TOS 有多重代价矩阵
<ul>
<li>例如:卫星链路代价对于尽力而为的服务代价设置比较低，对实
时服务代价设置的比较高</li>
<li>支持按照不同的代价计算最优路径，如:按照时间和延迟分别计
算最优路径</li>
</ul>
</li>
<li>对单播和多播的集成支持:
<ul>
<li>Multicast OSPF(MOSPF)使用相同的拓扑数据库，就像在 OSPF 中一样</li>
</ul>
</li>
<li>在大型网络中支持层次性 OSPF</li>
</ul>
<h4 id="3122-层次化的-ospf-路由">31.2.2 层次化的 OSPF 路由</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./38f6699c10fc52a1fc87b90c998905f4.png"
        data-srcset="./38f6699c10fc52a1fc87b90c998905f4.png, ./38f6699c10fc52a1fc87b90c998905f4.png 1.5x, ./38f6699c10fc52a1fc87b90c998905f4.png 2x"
        data-sizes="auto"
        alt="./38f6699c10fc52a1fc87b90c998905f4.png"
        title="image-20211002170733474" /></p>
<h4 id="3123-层次性的-ospf-路由">31.2.3 层次性的 OSPF 路由</h4>
<ul>
<li>2 个级别的层次性: 本地, 骨干
<ul>
<li>链路状态通告仅仅在本地区域 Area 范围内进行</li>
<li>每一个节点拥有本地区域的拓扑信息；</li>
</ul>
</li>
<li>关于其他区域，知道去它的方向，通过区域边界路 由器(最短路径)</li>
<li>区域边界路由器: “汇总(聚集)”到自己区域 内网络的距离, 向其它区域边界路由器通告.</li>
<li>骨干路由器: 仅仅在骨干区域内，运行 OSPF 路由</li>
<li>边界路由器: 连接其它的 AS’s.</li>
</ul>
<h2 id="32-isp-之间的路由选择-bgp">32 ISP 之间的路由选择: BGP</h2>
<h3 id="321-层次路由">32.1 层次路由</h3>
<p>一个平面的路由</p>
<ul>
<li>一个网络中的所有路 由器的地位一样</li>
<li>通过 LS, DV，或者其 他路由算法，所有路 由器都要知道其他所 有路由器(子网)如 何走</li>
<li>所有路由器在一个平 面</li>
</ul>
<p>平面路由的问题</p>
<ul>
<li><strong>规模巨大的网络中，路由信息的存储、传输和计算代价 巨大</strong>
<ul>
<li>DV: 距离矢量很大，且不能够 收敛</li>
<li>LS：几百万个节点的 LS 分组 的泛洪传输，存储以及最短路 径算法的计算</li>
</ul>
</li>
<li><strong>管理问题：</strong> (一个平面搞不定)
<ul>
<li>不同的网络所有者希望按照自 己的方式管理网络</li>
<li>希望对外隐藏自己网络的细节</li>
<li>当然，还希望和其它网络互联</li>
</ul>
</li>
</ul>
<h4 id="3211-层次路由的实现">32.1.1 层次路由的实现</h4>
<ul>
<li>
<p>层次路由：将互联网 分成一个个 AS(路由器 区域)</p>
<ul>
<li><strong>某个区域内的路由器集 合，自治系统 “autonomous systems” (AS)</strong></li>
<li>一个 AS 用 AS Number (ASN)唯一标示</li>
<li>一个 ISP 可能包括 1 个 或者多个 AS</li>
</ul>
</li>
<li>
<p>路由变成了: 2 个层次路由</p>
<ul>
<li><strong>AS 内部路由：在同一个 AS 内路由器运行相同的路由协议</strong>
<ul>
<li>“intra-AS” routing protocol：内部网关协议</li>
<li>不同的 AS 可能运行着不同的 内部网关协议</li>
<li>能够解决规模和管理问题</li>
<li>如：RIP,OSPF,IGRP</li>
<li>网关路由器：AS 边缘路由器 ，可以连接到其他 AS</li>
</ul>
</li>
<li><strong>AS 间运行 AS 间路由协议</strong>
<ul>
<li><strong>“inter-AS” routing protocol：外部网关协议</strong></li>
<li><strong>解决 AS 之间的路由问题，完成 AS 之间的互联互通</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3212-层次路由的优点">32.1.2 层次路由的优点</h4>
<ul>
<li>解决了<strong>规模问题</strong>
<ul>
<li><strong>内部网关协议解决:AS 内部数量有限的路由器相互到达的间题，AS 内部规模可控</strong>
<ul>
<li>如 AS 节点太多，可分割 AS，使得 AS 内部的节点数量有限</li>
</ul>
</li>
<li>AS 之间的路由的规模问题
<ul>
<li>增加一个 As，对于 AS 之间的路由从总体上来说，只是增加了一个节点=子网(每个 AS 可以用一个点来表示)</li>
<li>对于其他 AS 来说只是增加了一个表项，就是这个新增的 AS 如何走的问题</li>
<li><strong>扩展性强:规模增大，性能不会减得太多</strong></li>
</ul>
</li>
</ul>
</li>
<li>解决了<strong>管理问题</strong>
<ul>
<li><strong>各个 AS 可以运行不 同的内部网关协议</strong></li>
<li><strong>可以使自己网络的细节不向外透露</strong></li>
</ul>
</li>
</ul>
<h3 id="322-互联网-as-间路由bgp-边界网关协议">32.2 互联网 AS 间路由：BGP 边界网关协议</h3>
<ul>
<li>BGP (Border Gateway Protocol):自治区域间路由协议&quot;事实上的&quot;标准
o <strong>&ldquo;将互联网各个 AS 粘在一起的胶水”</strong></li>
<li>BGP 提供给每个 AS 以以下方法:
o <strong>eBGP:从相邻的 ASes 那里获得子网可达信息</strong> —— 从外部获取
o <strong>iBGP:将获得的子网可达信息传遍到 AS 内部的所有路由器</strong> —— 向内部传
o <strong>根据子网可达信息和策略来决定到达子网的&quot;好&quot;路径</strong></li>
<li>允许子网向互联网其他网络通告&quot;我在这里”</li>
<li>基于距离矢量算法(路径矢量)
o 不仅仅是距离矢量，还包括到达各个目标网络的详细路径(AS
序号的列表)能够避免简单 DV 算法的路由环路问题</li>
</ul>
<h4 id="3221-ebgp-ibgp-连接">32.2.1 eBGP, iBGP 连接</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./08ea96ec9852f7c33902a28037b4de4d.png"
        data-srcset="./08ea96ec9852f7c33902a28037b4de4d.png, ./08ea96ec9852f7c33902a28037b4de4d.png 1.5x, ./08ea96ec9852f7c33902a28037b4de4d.png 2x"
        data-sizes="auto"
        alt="./08ea96ec9852f7c33902a28037b4de4d.png"
        title="image-20211002172739773" /></p>
<h2 id="33-sdn-控制平面">33 SDN 控制平面</h2>
<h3 id="331-software-defined-networking-sdn">33.1 Software defined networking (SDN)</h3>
<ul>
<li> 互联网络网络层：历史上都是通过分布式、每个 路由器的实现
<ul>
<li> 单个路由器包含了：交换设备硬件、私有路由器 OS( 如：思科 IOS)和其上运行的互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li>
<li> 需要不同的中间盒来实现不同网络层功能：防火墙， 负载均衡设备和 NAT…</li>
</ul>
</li>
</ul>
<h4 id="3311-sdn-面临的挑战">33.1.1 SDN: 面临的挑战</h4>
<ul>
<li>强化控制平面：可信、可靠、性能可扩展性、 安全的分布式系统
<ul>
<li>对于失效的鲁棒性： 利用为控制平面可靠分布式系 统的强大理论</li>
<li>可信任，安全：从开始就进行铸造</li>
</ul>
</li>
<li>网络、协议满足特殊任务的需求
<ul>
<li>e.g., 实时性，超高可靠性、超高安全性</li>
</ul>
</li>
<li>互联网络范围内的扩展性
<ul>
<li>而不是仅仅在一个 AS 的内部部署，全网部署</li>
</ul>
</li>
</ul>
<h2 id="34-icmp-因特网控制报-文协议">34 ICMP: 因特网控制报 文协议</h2>
<h3 id="341-icmp-internet-control-message-protocol">34.1 ICMP: Internet Control Message Protocol</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./aca91a2baff3e9f54d02eeceac39abad.png"
        data-srcset="./aca91a2baff3e9f54d02eeceac39abad.png, ./aca91a2baff3e9f54d02eeceac39abad.png 1.5x, ./aca91a2baff3e9f54d02eeceac39abad.png 2x"
        data-sizes="auto"
        alt="./aca91a2baff3e9f54d02eeceac39abad.png"
        title="image-20211002173250939" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./05cf77d3214550375fabf511ebdee882.png"
        data-srcset="./05cf77d3214550375fabf511ebdee882.png, ./05cf77d3214550375fabf511ebdee882.png 1.5x, ./05cf77d3214550375fabf511ebdee882.png 2x"
        data-sizes="auto"
        alt="./05cf77d3214550375fabf511ebdee882.png"
        title="image-20211002173303211" /></p>
<h2 id="35-网络管理和-snmp略">35 网络管理和 SNMP(略)</h2>
<h3 id="351-什么是网络管理">35.1 什么是网络管理?</h3>
<p>自治系统(autonomous systems, aka “network”): 1000 多个 相互的软件和硬件部件</p>
<p>其他复杂系统也需要被监视和控制:  喷气飞机  核电站  其他例子？</p>
<blockquote>
<p>“网络管理”包括了硬件、软件和人类元素的设置，综合和协 调，以便监测，测试，轮询，配置，分析，评价和控制网络 和网元资源，用合理的成本满足实时性，运行能和服务质量 的要求；</p>
</blockquote>
<p>性能管理:
О 性能(利用率、吞吐量)量化、测量、报告、分析和控制不同网络部件的性能
o 涉及到的部件:单独部件(网卡，协议实体)，端到端的路径故障管理:记录、检测和响应故障;
○ 性能管理为长期监测设备性能</p>
<p>故障管理:突然发生的强度大的性能降低，强调对故障的响应配置管理:跟踪设备的配置，管理设备配置信息</p>
<p>账户管理:定义、记录和控制用户和设备访问网络资源
o 限额使用、给予使用的收费，以及分配资源访问权限</p>
<p>安全管理:定义安全策略，控制对网络资源的使用</p>
<h3 id="352-网络管理架构">35.2 网络管理架构</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6ef7b4a959e9e18eb20f09fffd36ebf7.png"
        data-srcset="./6ef7b4a959e9e18eb20f09fffd36ebf7.png, ./6ef7b4a959e9e18eb20f09fffd36ebf7.png 1.5x, ./6ef7b4a959e9e18eb20f09fffd36ebf7.png 2x"
        data-sizes="auto"
        alt="./6ef7b4a959e9e18eb20f09fffd36ebf7.png"
        title="image-20211002173448692" /></p>
<h3 id="353-snmp-协议">35.3 SNMP 协议</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./bdb073aee88225b5d35a120a9b294b0b.png"
        data-srcset="./bdb073aee88225b5d35a120a9b294b0b.png, ./bdb073aee88225b5d35a120a9b294b0b.png 1.5x, ./bdb073aee88225b5d35a120a9b294b0b.png 2x"
        data-sizes="auto"
        alt="./bdb073aee88225b5d35a120a9b294b0b.png"
        title="image-20211002173459816" /></p>
<h4 id="3531-snmp-协议-报文类型">35.3.1 SNMP 协议: 报文类型</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6bd7678b243f9bb7d51fec370ef7370b.png"
        data-srcset="./6bd7678b243f9bb7d51fec370ef7370b.png, ./6bd7678b243f9bb7d51fec370ef7370b.png 1.5x, ./6bd7678b243f9bb7d51fec370ef7370b.png 2x"
        data-sizes="auto"
        alt="./6bd7678b243f9bb7d51fec370ef7370b.png"
        title="image-20211002173514916" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./197ee2cfce70c45ca16dca75b490d7e8.png"
        data-srcset="./197ee2cfce70c45ca16dca75b490d7e8.png, ./197ee2cfce70c45ca16dca75b490d7e8.png 1.5x, ./197ee2cfce70c45ca16dca75b490d7e8.png 2x"
        data-sizes="auto"
        alt="./197ee2cfce70c45ca16dca75b490d7e8.png"
        title="image-20211002173523394" /></p>
<h2 id="36-第五章总结">36 第五章：总结</h2>
<ul>
<li>网络层控制平面的方法
o**每个路由器控制(传统方法)**
o**逻辑上集中的控制(software defined networking)** SDN</li>
<li>传统路由选择算法
o**在互联网上的实现:RIP，OSPF，BGP**</li>
<li>SDN 控制器
o <strong>实际中的实现:ODL,ONOS</strong></li>
<li>Internet Control Message Protocol</li>
<li>网络管理和 SNMP 协议</li>
</ul>
<h1 id="第六章数据链路层和局域网-data-link-layer-and-local-area-network">第六章：数据链路层和局域网 Data link layer and local area network</h1>
<h2 id="37-数据链路层和局域网">37 数据链路层和局域网</h2>
<p>WAN—— 广域网，LAN —— 局域网</p>
<ul>
<li>
<p><strong>WAN:网络形式采用点到点链路</strong>
带宽大、距离远(延迟大)</p>
<blockquote>
<p>带宽延迟积大
如果采用多点连接方式
• 竞争方式：一旦冲突代价 大
• 令牌等协调方式：在其中 协调节点的发送代价大</p>
</blockquote>
</li>
<li>
<p><strong>点到点链路的链路层服务 实现非常简单，封装和解 封装</strong></p>
</li>
<li>
<p><strong>LAN 一般采用多点连接方式</strong>
 连接节点非常方便  接到共享型介质上(或网络 交换机)，就可以连接所有其他节点</p>
</li>
<li>
<p><strong>多点连接方式网络的链路层 功能实现相当复杂</strong>
 多点接入：协调各节点对共 享性介质的访问和使用
 竞争方式：冲突之后的协调 ；
 令牌方式：令牌产生，占有 和释放等</p>
</li>
</ul>
<h2 id="38-引论和服务">38 引论和服务</h2>
<h2 id="39-链路层-导论">39 链路层: 导论</h2>
<p>一些术语:</p>
<ul>
<li><strong>主机和路由器是节点(网桥和交换机也是): nodes</strong></li>
<li><strong>沿着通信路径,连接个相邻节点通信信道的是链路:links</strong>
<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li><strong>第二层协议数据单元帧 frame，封装数据报</strong></li>
</ul>
<p><strong>数据链路层负责从一个节点通过链路将(帧中的)数据报发送到相邻的物理节点(一个子网内部的 2 节点)</strong></p>
<h3 id="391-链路层-上下文">39.1 链路层: 上下文</h3>
<ul>
<li>
<p>数据报(分组)在不同的链路上<strong>以不同的链路协议</strong>传送：
 <strong>第一跳链路</strong>：以太网
 <strong>中间链路</strong>：帧中继链路
 <strong>最后一跳</strong>：802.11 (无线局域网通用的标准)</p>
</li>
<li>
<p>不同的链路协议提供不同 的服务</p>
<ul>
<li>e.g.,比如在链路层上提供( 或没有)可靠数据传送</li>
</ul>
</li>
</ul>
<p>传输类比</p>
<ul>
<li>从 Princeton 到 Lausanne
<ul>
<li>轿车: Princeton to JFK</li>
<li>飞机: JFK to Geneva</li>
<li>火车: Geneva to Lausanne</li>
</ul>
</li>
<li><strong>旅行者=数据报</strong>datagram</li>
<li><strong>交通段=通信链路</strong> communication link</li>
<li><strong>交通模式=链路层协议</strong> : 数 据链路层和局域网 protocol</li>
<li><strong>票务代理=路由算法</strong> routing algorithm</li>
</ul>
<h4 id="3911-链路层服务">39.1.1 链路层服务</h4>
<ul>
<li><strong>成帧，链路接入</strong>：
<ul>
<li>将数据报封装在帧中，加上帧头、帧尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用“MAC”(物理)地址来标示源和目的
• 不同于 IP 地址</li>
</ul>
</li>
<li><strong>在(一个网络内)相邻两个节点完成可靠数据传递</strong>
<ul>
<li>已经学过了(第三章) —— 传输层</li>
<li>在低出错率的链路上(光纤和双绞线电缆)很少使用</li>
<li>在无线链路经常使用：出错率高</li>
</ul>
</li>
</ul>
<p><strong>Q: 为什么在链路层和传输层都实现了可靠性？</strong></p>
<blockquote>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务
一个特定的链路层只是提供其中一部分的服务</p>
</blockquote>
<ul>
<li>
<p>在相邻节点间(一个子网内)进行可靠的转发</p>
<ul>
<li>我们已经学习过(见第三章)！</li>
<li><strong>在低差错链路上很少使用 (光纤,一些双绞线)</strong>
<ul>
<li>出错率低，没有必要在每一个帧中做差错控制的工作，协议复杂
<ul>
<li>发送端对每一帧进行差错控制编码，根据反馈做相应的动作</li>
<li>接收端进行差错控制解码，反馈给发送端(ACK，NAK)</li>
</ul>
</li>
<li>在本层放弃可靠控制的工作，在网络层或者是传输层做可靠控制的工作，或者根本就不做可靠控制的工作</li>
</ul>
</li>
<li>在高差错链路上需要进行可靠的数据传送
<ul>
<li>高差错链路：无线链路：
<ul>
<li><strong>Q：为什么要在采用无线链路的网络上，链路层做可靠数据传输工作 ；还要在传输层做端到端的可靠性工作？</strong></li>
<li><strong>原因：出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</strong> —— 出错率较大的时候，传到上层再纠错代价大
<ul>
<li><strong>如不做 local recovery 工作，总体代价大</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>流量控制：</strong></p>
<ul>
<li>使得相邻的发送和接收方节点的速度匹配</li>
</ul>
</li>
<li>
<p><strong>错误检测：</strong></p>
<ul>
<li>差错由信号衰减和噪声引起</li>
<li>接收方检测出的错误:
<ul>
<li>通知发送端进行重传或丢弃帧</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>差错纠正:</strong></p>
<ul>
<li>接收端检查和纠正 bit 错误，不通过重传来纠正错误</li>
</ul>
</li>
<li>
<p><strong>半双工和全双工:</strong></p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<h4 id="3912-链路层在哪里实现">39.1.2 链路层在哪里实现？</h4>
<ul>
<li>在每一个主机上
<ul>
<li>也在每个路由器上</li>
<li>交换机的每个端口上</li>
</ul>
</li>
<li>链路层功能在“适配器”上 实现 (aka network interface card NIC) 或 者在一个芯片组上
<ul>
<li>以太网卡，802.11 网卡 ; 以太网芯片组</li>
<li>实现链路层和相应的物 理层功能</li>
</ul>
</li>
<li>接到主机的系统总线上</li>
<li>硬件、软件和固件的综合 体</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./042cf754ea8412de4569889e49f8cbf9.png"
        data-srcset="./042cf754ea8412de4569889e49f8cbf9.png, ./042cf754ea8412de4569889e49f8cbf9.png 1.5x, ./042cf754ea8412de4569889e49f8cbf9.png 2x"
        data-sizes="auto"
        alt="./042cf754ea8412de4569889e49f8cbf9.png"
        title="image-20211002224550874" /></p>
<h4 id="3913-适配器通信">39.1.3 适配器通信</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a26f88424260c22a4dcdf51bc3863815.png"
        data-srcset="./a26f88424260c22a4dcdf51bc3863815.png, ./a26f88424260c22a4dcdf51bc3863815.png 1.5x, ./a26f88424260c22a4dcdf51bc3863815.png 2x"
        data-sizes="auto"
        alt="./a26f88424260c22a4dcdf51bc3863815.png"
        title="image-20211002224607535" /></p>
<ul>
<li>发送方:
<ul>
<li>在帧中封装数据报</li>
<li>加上差错控制编码，实现 RDT 和流量控制功能等</li>
</ul>
</li>
<li>接收方：
<ul>
<li>检查有无出错，执行 rdt 和流量控制功能等</li>
<li>解封装数据报，将至交 给上层</li>
</ul>
</li>
</ul>
<h2 id="40-差错检测和纠正">40 差错检测和纠正</h2>
<h3 id="401-错误检测">40.1 错误检测</h3>
<p>EDC=差错检测和纠正位(冗余位)</p>
<p>D =数据由差错检测保护，可以包含头部字段错误检测不是 100%可靠的!</p>
<p>错误检测不是 100%可靠的!</p>
<ul>
<li>协议会漏检一些错误，但是很少</li>
<li>更长的 EDC 字段可以得到更好的检测和纠正效果</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./334352b895b4383c3b9d0caa6a5713e7.png"
        data-srcset="./334352b895b4383c3b9d0caa6a5713e7.png, ./334352b895b4383c3b9d0caa6a5713e7.png 1.5x, ./334352b895b4383c3b9d0caa6a5713e7.png 2x"
        data-sizes="auto"
        alt="./334352b895b4383c3b9d0caa6a5713e7.png"
        title="image-20211002224745844" /></p>
<h3 id="402-奇偶校验">40.2 奇偶校验</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b67bc76b46222514adb65ef2dfe76ba3.png"
        data-srcset="./b67bc76b46222514adb65ef2dfe76ba3.png, ./b67bc76b46222514adb65ef2dfe76ba3.png 1.5x, ./b67bc76b46222514adb65ef2dfe76ba3.png 2x"
        data-sizes="auto"
        alt="./b67bc76b46222514adb65ef2dfe76ba3.png"
        title="image-20211002224811357" /></p>
<h3 id="403-internet-校验和">40.3 Internet 校验和</h3>
<p>目标: 检测在传输报文段时的错误(如位翻转)，(注：仅仅用在传输层)</p>
<ul>
<li>
<p>发送方:</p>
<ul>
<li>将报文段看成 16-bit 整 数</li>
<li>报文段的校验和: 和 (1’ 的补码和)</li>
<li>发送方将 checksum 的 值放在‘UDP 校验和’ 字段</li>
</ul>
</li>
<li>
<p>接收方:</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查是否与携带校验和字 段值一致:
<ul>
<li>不一致：检出错误</li>
<li>一致：没有检出错误，但可能还是有错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有更简单的检查方法 全部加起来看是不是全 1</p>
<h3 id="404-检验和crc循环冗余校验">40.4 检验和：CRC(循环冗余校验)</h3>
<p>1、模二运算 —— 异或运算</p>
<p>2、位串的两种表示</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0efb7063e946759d3ffa898ebdfe33d6.png"
        data-srcset="./0efb7063e946759d3ffa898ebdfe33d6.png, ./0efb7063e946759d3ffa898ebdfe33d6.png 1.5x, ./0efb7063e946759d3ffa898ebdfe33d6.png 2x"
        data-sizes="auto"
        alt="./0efb7063e946759d3ffa898ebdfe33d6.png"
        title="image-20211002225934163" /></p>
<p>3、生成多项式，r 次方</p>
<p><strong>G = X^3 + 1 r + 1 位</strong> 例子：1001</p>
<p>4、发送方:根据 r 位 CRC 计算 r 位冗余位，使得</p>
<ul>
<li>正好被 G 整除 (modulo 2)</li>
<li>接收方知道 G, 将除以 G. 如果非 0 余数: 检查出错误!</li>
<li>能检出所有少于 r+1 位的突发错误</li>
</ul>
<p><strong>D ——发送的数据 (左移 r 位)+ R —— 冗余位 (r 位)</strong></p>
<p><strong>G —— 生成多项式(r - 1 次方)</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./61ea9d23fdf0a9a7e32dc47738a0bde8.png"
        data-srcset="./61ea9d23fdf0a9a7e32dc47738a0bde8.png, ./61ea9d23fdf0a9a7e32dc47738a0bde8.png 1.5x, ./61ea9d23fdf0a9a7e32dc47738a0bde8.png 2x"
        data-sizes="auto"
        alt="./61ea9d23fdf0a9a7e32dc47738a0bde8.png"
        title="image-20211002230457145" /></p>
<ul>
<li>强大的差错检测码</li>
<li>将数据比特 D, 看成是二进制的数据</li>
<li>生成多项式 G：双方协商 r+1 位模式(r 次方)
<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li>目标:选择 r 位 CRC 附加位 R，使得
<ul>
<li>正好被 G 整除 (modulo 2)</li>
<li>接收方知道 G, 将 除以 G. 如果非 0 余数: 检查出错误!</li>
<li>能检出所有少于 r+1 位的突发错误</li>
</ul>
</li>
<li>实际中广泛使用(以太网、802.11 WiFi、ATM)</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5ec5fc5ec113352de6ca86f0ad63f505.png"
        data-srcset="./5ec5fc5ec113352de6ca86f0ad63f505.png, ./5ec5fc5ec113352de6ca86f0ad63f505.png 1.5x, ./5ec5fc5ec113352de6ca86f0ad63f505.png 2x"
        data-sizes="auto"
        alt="./5ec5fc5ec113352de6ca86f0ad63f505.png"
        title="image-20211002225357330" /></p>
<h3 id="405-crc-例子">40.5 CRC 例子</h3>
<ul>
<li>需要: D.2r <strong>XOR</strong> R = nG</li>
<li>等价于: D.2r = nG <strong>XOR</strong> R</li>
<li>等价于: 两边同除 G 得到余数 R=… <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./944b3394ae5eb43e6580dbdb8191c6c5.png"
        data-srcset="./944b3394ae5eb43e6580dbdb8191c6c5.png, ./944b3394ae5eb43e6580dbdb8191c6c5.png 1.5x, ./944b3394ae5eb43e6580dbdb8191c6c5.png 2x"
        data-sizes="auto"
        alt="./944b3394ae5eb43e6580dbdb8191c6c5.png"
        title="image-20211002230905492" /></li>
</ul>
<p>remainder —— 余数 、当余数 R 不足 r 位，补 0</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./563fd86566e9cb9c37ba1a215715c618.png"
        data-srcset="./563fd86566e9cb9c37ba1a215715c618.png, ./563fd86566e9cb9c37ba1a215715c618.png 1.5x, ./563fd86566e9cb9c37ba1a215715c618.png 2x"
        data-sizes="auto"
        alt="./563fd86566e9cb9c37ba1a215715c618.png"
        title="image-20211002230858718" /></p>
<h3 id="406-crc-性能分析">40.6 CRC 性能分析</h3>
<ul>
<li>突发错误和突发长度</li>
<li>CRC 检错性能描述
<ul>
<li><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./eb60e911598562e3c7317eaf299ca74b.png"
        data-srcset="./eb60e911598562e3c7317eaf299ca74b.png, ./eb60e911598562e3c7317eaf299ca74b.png 1.5x, ./eb60e911598562e3c7317eaf299ca74b.png 2x"
        data-sizes="auto"
        alt="./eb60e911598562e3c7317eaf299ca74b.png"
        title="image-20211002231306540" /></li>
</ul>
</li>
</ul>
<h2 id="41-多点访问协议">41 多点访问协议</h2>
<h3 id="411-多路访问链路和协议">41.1 多路访问链路和协议</h3>
<p>两种类型的链路(一个子网内部链路连接形式)：</p>
<ul>
<li>点对点
<ul>
<li>拨号访问的 PPP</li>
<li>以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li>广播 (共享线路或媒体)
<ul>
<li>传统以太网</li>
<li>HFC 上行链路</li>
<li>802.11 无线局域网</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e9341bbe454afde37448da48cc933593.png"
        data-srcset="./e9341bbe454afde37448da48cc933593.png, ./e9341bbe454afde37448da48cc933593.png 1.5x, ./e9341bbe454afde37448da48cc933593.png 2x"
        data-sizes="auto"
        alt="./e9341bbe454afde37448da48cc933593.png"
        title="image-20211002231421347" /></p>
<h3 id="412-多路访问协议">41.2 多路访问协议</h3>
<ul>
<li>单个共享的广播型链路</li>
<li>2 个或更多站点同时传送: 冲突(collision)
<ul>
<li>多个节点在同一个时刻发送，则会收到 2 个或多个信号 叠加</li>
</ul>
</li>
</ul>
<p><strong>多路访问协议(介质访问控制协议：MAC)</strong></p>
<ul>
<li><strong>分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送？</strong></li>
<li>关于共享控制的通信必须用借助信道本身传输！
<ul>
<li>没有带外的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
<h3 id="413-理想的多路访问协议">41.3 理想的多路访问协议</h3>
<ul>
<li>给定：Rbps 带宽的广播信道</li>
</ul>
<p>必要条件：</p>
<ol>
<li>
<p>当一个节点要发送时，可以<strong>以 R 速率发送</strong>.</p>
</li>
<li>
<p>当 M 个节点要发送，每个可以<strong>以 R/M 的平均速率</strong>发送</p>
</li>
<li>
<p>完全分布的:</p>
<ol>
<li><strong>没有特殊节点协调发送</strong></li>
<li><strong>没有时钟和时隙的同步</strong></li>
</ol>
</li>
<li>
<p>简单</p>
</li>
</ol>
<h3 id="414-mac媒体访问控制协议分类">41.4 MAC(媒体访问控制)协议：分类</h3>
<p>3 大类</p>
<ul>
<li><strong>信道划分</strong>
o 把信道划分成小片(时间、频率、编码)
o 分配片给每个节点专用</li>
<li><strong>随机访问</strong>
o 信道不划分，允许冲突
○ 冲突后恢复</li>
<li><strong>依次轮流</strong>
o 节点依次轮流
○ 但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
<h4 id="4141-a信道划分-mac-协议tdma-时分复用">41.4.1 a.信道划分 MAC 协议：TDMA 时分复用</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ebe2668cb8c90a8abc574c46725bfc0a.png"
        data-srcset="./ebe2668cb8c90a8abc574c46725bfc0a.png, ./ebe2668cb8c90a8abc574c46725bfc0a.png 1.5x, ./ebe2668cb8c90a8abc574c46725bfc0a.png 2x"
        data-sizes="auto"
        alt="./ebe2668cb8c90a8abc574c46725bfc0a.png"
        title="image-20211003010402398" /></p>
<h4 id="4142-a信道划分-mac-协议fdma-频分复用">41.4.2 a.信道划分 MAC 协议：FDMA 频分复用</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1d0ecbbfb801140b007d336ee0d1f88e.png"
        data-srcset="./1d0ecbbfb801140b007d336ee0d1f88e.png, ./1d0ecbbfb801140b007d336ee0d1f88e.png 1.5x, ./1d0ecbbfb801140b007d336ee0d1f88e.png 2x"
        data-sizes="auto"
        alt="./1d0ecbbfb801140b007d336ee0d1f88e.png"
        title="image-20211003010449653" /></p>
<h4 id="4143-a码分多路访问cdma">41.4.3 a.码分多路访问(CDMA)</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./bf6d799fea17df99394124ec948406de.png"
        data-srcset="./bf6d799fea17df99394124ec948406de.png, ./bf6d799fea17df99394124ec948406de.png 1.5x, ./bf6d799fea17df99394124ec948406de.png 2x"
        data-sizes="auto"
        alt="./bf6d799fea17df99394124ec948406de.png"
        title="image-20211003010510131" /></p>
<h4 id="4144-b随机存取协议">41.4.4 b.随机存取协议</h4>
<p>检错冲突 与 冲突解决/冲突避免</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6bc63978f9ed72883d50ce6a8997a575.png"
        data-srcset="./6bc63978f9ed72883d50ce6a8997a575.png, ./6bc63978f9ed72883d50ce6a8997a575.png 1.5x, ./6bc63978f9ed72883d50ce6a8997a575.png 2x"
        data-sizes="auto"
        alt="./6bc63978f9ed72883d50ce6a8997a575.png"
        title="image-20211003010538701" /></p>
<h4 id="4145-b1-时隙-aloha">41.4.5 b.1 时隙 ALOHA</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e467fc2e3bdd3c1c6a05a04a660ae27e.png"
        data-srcset="./e467fc2e3bdd3c1c6a05a04a660ae27e.png, ./e467fc2e3bdd3c1c6a05a04a660ae27e.png 1.5x, ./e467fc2e3bdd3c1c6a05a04a660ae27e.png 2x"
        data-sizes="auto"
        alt="./e467fc2e3bdd3c1c6a05a04a660ae27e.png"
        title="image-20211003010613208" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./fb02034af6f6944c5fe0623222045d9a.png"
        data-srcset="./fb02034af6f6944c5fe0623222045d9a.png, ./fb02034af6f6944c5fe0623222045d9a.png 1.5x, ./fb02034af6f6944c5fe0623222045d9a.png 2x"
        data-sizes="auto"
        alt="./fb02034af6f6944c5fe0623222045d9a.png"
        title="image-20211003010707726" /></p>
<p>时隙 ALOHA 的效率( Efficiency )</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./012e476deac0121523227fcb725fbb95.png"
        data-srcset="./012e476deac0121523227fcb725fbb95.png, ./012e476deac0121523227fcb725fbb95.png 1.5x, ./012e476deac0121523227fcb725fbb95.png 2x"
        data-sizes="auto"
        alt="./012e476deac0121523227fcb725fbb95.png"
        title="image-20211003010722429" /></p>
<h4 id="4146-b2-纯-aloha非时隙">41.4.6 b.2 纯 ALOHA(非时隙)</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b39c4939d32a32e1475d423fe2dcb2ff.png"
        data-srcset="./b39c4939d32a32e1475d423fe2dcb2ff.png, ./b39c4939d32a32e1475d423fe2dcb2ff.png 1.5x, ./b39c4939d32a32e1475d423fe2dcb2ff.png 2x"
        data-sizes="auto"
        alt="./b39c4939d32a32e1475d423fe2dcb2ff.png"
        title="image-20211003010738468" /></p>
<p>纯 ALOHA 的效率</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c6d214b58a8a61930e9d4fec7920eb9b.png"
        data-srcset="./c6d214b58a8a61930e9d4fec7920eb9b.png, ./c6d214b58a8a61930e9d4fec7920eb9b.png 1.5x, ./c6d214b58a8a61930e9d4fec7920eb9b.png 2x"
        data-sizes="auto"
        alt="./c6d214b58a8a61930e9d4fec7920eb9b.png"
        title="image-20211003010753389" /></p>
<h4 id="4147-b3-csma载波侦听多路访问">41.4.7 b.3 CSMA(载波侦听多路访问)</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./01f2a34187983ec9527718dac7995c8b.png"
        data-srcset="./01f2a34187983ec9527718dac7995c8b.png, ./01f2a34187983ec9527718dac7995c8b.png 1.5x, ./01f2a34187983ec9527718dac7995c8b.png 2x"
        data-sizes="auto"
        alt="./01f2a34187983ec9527718dac7995c8b.png"
        title="image-20211003010815762" /></p>
<p>CSMA 冲突</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./83845d586946c29c165ddad710428bad.png"
        data-srcset="./83845d586946c29c165ddad710428bad.png, ./83845d586946c29c165ddad710428bad.png 1.5x, ./83845d586946c29c165ddad710428bad.png 2x"
        data-sizes="auto"
        alt="./83845d586946c29c165ddad710428bad.png"
        title="image-20211003010833065" /></p>
<h4 id="4148-b4-csmacd冲突检测">41.4.8 b.4 CSMA/CD(冲突检测)</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./aa6ac3a830beee1ba33415e3e6c08854.png"
        data-srcset="./aa6ac3a830beee1ba33415e3e6c08854.png, ./aa6ac3a830beee1ba33415e3e6c08854.png 1.5x, ./aa6ac3a830beee1ba33415e3e6c08854.png 2x"
        data-sizes="auto"
        alt="./aa6ac3a830beee1ba33415e3e6c08854.png"
        title="image-20211003010844252" /></p>
<p>CSMA/CD(冲突检测)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./85a6b5c6ae2a8afaf338023c63bd2581.png"
        data-srcset="./85a6b5c6ae2a8afaf338023c63bd2581.png, ./85a6b5c6ae2a8afaf338023c63bd2581.png 1.5x, ./85a6b5c6ae2a8afaf338023c63bd2581.png 2x"
        data-sizes="auto"
        alt="./85a6b5c6ae2a8afaf338023c63bd2581.png"
        title="image-20211003010859719" /></p>
<p>以太网 CSMA/CD 算法</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./92b80487f91d9803bad2eb6c415c6eea.png"
        data-srcset="./92b80487f91d9803bad2eb6c415c6eea.png, ./92b80487f91d9803bad2eb6c415c6eea.png 1.5x, ./92b80487f91d9803bad2eb6c415c6eea.png 2x"
        data-sizes="auto"
        alt="./92b80487f91d9803bad2eb6c415c6eea.png"
        title="image-20211003010933464" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c1d5e474e2d61675f17a5216c22670d8.png"
        data-srcset="./c1d5e474e2d61675f17a5216c22670d8.png, ./c1d5e474e2d61675f17a5216c22670d8.png 1.5x, ./c1d5e474e2d61675f17a5216c22670d8.png 2x"
        data-sizes="auto"
        alt="./c1d5e474e2d61675f17a5216c22670d8.png"
        title="image-20211003010941312" /></p>
<p>CSMA/CD 效率</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./27714fdf2691f87d8547a04372b33d0a.png"
        data-srcset="./27714fdf2691f87d8547a04372b33d0a.png, ./27714fdf2691f87d8547a04372b33d0a.png 1.5x, ./27714fdf2691f87d8547a04372b33d0a.png 2x"
        data-sizes="auto"
        alt="./27714fdf2691f87d8547a04372b33d0a.png"
        title="image-20211003010953336" /></p>
<h4 id="4149-b5-无线局域网-csmaca">41.4.9 b.5 无线局域网 CSMA/CA</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./aba76ceba0b4c3f8e4ff16d8f66cee2a.png"
        data-srcset="./aba76ceba0b4c3f8e4ff16d8f66cee2a.png, ./aba76ceba0b4c3f8e4ff16d8f66cee2a.png 1.5x, ./aba76ceba0b4c3f8e4ff16d8f66cee2a.png 2x"
        data-sizes="auto"
        alt="./aba76ceba0b4c3f8e4ff16d8f66cee2a.png"
        title="image-20211003011006144" /></p>
<p>无线局域网中的 MAC：CSMA/CA</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./dfb03b05cab4f37e658caa62505b3548.png"
        data-srcset="./dfb03b05cab4f37e658caa62505b3548.png, ./dfb03b05cab4f37e658caa62505b3548.png 1.5x, ./dfb03b05cab4f37e658caa62505b3548.png 2x"
        data-sizes="auto"
        alt="./dfb03b05cab4f37e658caa62505b3548.png"
        title="image-20211003011019740" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./add3ee59a08ff66d310f9c13442d8675.png"
        data-srcset="./add3ee59a08ff66d310f9c13442d8675.png, ./add3ee59a08ff66d310f9c13442d8675.png 1.5x, ./add3ee59a08ff66d310f9c13442d8675.png 2x"
        data-sizes="auto"
        alt="./add3ee59a08ff66d310f9c13442d8675.png"
        title="image-20211003011031282" /></p>
<p>冲突避免(续)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9a3630c9a7b8777defde36d4136fe815.png"
        data-srcset="./9a3630c9a7b8777defde36d4136fe815.png, ./9a3630c9a7b8777defde36d4136fe815.png 1.5x, ./9a3630c9a7b8777defde36d4136fe815.png 2x"
        data-sizes="auto"
        alt="./9a3630c9a7b8777defde36d4136fe815.png"
        title="image-20211003011105533" /></p>
<p>冲突避免：RTS-CTS 交换</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5437f214e7b2d6e7a96dc3755a0699b0.png"
        data-srcset="./5437f214e7b2d6e7a96dc3755a0699b0.png, ./5437f214e7b2d6e7a96dc3755a0699b0.png 1.5x, ./5437f214e7b2d6e7a96dc3755a0699b0.png 2x"
        data-sizes="auto"
        alt="./5437f214e7b2d6e7a96dc3755a0699b0.png"
        title="image-20211003011156385" /></p>
<h4 id="41410-b5-线缆接入网络">41.4.10 b.5 线缆接入网络</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./eb81bcf9f6d38e6bd58736ef20270de7.png"
        data-srcset="./eb81bcf9f6d38e6bd58736ef20270de7.png, ./eb81bcf9f6d38e6bd58736ef20270de7.png 1.5x, ./eb81bcf9f6d38e6bd58736ef20270de7.png 2x"
        data-sizes="auto"
        alt="./eb81bcf9f6d38e6bd58736ef20270de7.png"
        title="image-20211003011225369" /></p>
<h4 id="41411-c轮流taking-turnsmac-协议">41.4.11 c.轮流(Taking Turns)MAC 协议</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./20d95cb13c216c5499f9168c54a65170.png"
        data-srcset="./20d95cb13c216c5499f9168c54a65170.png, ./20d95cb13c216c5499f9168c54a65170.png 1.5x, ./20d95cb13c216c5499f9168c54a65170.png 2x"
        data-sizes="auto"
        alt="./20d95cb13c216c5499f9168c54a65170.png"
        title="image-20211003011240667" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e62c6a921ae5785095a101f5f64f61b0.png"
        data-srcset="./e62c6a921ae5785095a101f5f64f61b0.png, ./e62c6a921ae5785095a101f5f64f61b0.png 1.5x, ./e62c6a921ae5785095a101f5f64f61b0.png 2x"
        data-sizes="auto"
        alt="./e62c6a921ae5785095a101f5f64f61b0.png"
        title="image-20211003011248967" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f649946b59c9788e534d061ef4c07541.png"
        data-srcset="./f649946b59c9788e534d061ef4c07541.png, ./f649946b59c9788e534d061ef4c07541.png 1.5x, ./f649946b59c9788e534d061ef4c07541.png 2x"
        data-sizes="auto"
        alt="./f649946b59c9788e534d061ef4c07541.png"
        title="image-20211003011256683" /></p>
<h3 id="415-mac-协议总结">41.5 MAC 协议总结</h3>
<p>多点接入问题：对于一个共享型介质，各个节点 如何协调对它的访问和使用?</p>
<ul>
<li>信道划分：按时间、频率或者编码
<ul>
<li>TDMA、FDMA、CDMA</li>
</ul>
</li>
<li>随机访问 (动态)
<ul>
<li>ALOHA, S-ALOHA, CSMA, CSMA/CD</li>
<li>载波侦听: 在有些介质上很容易 (wire：有线介质), 但在有些 介质上比较困难 (wireless：无线)</li>
<li>CSMA/CD ：802.3 Ethernet 网中使用</li>
<li>CSMA/CA ：802.11WLAN 中使用</li>
</ul>
</li>
<li>依次轮流协议
<ul>
<li><strong>集中：由一个中心节点轮询；</strong>
<strong>分布：通过令牌控制</strong></li>
<li>蓝牙、FDDI、令牌环</li>
</ul>
</li>
</ul>
<h2 id="42-lans">42 LANs</h2>
<p>addressing, ARP</p>
<h3 id="421-mac-地址和-arp">42.1 MAC 地址和 ARP</h3>
<ul>
<li>32bit IP 地址:
<ul>
<li>网络层地址</li>
<li>前 n-1 跳：用于使数据报到达目的 IP 子网</li>
<li>最后一跳：到达子网中的目标节点</li>
</ul>
</li>
<li>LAN(MAC/物理/以太网)地址: —— (在一个物理网络的内部来标识每一个节点)
<ul>
<li><strong>用于使帧从一个网卡传递到与其物理连接的另一个网卡 (在同一个物理网络中)</strong></li>
<li><strong>48bit MAC 地址固化在适配器的 ROM，有时也可以通过软件设定</strong></li>
<li><strong>理论上全球任何 2 个网卡的 MAC 地址都不相同</strong></li>
<li>e.g.: 1A-2F-BB-76-09-AD —— ( 16 进制表示 (每一位代表 4 个 bits) )</li>
</ul>
</li>
</ul>
<h4 id="4211-网络地址和-mac-地址分离">42.1.1 网络地址和 mac 地址分离</h4>
<ul>
<li>
<p>IP 地址和 MAC 地址的作用不同
a) <strong>IP 地址是分层的</strong> —— 二层</p>
<ul>
<li><strong>一个子网所有站点网络号一致，路由聚集，减少路由表</strong>
<ul>
<li>需要一个网络中的站点地址网络号一致，如果捆绑需要定制网卡非常麻烦</li>
</ul>
</li>
<li><strong>希望网络层地址是配置的；IP 地址完成网络到网络的交付</strong></li>
</ul>
<p>b) <strong>mac 地址是一个平面的</strong></p>
<ul>
<li>网<strong>卡在生产时不知道被用于哪个网络，因此给网卡一个 唯一的标示，用于区分一个网络内部不同的网卡即可</strong></li>
<li><strong>可以完成一个物理网络内部的节点到节点的数据交付</strong></li>
</ul>
</li>
</ul>
<p>从 IP 的角度，是从一个路由器到另一个路由器。
从 链路层的角度，是从一个网卡当另一个网卡。</p>
<ol>
<li>
<p>分离好处
a) <strong>网卡坏了，ip 不变，可以捆绑到另外一个网卡的 mac 上</strong>
b) <strong>物理网络还可以除 IP 之外支持其他网络层协议， 链路协议为任意上层网络协议， 如 IPX 等</strong></p>
</li>
<li>
<p>捆绑的问题
a) 如果仅仅使用 IP 地址，不用 mac 地址，那么它仅支持 IP 协议
b) 每次上电都要重新写入网卡 IP 地址；
c) 另外一个选择就是不使用任何地址；不用 MAC 地址，则每到来一个帧都要上传到 IP 层次，由它判断是不是需要接受，干扰一次</p>
</li>
</ol>
<h4 id="4212-lan-地址和-arp">42.1.2 LAN 地址和 ARP</h4>
<p>局域网上每个适配器都有一个唯一的 LAN 地址</p>
<p>全 F 的 MAX 地址 是 广播地址</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5f62eb5cb849097a5acd6e4ff1f66d36.png"
        data-srcset="./5f62eb5cb849097a5acd6e4ff1f66d36.png, ./5f62eb5cb849097a5acd6e4ff1f66d36.png 1.5x, ./5f62eb5cb849097a5acd6e4ff1f66d36.png 2x"
        data-sizes="auto"
        alt="./5f62eb5cb849097a5acd6e4ff1f66d36.png"
        title="image-20211003091929111" /></p>
<ul>
<li>MAC 地址由 IEEE 管理和分配</li>
<li>制造商购入 MAC 地址空间(保证唯一性)</li>
<li>类比:
(a)MAC 地址：社会安全号
(b)IP 地址：通讯地址  MAC 平面地址 ➜ 支持移动</li>
<li>可以将网卡到接到其它网络  IP 地址有层次-不能移动
<ul>
<li>依赖于节点连接的 IP 子网，与子网的网络号相同( 有与其相连的子网相同的网络前缀)</li>
</ul>
</li>
</ul>
<h4 id="4213-arp-address-resolution-protocol">42.1.3 ARP: Address Resolution Protocol</h4>
<p>问题:已知 B 的 IP 地址，如何确定 B 的 MAC 地址?</p>
<ul>
<li>在 LAN 上的每个 IP 节点都有<strong>一个 ARP 表</strong></li>
<li><strong>ARP 表：包括一些 LAN 节点 IP/MAC 地 址的映射 &lt; IP address; MAC address; TTL&gt;</strong>
<ul>
<li>TTL 时间是指地址映射失效的时间</li>
<li>典型是 20min</li>
</ul>
</li>
</ul>
<h4 id="4214-arp-协议在同一个-lan-网络">42.1.4 ARP 协议：在同一个 LAN (网络)</h4>
<ul>
<li>A 要发送帧给 B(B 的 IP 地址 已知)， 但 B 的 MAC 地址不 在 A 的 ARP 表中</li>
<li>A 广播包含 B 的 IP 地址的 ARP 查询包
<ul>
<li>Dest MAC address = FF-FF-FF-FF-FF-FF</li>
<li>LAN 上的所有节点都会收到 该查询包</li>
</ul>
</li>
<li>B 接收到 ARP 包，回复 A 自 己的 MAC 地址
<ul>
<li>帧发送给 A</li>
<li>用 A 的 MAC 地址(单播)</li>
</ul>
</li>
<li>A 在自己的 ARP 表中，缓存 IP-to-MAC 地址映射关系 ，直到信息超时
<ul>
<li>软状态: 靠定期刷新维持的系统状态</li>
<li>定期刷新周期之间维护的状态信息可能和原有系统不一 致</li>
</ul>
</li>
<li>ARP 是即插即用的
<ul>
<li>节点自己创建 ARP 的表项</li>
<li>无需网络管理员的干预</li>
</ul>
</li>
</ul>
<h4 id="4215-路由到其他-lan">42.1.5 路由到其他 LAN</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ea96919f77b4355926797af33029d860.png"
        data-srcset="./ea96919f77b4355926797af33029d860.png, ./ea96919f77b4355926797af33029d860.png 1.5x, ./ea96919f77b4355926797af33029d860.png 2x"
        data-sizes="auto"
        alt="./ea96919f77b4355926797af33029d860.png"
        title="image-20211003092755106" /></p>
<h4 id="4216-编址路由到其他-lan">42.1.6 编址：路由到其他 LAN</h4>
<ul>
<li>
<p><strong>A 创建数据报，源 IP 地址：A；目标 IP 地址：B</strong> 封装一层</p>
</li>
<li>
<p><strong>A 创建一个链路层的帧，目标 MAC 地址是 R，该帧包含 A 到 B 的 IP 数据报</strong></p>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./daa44238ac5ba2f212aacb0ce4c29685.png"
        data-srcset="./daa44238ac5ba2f212aacb0ce4c29685.png, ./daa44238ac5ba2f212aacb0ce4c29685.png 1.5x, ./daa44238ac5ba2f212aacb0ce4c29685.png 2x"
        data-sizes="auto"
        alt="./daa44238ac5ba2f212aacb0ce4c29685.png"
        title="image-20211003092846728" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./68d39c490db41e9b33ee6314d53594c2.png"
        data-srcset="./68d39c490db41e9b33ee6314d53594c2.png, ./68d39c490db41e9b33ee6314d53594c2.png 1.5x, ./68d39c490db41e9b33ee6314d53594c2.png 2x"
        data-sizes="auto"
        alt="./68d39c490db41e9b33ee6314d53594c2.png"
        title="image-20211003093159324" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./78e8a28119ed5efa30397842db9f271a.png"
        data-srcset="./78e8a28119ed5efa30397842db9f271a.png, ./78e8a28119ed5efa30397842db9f271a.png 1.5x, ./78e8a28119ed5efa30397842db9f271a.png 2x"
        data-sizes="auto"
        alt="./78e8a28119ed5efa30397842db9f271a.png"
        title="image-20211003093207363" /></p>
<h3 id="422-以太网">42.2 以太网</h3>
<ul>
<li>目前最主流的 LAN 技术：98%占有率</li>
<li>廉价：30 元 RMB 100Mbps！</li>
<li>最早广泛应用的 LAN 技术</li>
<li>比令牌网和 ATM 网络简单、廉价</li>
<li>带宽不断提升：10M, 100M, 1G, 10G</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3626a949d280523ee4d4d393d44bb491.png"
        data-srcset="./3626a949d280523ee4d4d393d44bb491.png, ./3626a949d280523ee4d4d393d44bb491.png 1.5x, ./3626a949d280523ee4d4d393d44bb491.png 2x"
        data-sizes="auto"
        alt="./3626a949d280523ee4d4d393d44bb491.png"
        title="image-20211003093457375" /></p>
<h4 id="4221-以太网物理拓扑">42.2.1 以太网：物理拓扑</h4>
<ul>
<li><strong>总线：在上个世纪 90 年代中期很流行</strong>
<ul>
<li>所有节点在一个碰撞域内，一次只允许一个节点发送</li>
<li><strong>可靠性差，如果介质破损，截面形成信号的反射，发送节点误认为 是冲突，总是冲突</strong></li>
</ul>
</li>
<li><strong>星型：目前最主流</strong>
<ul>
<li><strong>连接选择: hub(无法并行，一发全收) 或者 switch (并行)</strong></li>
<li>现在一般是交换机(switch)在中心</li>
<li><strong>每个节点以及相连的交换机端口使用(独立的)以太网协议(不会和其他节点的发送产生碰撞)</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e9e448d05d5c99349d7a9dbc7f926c11.png"
        data-srcset="./e9e448d05d5c99349d7a9dbc7f926c11.png, ./e9e448d05d5c99349d7a9dbc7f926c11.png 1.5x, ./e9e448d05d5c99349d7a9dbc7f926c11.png 2x"
        data-sizes="auto"
        alt="./e9e448d05d5c99349d7a9dbc7f926c11.png"
        title="image-20211003093613325" /></p>
<h4 id="4222-以太帧结构">42.2.2 以太帧结构</h4>
<p>发送方适配器在以太网帧中封装 IP 数据报， 或其他网络层协议数据单元</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0912b72ff65f84ef295f5be6963985ac.png"
        data-srcset="./0912b72ff65f84ef295f5be6963985ac.png, ./0912b72ff65f84ef295f5be6963985ac.png 1.5x, ./0912b72ff65f84ef295f5be6963985ac.png 2x"
        data-sizes="auto"
        alt="./0912b72ff65f84ef295f5be6963985ac.png"
        title="image-20211003093826481" /></p>
<p>前导码:</p>
<ul>
<li>
<p><strong>7B 10101010 + 1B 10101011</strong></p>
</li>
<li>
<p><strong>用来同步接收方和发送方的时钟速率</strong></p>
<ul>
<li>使得接收方将自己的时钟调到发送端的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul>
</li>
<li>
<p><strong>地址：6 字节源 MAC 地址，目标 MAC 地址</strong></p>
<ul>
<li>如：帧目标地址=本站 MAC 地址，或是广播地址， 接收，递交帧中的数据到网络层</li>
<li>否则，适配器忽略该帧</li>
</ul>
</li>
<li>
<p><strong>类型：指出高层协(大多情况下是 IP，但也支持其它网络层协议 Novell IPX 和 AppleTalk)</strong></p>
</li>
<li>
<p><strong>CRC：在接收方校验</strong></p>
<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
<h4 id="4223-以太网无连接不可靠的服务">42.2.3 以太网：无连接、不可靠的服务</h4>
<ul>
<li><strong>无连接：帧传输前，发送方和接收方之间没有握手</strong></li>
<li><strong>不可靠：接收方适配器不发送 ACKs 或 NAKs 给发送方</strong>
<ul>
<li>递交给网络层的数据报流可能有 gap</li>
<li>如上层使用像传输层 TCP 协议这样的 rdt，gap 会被补上( 源主机，TCP 实体)</li>
<li>否则，应用层就会看到 gap</li>
</ul>
</li>
<li><strong>以太网的 MAC 协议：采用二进制退避的 CSMA/CD 介质访问控制形式</strong></li>
</ul>
<h4 id="4224-以太网标准链路和物理层">42.2.4 以太网标准：链路和物理层</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0f21fce4eebfb5bdd7f63ff8e50aee6b.png"
        data-srcset="./0f21fce4eebfb5bdd7f63ff8e50aee6b.png, ./0f21fce4eebfb5bdd7f63ff8e50aee6b.png 1.5x, ./0f21fce4eebfb5bdd7f63ff8e50aee6b.png 2x"
        data-sizes="auto"
        alt="./0f21fce4eebfb5bdd7f63ff8e50aee6b.png"
        title="image-20211003095719135" /></p>
<h4 id="4225-以太网使用-csmacd">42.2.5 以太网使用 CSMA/CD</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./dcc0c26c7ef477f48b7c6a249d43ac81.png"
        data-srcset="./dcc0c26c7ef477f48b7c6a249d43ac81.png, ./dcc0c26c7ef477f48b7c6a249d43ac81.png 1.5x, ./dcc0c26c7ef477f48b7c6a249d43ac81.png 2x"
        data-sizes="auto"
        alt="./dcc0c26c7ef477f48b7c6a249d43ac81.png"
        title="image-20211003095730238" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5fda0846b2b3b5ff6aeb7eab794d7eb9.png"
        data-srcset="./5fda0846b2b3b5ff6aeb7eab794d7eb9.png, ./5fda0846b2b3b5ff6aeb7eab794d7eb9.png 1.5x, ./5fda0846b2b3b5ff6aeb7eab794d7eb9.png 2x"
        data-sizes="auto"
        alt="./5fda0846b2b3b5ff6aeb7eab794d7eb9.png"
        title="image-20211003095801368" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./658329af1bc70f62d54dba5472c6c58b.png"
        data-srcset="./658329af1bc70f62d54dba5472c6c58b.png, ./658329af1bc70f62d54dba5472c6c58b.png 1.5x, ./658329af1bc70f62d54dba5472c6c58b.png 2x"
        data-sizes="auto"
        alt="./658329af1bc70f62d54dba5472c6c58b.png"
        title="image-20211003095826706" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./017f03d0dc609e1dcd692f8eab8e4f93.png"
        data-srcset="./017f03d0dc609e1dcd692f8eab8e4f93.png, ./017f03d0dc609e1dcd692f8eab8e4f93.png 1.5x, ./017f03d0dc609e1dcd692f8eab8e4f93.png 2x"
        data-sizes="auto"
        alt="./017f03d0dc609e1dcd692f8eab8e4f93.png"
        title="image-20211003095900060" /></p>
<h4 id="4226-baset-and-100baset">42.2.6 BaseT and 100BaseT</h4>
<ul>
<li>100 Mbps 速率 也被称之为 “fast ethernet” Base 基带信号</li>
<li>T 代表双绞线</li>
<li>节点连接到 HUB 上: “star topology”物理上星型
<ul>
<li><strong>逻辑上总线型，盒中总线</strong> 一发全收，一次只能发一次</li>
</ul>
</li>
<li>节点和 HUB 间的最大距离是 100 m</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./537ff39880bab5f26d1bd54812fd5a50.png"
        data-srcset="./537ff39880bab5f26d1bd54812fd5a50.png, ./537ff39880bab5f26d1bd54812fd5a50.png 1.5x, ./537ff39880bab5f26d1bd54812fd5a50.png 2x"
        data-sizes="auto"
        alt="./537ff39880bab5f26d1bd54812fd5a50.png"
        title="image-20211003095952932" /></p>
<h4 id="4227-hubs">42.2.7 Hubs</h4>
<ul>
<li>Hubs 本质上是物理层的中继器:
<ul>
<li>从一个端口收，转发到所有其他端口</li>
<li>速率一致  没有帧的缓存</li>
<li>在 hub 端口上没有 CSMA/CD 机制:适配器检测冲突</li>
<li>提供网络管理功能</li>
</ul>
</li>
</ul>
<h4 id="4228-manchester-编码--物理层">42.2.8 Manchester 编码 —— 物理层</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1ee2a02b02610b686d3fba2daa2071be.png"
        data-srcset="./1ee2a02b02610b686d3fba2daa2071be.png, ./1ee2a02b02610b686d3fba2daa2071be.png 1.5x, ./1ee2a02b02610b686d3fba2daa2071be.png 2x"
        data-sizes="auto"
        alt="./1ee2a02b02610b686d3fba2daa2071be.png"
        title="image-20211003100140814" /></p>
<ul>
<li>在 10BaseT 中使用</li>
<li>每一个 bit 的位时中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步
<ul>
<li>节点间不需要集中的和全局的时钟</li>
</ul>
</li>
<li>10Mbps，使用 20M 带宽，效率 50%</li>
<li>Hey, this is physical-layer stuff!</li>
</ul>
<h4 id="4229-baset-中的-4b5b-编码">42.2.9 BaseT 中的 4b5b 编码</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./eb039062780db59ff60b325f999ba221.png"
        data-srcset="./eb039062780db59ff60b325f999ba221.png, ./eb039062780db59ff60b325f999ba221.png 1.5x, ./eb039062780db59ff60b325f999ba221.png 2x"
        data-sizes="auto"
        alt="./eb039062780db59ff60b325f999ba221.png"
        title="image-20211003102620272" /></p>
<h4 id="42210-千兆以太网">42.2.10 千兆以太网</h4>
<p> 采用标准的以太帧格式
 允许点对点链路和共享广播信道
 物理编码：8b10b 编码
 在共享模式，继续使用 CSMA/CD MAC 技术 ，节点间需要较短距离以提高利用率
 交换模式：全双工千兆可用于点对点链路
 站点使用专用信道，基本不会冲突，效率高
 除非发往同一个目标站点
 10 Gbps now !</p>
<h3 id="423-wlan">42.3 WLAN</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./c0e10a3191cd5ebf60df994428ec3981.png"
        data-srcset="./c0e10a3191cd5ebf60df994428ec3981.png, ./c0e10a3191cd5ebf60df994428ec3981.png 1.5x, ./c0e10a3191cd5ebf60df994428ec3981.png 2x"
        data-sizes="auto"
        alt="./c0e10a3191cd5ebf60df994428ec3981.png"
        title="image-20211003102721615" /></p>
<h4 id="4231-lan-体系结构">42.3.1 LAN 体系结构</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4f17e49d8a92e770f688cb7e83dba91e.png"
        data-srcset="./4f17e49d8a92e770f688cb7e83dba91e.png, ./4f17e49d8a92e770f688cb7e83dba91e.png 1.5x, ./4f17e49d8a92e770f688cb7e83dba91e.png 2x"
        data-sizes="auto"
        alt="./4f17e49d8a92e770f688cb7e83dba91e.png"
        title="image-20211003102741419" /></p>
<h3 id="424-switches">42.4 switches</h3>
<h4 id="4241-hub集线器">42.4.1 Hub：集线器</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./bb6a88d95ee4148373aa8b9453d770cc.png"
        data-srcset="./bb6a88d95ee4148373aa8b9453d770cc.png, ./bb6a88d95ee4148373aa8b9453d770cc.png 1.5x, ./bb6a88d95ee4148373aa8b9453d770cc.png 2x"
        data-sizes="auto"
        alt="./bb6a88d95ee4148373aa8b9453d770cc.png"
        title="image-20211003102803772" /></p>
<h4 id="4242-交换机--路由层面主机是看不到交换机的透明的">42.4.2 交换机 —— 路由层面(主机)是看不到交换机的，透明的</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./15aab5784973cfaafa1fc49650b57158.png"
        data-srcset="./15aab5784973cfaafa1fc49650b57158.png, ./15aab5784973cfaafa1fc49650b57158.png 1.5x, ./15aab5784973cfaafa1fc49650b57158.png 2x"
        data-sizes="auto"
        alt="./15aab5784973cfaafa1fc49650b57158.png"
        title="image-20211003102848810" /></p>
<h4 id="4243-交换机多路同时传输">42.4.3 交换机：多路同时传输</h4>
<ul>
<li><strong>主机有一个专用和直接到交换机的连接</strong></li>
<li><strong>交换机缓存到来的帧</strong></li>
<li><strong>对每个帧进入的链路使用以太网协议，没有碰撞；全双工</strong>
<ul>
<li>每条链路都是一个独立的 碰撞域</li>
<li>MAC 协议在其中的作用弱 化了</li>
</ul>
</li>
<li><strong>交换：A-to-A’ 和 B-to-B’ 可 以同时传输，没有碰撞</strong></li>
</ul>
<h4 id="4244-交换机转发表">42.4.4 交换机转发表</h4>
<ul>
<li>
<p>Q:交换机如何知道通过接口 1 到达 A，通过接口 5 到达 B’?</p>
</li>
<li>
<p>A:每个交换机都有一个交换表 switch table，每个表项:</p>
<p><strong>(主机的 MAC 地址,到达该 MAC 经过的接口，时戳)</strong>
<strong>比较像路由表!</strong></p>
</li>
<li>
<p>Q: 每个表项是如何创建的？如何维护的？</p>
<p><strong>有点像路由协议?</strong></p>
</li>
</ul>
<h4 id="4245-交换机自学习">42.4.5 交换机：自学习</h4>
<ul>
<li>
<p>交换机通过学习得到哪些 主机(mac 地址)可以通 过哪些端口到达</p>
<ul>
<li><strong>当接收到帧，交换机 学习到发送站点所在 的端口(网段)</strong></li>
<li><strong>记录发送方 MAC 地址/ 进入端口映射关系， 在交换表中</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./8fd3478b2b352645f4e6e87111d5eff8.png"
        data-srcset="./8fd3478b2b352645f4e6e87111d5eff8.png, ./8fd3478b2b352645f4e6e87111d5eff8.png 1.5x, ./8fd3478b2b352645f4e6e87111d5eff8.png 2x"
        data-sizes="auto"
        alt="./8fd3478b2b352645f4e6e87111d5eff8.png"
        title="image-20211003104905022" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a01928f70a4715258735ff5decaa9ff1.png"
        data-srcset="./a01928f70a4715258735ff5decaa9ff1.png, ./a01928f70a4715258735ff5decaa9ff1.png 1.5x, ./a01928f70a4715258735ff5decaa9ff1.png 2x"
        data-sizes="auto"
        alt="./a01928f70a4715258735ff5decaa9ff1.png"
        title="image-20211003104914637" /></p>
</li>
</ul>
<h4 id="4246-交换机过滤转发">42.4.6 交换机：过滤／转发</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e6808bd00f4b9436a2c5b0ecd95f9dd2.png"
        data-srcset="./e6808bd00f4b9436a2c5b0ecd95f9dd2.png, ./e6808bd00f4b9436a2c5b0ecd95f9dd2.png 1.5x, ./e6808bd00f4b9436a2c5b0ecd95f9dd2.png 2x"
        data-sizes="auto"
        alt="./e6808bd00f4b9436a2c5b0ecd95f9dd2.png"
        title="image-20211003103245720" /></p>
<h4 id="4247-自学习转发的例子--不知道泛洪">42.4.7 自学习，转发的例子 —— 不知道，泛洪</h4>
<p>帧的目标： A’, 不知道 其位置在哪：泛洪 A’ A</p>
<ul>
<li>知道目标 A 对应的链路 ： A’ 4 60 选择性发送到那个端 口</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7bd50041c4f1287820a0249cca84114d.png"
        data-srcset="./7bd50041c4f1287820a0249cca84114d.png, ./7bd50041c4f1287820a0249cca84114d.png 1.5x, ./7bd50041c4f1287820a0249cca84114d.png 2x"
        data-sizes="auto"
        alt="./7bd50041c4f1287820a0249cca84114d.png"
        title="image-20211003105023894" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./79dead42fa17b803105dc8d33850b830.png"
        data-srcset="./79dead42fa17b803105dc8d33850b830.png, ./79dead42fa17b803105dc8d33850b830.png 1.5x, ./79dead42fa17b803105dc8d33850b830.png 2x"
        data-sizes="auto"
        alt="./79dead42fa17b803105dc8d33850b830.png"
        title="image-20211003105040787" /></p>
<h4 id="4248-交换机级联">42.4.8 交换机级联</h4>
<p>交换机可被级联到一起</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f985eb8ed700214002102bb1323d73d9.png"
        data-srcset="./f985eb8ed700214002102bb1323d73d9.png, ./f985eb8ed700214002102bb1323d73d9.png 1.5x, ./f985eb8ed700214002102bb1323d73d9.png 2x"
        data-sizes="auto"
        alt="./f985eb8ed700214002102bb1323d73d9.png"
        title="image-20211003105117255" /></p>
<p>Q: A to G 的发送 – 交换机 S1 如何知道经过从 S4 和 S3 最终达到 F?
 A: 自学习! (和在一个交换机联接所有站点一 样!)</p>
<h4 id="4249-多交换机自学习的例子">42.4.9 多交换机自学习的例子</h4>
<p>假设 C 向 I 发送帧，I 给 C 应答</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./81f98acf3b4c8997a74878b19d8f1e7e.png"
        data-srcset="./81f98acf3b4c8997a74878b19d8f1e7e.png, ./81f98acf3b4c8997a74878b19d8f1e7e.png 1.5x, ./81f98acf3b4c8997a74878b19d8f1e7e.png 2x"
        data-sizes="auto"
        alt="./81f98acf3b4c8997a74878b19d8f1e7e.png"
        title="image-20211003105129108" /></p>
<p> Q: 显示交换表和帧在 S1 , S2 , S3 , S4 的转发</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./de8a43a4ce817981b87e7c5152f1937a.png"
        data-srcset="./de8a43a4ce817981b87e7c5152f1937a.png, ./de8a43a4ce817981b87e7c5152f1937a.png 1.5x, ./de8a43a4ce817981b87e7c5152f1937a.png 2x"
        data-sizes="auto"
        alt="./de8a43a4ce817981b87e7c5152f1937a.png"
        title="image-20211003105230290" /></p>
<h3 id="425-交换机-vs-路由器">42.5 交换机 vs. 路由器</h3>
<ul>
<li>都是存储转发设备，但层次不同
<ul>
<li>交换机：链路层设备(检查 链路层头部)</li>
<li>路由器：网络层设备(检查 网络层的头部)</li>
</ul>
</li>
<li>都有转发表：
<ul>
<li>交换机：<strong>维护交换表，按照 MAC 地址转发</strong>
<ul>
<li>执行过滤、自学习和生成树算法</li>
<li><strong>即插即用；二层设备，速率高</strong></li>
<li>执行生成树算法，限制广播帧的 转发</li>
<li><strong>ARP 表项随着站点数量增多而增多</strong></li>
</ul>
</li>
<li>路由器：续</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./e5ee7c0f99a846241cfe257d0860f536.png"
        data-srcset="./e5ee7c0f99a846241cfe257d0860f536.png, ./e5ee7c0f99a846241cfe257d0860f536.png 1.5x, ./e5ee7c0f99a846241cfe257d0860f536.png 2x"
        data-sizes="auto"
        alt="./e5ee7c0f99a846241cfe257d0860f536.png"
        title="image-20211003105503237" /></p>
<ul>
<li>路由器维护路由表，执行路由算法
<ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li>
<li>对广播分组做限制</li>
<li><strong>不是即插即用的，配置网络地址(子网前缀)</strong></li>
<li><strong>三层设备，速率低</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./29bce7f8c49476a34dc62af96ce55e53.png"
        data-srcset="./29bce7f8c49476a34dc62af96ce55e53.png, ./29bce7f8c49476a34dc62af96ce55e53.png 1.5x, ./29bce7f8c49476a34dc62af96ce55e53.png 2x"
        data-sizes="auto"
        alt="./29bce7f8c49476a34dc62af96ce55e53.png"
        title="image-20211003105603439" /></p>
<h3 id="426-vlans-虚拟局域网">42.6 VLANS 虚拟局域网</h3>
<h4 id="4261-vlans-动机">42.6.1 VLANs: 动机</h4>
<p>考虑场景：</p>
<ul>
<li>CS 用户搬到 EE 大楼办公室 ，但是希望连接到 CS 的交 换机?</li>
<li>接到多个交换机上
<ul>
<li>麻烦和浪费：96 端口 /10 个有用</li>
</ul>
</li>
<li>如果都接到一个交换机上 ，在一个广播域
<ul>
<li>所有的层 2 广播流量 (ARP, DHCP,不知道 MAC 地址对应端口的帧 )都必须穿过整个 LAN</li>
<li>安全性/私密性的问题</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./dad8a9cc772113918c8e85a86c46482d.png"
        data-srcset="./dad8a9cc772113918c8e85a86c46482d.png, ./dad8a9cc772113918c8e85a86c46482d.png 1.5x, ./dad8a9cc772113918c8e85a86c46482d.png 2x"
        data-sizes="auto"
        alt="./dad8a9cc772113918c8e85a86c46482d.png"
        title="image-20211003105820232" /></p>
<h4 id="4262-基于端口的-vlan--一些端口mac-地址-通过虚拟交换机连在一起">42.6.2 基于端口的 VLAN —— 一些端口/mac 地址 通过虚拟交换机连在一起</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./79f2c0541213829c0270a4f9f3de703b.png"
        data-srcset="./79f2c0541213829c0270a4f9f3de703b.png, ./79f2c0541213829c0270a4f9f3de703b.png 1.5x, ./79f2c0541213829c0270a4f9f3de703b.png 2x"
        data-sizes="auto"
        alt="./79f2c0541213829c0270a4f9f3de703b.png"
        title="image-20211003105839184" /></p>
<h2 id="43-链路虚拟化mpls">43 链路虚拟化：MPLS</h2>
<h3 id="431-mpls-概述--标签分发">43.1 MPLS 概述 —— 标签分发</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./098366890c8e3f21ccc83d78da946a05.png"
        data-srcset="./098366890c8e3f21ccc83d78da946a05.png, ./098366890c8e3f21ccc83d78da946a05.png 1.5x, ./098366890c8e3f21ccc83d78da946a05.png 2x"
        data-sizes="auto"
        alt="./098366890c8e3f21ccc83d78da946a05.png"
        title="image-20211003110011423" /></p>
<h2 id="44-数据中心网络">44 数据中心网络</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4a5ba820cdb8ac05396c79a6c685549f.png"
        data-srcset="./4a5ba820cdb8ac05396c79a6c685549f.png, ./4a5ba820cdb8ac05396c79a6c685549f.png 1.5x, ./4a5ba820cdb8ac05396c79a6c685549f.png 2x"
        data-sizes="auto"
        alt="./4a5ba820cdb8ac05396c79a6c685549f.png"
        title="image-20211003110123038" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./ba051fa269cc76f156161a27cb188ae5.png"
        data-srcset="./ba051fa269cc76f156161a27cb188ae5.png, ./ba051fa269cc76f156161a27cb188ae5.png 1.5x, ./ba051fa269cc76f156161a27cb188ae5.png 2x"
        data-sizes="auto"
        alt="./ba051fa269cc76f156161a27cb188ae5.png"
        title="image-20211003110142423" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./243dbef870b3f11c5956fbf89c51415a.png"
        data-srcset="./243dbef870b3f11c5956fbf89c51415a.png, ./243dbef870b3f11c5956fbf89c51415a.png 1.5x, ./243dbef870b3f11c5956fbf89c51415a.png 2x"
        data-sizes="auto"
        alt="./243dbef870b3f11c5956fbf89c51415a.png"
        title="image-20211003110203396" /></p>
<h2 id="45-a-day-in-the-life-of-web-request">45 a day in the life of web request</h2>
<p>回顾: 页面请求的历程</p>
<ul>
<li>Top-down 的协议栈旅程结束了!
<ul>
<li>应用层、运输层、网络层和链路层</li>
</ul>
</li>
<li>以一个 web 页面请求的例子: 综述!
<ul>
<li>目标: 标示、回顾和理解涉及到的协议(所有层次 )，以一个看似简单的场景: 请求 www 页面</li>
<li>场景：学生在校园启动一台笔记本电脑：请求和接 受www.google.com</li>
</ul>
</li>
</ul>
<h3 id="451-日常场景">45.1 日常场景</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./fb13855f02b6bfbf1e94bf489f2fede4.png"
        data-srcset="./fb13855f02b6bfbf1e94bf489f2fede4.png, ./fb13855f02b6bfbf1e94bf489f2fede4.png 1.5x, ./fb13855f02b6bfbf1e94bf489f2fede4.png 2x"
        data-sizes="auto"
        alt="./fb13855f02b6bfbf1e94bf489f2fede4.png"
        title="image-20211003110344335" /></p>
<h3 id="452-日常场景-连接到互联网">45.2 日常场景：… 连接到互联网</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b26ff22d374b08b4793c634223f1aa60.png"
        data-srcset="./b26ff22d374b08b4793c634223f1aa60.png, ./b26ff22d374b08b4793c634223f1aa60.png 1.5x, ./b26ff22d374b08b4793c634223f1aa60.png 2x"
        data-sizes="auto"
        alt="./b26ff22d374b08b4793c634223f1aa60.png"
        title="image-20211003111137748" /></p>
<ul>
<li>
<p>笔记本需要一个 IP 地址，第一跳路由器的 IP 地址，DNS 的地址:采用 DHCP</p>
</li>
<li>
<p>DHCP 请求被封装在 UDP 中，封装在 IP，封装在 802.3 以太网帧中</p>
</li>
<li>
<p>以太网的帧在 LAN 上广播
(dest: FFFFFFFFFFFF)，被运行中的 DHCP 服务器接收到</p>
</li>
<li>
<p>以太网帧中解封装 IP 分组，解封装 UDP，解封装 DHCP</p>
</li>
<li>
<p>DHCP 服务器生成 DHCPACK 包括客户端 IP 地址，第一跳路由器 P 地址和 DNS 名字服务器地址</p>
</li>
<li>
<p>在 DHCP 服务器封装，帧通过 LAN 转发(交换机学习)在客户端段解封装</p>
</li>
<li>
<p>客户端接收 DHCP ACK 应答</p>
</li>
</ul>
<p>客户端有了 IP 地址，知道了 DNS 域名服务器的名字和 IP 地址 第一跳路由器的 IP 地址</p>
<h3 id="453-日常场景-arp-dns-之前-http-之前">45.3 日常场景…… ARP (DNS 之前, HTTP 之前)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./085e0ea1d27f0875d9489939c21608a7.png"
        data-srcset="./085e0ea1d27f0875d9489939c21608a7.png, ./085e0ea1d27f0875d9489939c21608a7.png 1.5x, ./085e0ea1d27f0875d9489939c21608a7.png 2x"
        data-sizes="auto"
        alt="./085e0ea1d27f0875d9489939c21608a7.png"
        title="image-20211003111146617" /></p>
<ul>
<li>在发送 HTTP request 请求之前, 需要知道www.google.com的IP地 址: DNS</li>
<li>DNS 查询被创建，封装在 UDP 段中 ，封装在 IP 数据报中，封装在以 太网的帧中. 将帧传递给路由器 ，但是需要知道路由器的接口： MAC 地址：ARP</li>
<li>ARP 查询广播，被路由器接收， 路由器用 ARP 应答，给出其 IP 地 址某个端口的 MAC 地址</li>
<li>客户端现在知道第一跳路由器 MAC 地址，所以可以发送 DNS 查 询帧了</li>
</ul>
<h3 id="454-日常场景使用-dns">45.4 日常场景：使用 DNS</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3b7237e975cc965122f4a931c1d3480e.png"
        data-srcset="./3b7237e975cc965122f4a931c1d3480e.png, ./3b7237e975cc965122f4a931c1d3480e.png 1.5x, ./3b7237e975cc965122f4a931c1d3480e.png 2x"
        data-sizes="auto"
        alt="./3b7237e975cc965122f4a931c1d3480e.png"
        title="image-20211003111215380" /></p>
<ul>
<li>包含了 DNS 查询的 IP 数据报 通过 LAN 交换机转发，从客 户端到第一跳路由器</li>
<li>IP 数据报被转发，从校园到达 comcast 网络，路由(路由表被 RIP，OSPF，IS-IS 和/或 BGP 协 议创建)到 DNS 服务器</li>
<li>被 DNS 服务器解封装</li>
<li>DNS 服务器回复给客户端： <a href="https://www.google.com" target="_blank" rel="noopener noreffer">www.google.com</a>的IP地址</li>
</ul>
<h3 id="455-日常场景-tcp-连接携带-http-报文">45.5 日常场景： …TCP 连接携带 HTTP 报文</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./02daf96751a2604c71b094017a0d8724.png"
        data-srcset="./02daf96751a2604c71b094017a0d8724.png, ./02daf96751a2604c71b094017a0d8724.png 1.5x, ./02daf96751a2604c71b094017a0d8724.png 2x"
        data-sizes="auto"
        alt="./02daf96751a2604c71b094017a0d8724.png"
        title="image-20211003111254982" /></p>
<ul>
<li>为了发送 HTTP 请求，客户端打开到达 web 服务器的 TCP socket</li>
<li>TCP SYN 段(3 次握手的第 1 次握手)域间路由到 web 服务器</li>
<li>web 服务器用 TCP SYNACK 应答(3 次握手的第 2 次握手)</li>
<li>TCP 连接建立了!</li>
</ul>
<h4 id="4551-日常场景--http-请求和应答">45.5.1 日常场景： …… HTTP 请求和应答</h4>
<ul>
<li>HTTP 请求发送到 TCPsocket 中</li>
<li>IP 数据报包含 HTTP 请求，最终路由到www.google.com</li>
<li>web 服务器用 HTTP 应答回应(包括请求的页面)</li>
<li>IP 数据报包含 HTTP 应答最后被路由到客户端</li>
</ul>
<h2 id="46-第-6-章总结">46 第 6 章：总结</h2>
<ul>
<li>
<p>数据链路层服务背后的原理:</p>
<ul>
<li>检错、纠错</li>
<li>共享广播式信道：多路访问</li>
<li>链路编址</li>
</ul>
</li>
<li>
<p>各种链路层技术的实例和实现</p>
<ul>
<li>Ethernet</li>
<li>交换式 LANS, VLANs</li>
<li>虚拟成链路层的网络: MPLS</li>
</ul>
</li>
<li>
<p>综合：一个 web 页面请求的日常场景</p>
</li>
<li>
<p>自上而下的协议栈的旅行<strong>结束</strong>了 (除了物理层)</p>
</li>
<li>
<p>坚实地理解了网络的原理和实践</p>
</li>
<li>
<p>…… 可以在这里停一下 … … 但是仍然还有很多有趣的话题!</p>
<ul>
<li>无线网络</li>
<li>多媒体</li>
<li>网络安全</li>
</ul>
</li>
</ul>
<h1 id="网络安全-cyber-security">网络安全 cyber security</h1>
<h2 id="47-什么是网络安全">47 什么是网络安全？</h2>
<p><strong>机密性</strong>: 只有发送方和预订的接收方能否理解传输的报文内容</p>
<ul>
<li>发送方加密报文</li>
<li>接收方解密报文</li>
</ul>
<p><strong>认证</strong>: 发送方和接收方需要<strong>确认对方的身份</strong></p>
<p><strong>报文完整性</strong>: 发送方、接受方需要<strong>确认报文在传输的过程中或者事后没有被改变</strong></p>
<p><strong>访问控制和服务的可用性</strong>: 服务可以接入 以及 对用户而言是可用的</p>
<h2 id="48-朋友和敌人-alice-bob-trudy">48 朋友和敌人: Alice, Bob, Trudy</h2>
<p>网络安全世界比较著名的模型</p>
<ul>
<li>Bob, Alice (lovers!) 需要安全的通信</li>
<li>Trudy (intruder) 可以截获，删除和增加报文</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b22669a9f18afb3ac896a3470dacef2d.png"
        data-srcset="./b22669a9f18afb3ac896a3470dacef2d.png, ./b22669a9f18afb3ac896a3470dacef2d.png 1.5x, ./b22669a9f18afb3ac896a3470dacef2d.png 2x"
        data-sizes="auto"
        alt="./b22669a9f18afb3ac896a3470dacef2d.png"
        title="image-20211003150436208" /></p>
<h3 id="481-网络中的坏蛋">48.1 网络中的坏蛋</h3>
<p>Q: “bad guy”可以干什么?</p>
<p>A: 很多!</p>
<ul>
<li>窃听: 截获报文</li>
<li>插入：在连接上插入报文</li>
<li>伪装: 可以在分组的源地址写上伪装的地址</li>
<li>劫持: 将发送方或者接收方踢出，接管连接</li>
<li>拒绝服务: 阻止服务被其他正常用户使用 (e.g.,通过 对资源的过载使用)</li>
<li>…</li>
</ul>
<h3 id="482-谁有可能是-bob-alice">48.2 谁有可能是 Bob, Alice?</h3>
<ul>
<li>… 现实世界中的 Bobs 和 Alices!</li>
<li>电子交易中的 Web browser/server (e.g.,在线 购买)</li>
<li>在线银行的 client/server </li>
<li>DNS servers</li>
<li>路由信息的交换</li>
<li>其它例子?</li>
</ul>
<h2 id="49-加密原理">49 加密原理</h2>
<h3 id="491-加密语言">49.1 加密语言</h3>
<ul>
<li>plaintext 纯文本
ciphertext 密文</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b508cc1fc1735198e117130f3d45f103.png"
        data-srcset="./b508cc1fc1735198e117130f3d45f103.png, ./b508cc1fc1735198e117130f3d45f103.png 1.5x, ./b508cc1fc1735198e117130f3d45f103.png 2x"
        data-sizes="auto"
        alt="./b508cc1fc1735198e117130f3d45f103.png"
        title="image-20211003150803167" /></p>
<ul>
<li>
<p>对称密钥密码学: 发送方和接收方的密钥相同</p>
</li>
<li>
<p>公开密钥密码学: 发送方使用接收方的公钥进行加密，接收 方使用自己的私钥进行解密</p>
</li>
</ul>
<h3 id="492-对称密钥加密">49.2 对称密钥加密</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./df617f46ccc5aa74ce318583be204a45.png"
        data-srcset="./df617f46ccc5aa74ce318583be204a45.png, ./df617f46ccc5aa74ce318583be204a45.png 1.5x, ./df617f46ccc5aa74ce318583be204a45.png 2x"
        data-sizes="auto"
        alt="./df617f46ccc5aa74ce318583be204a45.png"
        title="image-20211003150833540" /></p>
<p>对称密钥密码: Bob 和 Alice 共享一个对称式的密钥: K</p>
<ul>
<li>e.g., 密钥在单码替换加密方法中是替换模式</li>
<li>Q: 但是 Bob 和 Alice 如何就这个密钥达成一致呢?</li>
</ul>
<p>替换密码: 将一个事情换成另外一个事情</p>
<ul>
<li><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./77e9e37c04da6753be4ced1126e8f7e2.png"
        data-srcset="./77e9e37c04da6753be4ced1126e8f7e2.png, ./77e9e37c04da6753be4ced1126e8f7e2.png 1.5x, ./77e9e37c04da6753be4ced1126e8f7e2.png 2x"
        data-sizes="auto"
        alt="./77e9e37c04da6753be4ced1126e8f7e2.png"
        title="image-20211003153247440" /></li>
</ul>
<p>Q: 破解这个密码的强度?</p>
<ul>
<li>brute force (how hard?)</li>
<li>other?</li>
</ul>
<h3 id="493-对称密钥加密学-des">49.3 对称密钥加密学: DES</h3>
<p><strong>DES: Data Encryption Standard</strong></p>
<ul>
<li>US 加密标准[NIST 1993]</li>
<li>56-bit 对称密钥, 64-bit 明文输入</li>
<li>DES 有多安全?
<ul>
<li>DES 挑战: 56-bit 密钥加密的短语 (“Strong cryptography makes the world a safer place”) 被解密，用了 4 个月的时间</li>
<li>可能有后门</li>
</ul>
</li>
<li>使 DES 更安全:
<ul>
<li><strong>使用 3 个 key， 3 重 DES 运算</strong></li>
<li><strong>密文分组成串技术</strong></li>
</ul>
</li>
</ul>
<p>DES operation</p>
<p>初始替换
16 轮一样的函数应用 ，每一轮使用的不 同的 48bit 密钥
最终替换</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./98dcb128f8e5d1887ec5860fc3ac077b.png"
        data-srcset="./98dcb128f8e5d1887ec5860fc3ac077b.png, ./98dcb128f8e5d1887ec5860fc3ac077b.png 1.5x, ./98dcb128f8e5d1887ec5860fc3ac077b.png 2x"
        data-sizes="auto"
        alt="./98dcb128f8e5d1887ec5860fc3ac077b.png"
        title="image-20211003153512416" /></p>
<h3 id="494-块密码">49.4 块密码</h3>
<ul>
<li><strong>一个循环：一个 输入 bit 影响 8 个 输出 bit</strong></li>
<li><strong>多重循环: 每个输入比特影响所有的输出 bit</strong></li>
<li><strong>块密码：DES, 3DES, AES</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d32aea034c14a2f552e4ada66a32783a.png"
        data-srcset="./d32aea034c14a2f552e4ada66a32783a.png, ./d32aea034c14a2f552e4ada66a32783a.png 1.5x, ./d32aea034c14a2f552e4ada66a32783a.png 2x"
        data-sizes="auto"
        alt="./d32aea034c14a2f552e4ada66a32783a.png"
        title="image-20211003153728247" /></p>
<h3 id="495-aes-advanced-encryption-standard">49.5 AES: Advanced Encryption Standard</h3>
<ul>
<li><strong>新的对称密钥 NIST 标准(Nov. 2001) 用于替换 DES</strong></li>
<li><strong>数据 128bit 成组加密</strong></li>
<li><strong>128, 192, or 256 bit keys</strong></li>
<li><strong>穷尽法解密如果使用 1 秒钟破解 DES, 需要花 149 万亿年破解 AES</strong></li>
</ul>
<h3 id="496-密码块链">49.6 密码块链</h3>
<ul>
<li>密码块：如果输入 块重复，将会得到 相同的密文块</li>
<li>密码块链： 异或第 i 轮 输入 m(i), 与前一轮的密文, c(i-1) —— <strong>与之前所有的 输入和原文 都有关系</strong>
<ul>
<li>c(0) 明文传输到接收端</li>
<li>what happens in “HTTP/1.1” scenario from above?</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./623f23da7c27348db13ad23386f19918.png"
        data-srcset="./623f23da7c27348db13ad23386f19918.png, ./623f23da7c27348db13ad23386f19918.png 1.5x, ./623f23da7c27348db13ad23386f19918.png 2x"
        data-sizes="auto"
        alt="./623f23da7c27348db13ad23386f19918.png"
        title="image-20211003154039265" /></p>
<h3 id="497-公开密钥密码学">49.7 公开密钥密码学</h3>
<blockquote>
<p>对称密钥密码学</p>
<ul>
<li>需要发送方和接收方对共享式对称密钥达成一 致</li>
<li>Q: 但是他们如何第一次达成一致 (特别是他们永远不可能见面的情况下 )?</li>
</ul>
</blockquote>
<p><strong>公开密钥密码学</strong></p>
<ul>
<li><strong>完全不同的方法 [Diffie-Hellman76, RSA78]</strong></li>
<li><strong>发送方和接收方无需共享密钥</strong></li>
<li><strong>一个实体的公钥公诸于众</strong></li>
<li><strong>私钥只有他自己知道</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./623c38fb4d9d2c07a602b1bae6abc24f.png"
        data-srcset="./623c38fb4d9d2c07a602b1bae6abc24f.png, ./623c38fb4d9d2c07a602b1bae6abc24f.png 1.5x, ./623c38fb4d9d2c07a602b1bae6abc24f.png 2x"
        data-sizes="auto"
        alt="./623c38fb4d9d2c07a602b1bae6abc24f.png"
        title="image-20211003154754817" /></p>
<h3 id="498-公开密钥加密算法">49.8 公开密钥加密算法</h3>
<p>要求:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./a8d81eecbfde766273f46e88057cf740.png"
        data-srcset="./a8d81eecbfde766273f46e88057cf740.png, ./a8d81eecbfde766273f46e88057cf740.png 1.5x, ./a8d81eecbfde766273f46e88057cf740.png 2x"
        data-sizes="auto"
        alt="./a8d81eecbfde766273f46e88057cf740.png"
        title="image-20211003154439175" /></p>
<h3 id="499-rsa-选择密钥">49.9 RSA: 选择密钥</h3>
<p><strong>RSA: Rivest, Shamir, Adelson algorithm</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./421719aba0abff0179bd666a462026df.png"
        data-srcset="./421719aba0abff0179bd666a462026df.png, ./421719aba0abff0179bd666a462026df.png 1.5x, ./421719aba0abff0179bd666a462026df.png 2x"
        data-sizes="auto"
        alt="./421719aba0abff0179bd666a462026df.png"
        title="image-20211003155140347" /></p>
<h3 id="4910-rsa-加密解密">49.10 RSA: 加密,解密</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9ce89ba5e4b74cac4afa4672fbae177e.png"
        data-srcset="./9ce89ba5e4b74cac4afa4672fbae177e.png, ./9ce89ba5e4b74cac4afa4672fbae177e.png 1.5x, ./9ce89ba5e4b74cac4afa4672fbae177e.png 2x"
        data-sizes="auto"
        alt="./9ce89ba5e4b74cac4afa4672fbae177e.png"
        title="image-20211003155309450" /></p>
<h3 id="4911-rsa-为什么">49.11 RSA: 为什么</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./aa426af7048ce955840952bfe602555a.png"
        data-srcset="./aa426af7048ce955840952bfe602555a.png, ./aa426af7048ce955840952bfe602555a.png 1.5x, ./aa426af7048ce955840952bfe602555a.png 2x"
        data-sizes="auto"
        alt="./aa426af7048ce955840952bfe602555a.png"
        title="image-20211003155357026" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./86564a91b032c48c57c8e48136442429.png"
        data-srcset="./86564a91b032c48c57c8e48136442429.png, ./86564a91b032c48c57c8e48136442429.png 1.5x, ./86564a91b032c48c57c8e48136442429.png 2x"
        data-sizes="auto"
        alt="./86564a91b032c48c57c8e48136442429.png"
        title="image-20211003155402400" /></p>
<h3 id="4912-rsa-例子">49.12 RSA 例子:</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2e8804d0370220b17f412f8fcbd19193.png"
        data-srcset="./2e8804d0370220b17f412f8fcbd19193.png, ./2e8804d0370220b17f412f8fcbd19193.png 1.5x, ./2e8804d0370220b17f412f8fcbd19193.png 2x"
        data-sizes="auto"
        alt="./2e8804d0370220b17f412f8fcbd19193.png"
        title="image-20211003155453495" /></p>
<h3 id="4913-rsa-数字签名--先解密私钥-在加密公钥-确认身份">49.13 RSA: 数字签名 —— 先解密(私钥) 在加密(公钥) 确认身份</h3>
<p>下面的特性将在后面非常有用</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./037863f661c81846509d4f8eb16aaff5.png"
        data-srcset="./037863f661c81846509d4f8eb16aaff5.png, ./037863f661c81846509d4f8eb16aaff5.png 1.5x, ./037863f661c81846509d4f8eb16aaff5.png 2x"
        data-sizes="auto"
        alt="./037863f661c81846509d4f8eb16aaff5.png"
        title="image-20211003160213019" /></p>
<p>结果一致!</p>
<p>解密的几种类型</p>
<ul>
<li>加密算法已知，求密钥</li>
<li>加密算法和密钥均不知道</li>
<li>唯密文攻击</li>
<li>已知明文攻击
<ul>
<li>已经知道部分密文和明文的对应关系</li>
</ul>
</li>
<li>选择明文攻击
<ul>
<li>攻击者能够选择一段明文，并得到密文</li>
</ul>
</li>
</ul>
<h2 id="50-认证">50 认证</h2>
<ul>
<li>目标: Bob 需要 Alice 证明她的身份</li>
<li>Protocol ap1.0: Alice 说“I am Alice”</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b6a66a763b35cd9058c51759deb9735f.png"
        data-srcset="./b6a66a763b35cd9058c51759deb9735f.png, ./b6a66a763b35cd9058c51759deb9735f.png 1.5x, ./b6a66a763b35cd9058c51759deb9735f.png 2x"
        data-sizes="auto"
        alt="./b6a66a763b35cd9058c51759deb9735f.png"
        title="image-20211003160558153" /></p>
<p>在网络上 Bob 看不到 Alice, 因此 Trudy 可以简单地声称她是 Alice</p>
<h3 id="501-认证重新尝试">50.1 认证:重新尝试</h3>
<ul>
<li><strong>Protocol ap2.0: Alice 说 “I am Alice” ，在她发送的 IP 数据包 中包括了她的 IP 地址</strong>
<ul>
<li><strong>Trudy 可以生成一 个分组，包括伪造 的 Alice 的地址</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./0aff86179360d19b8c813304c6efba73.png"
        data-srcset="./0aff86179360d19b8c813304c6efba73.png, ./0aff86179360d19b8c813304c6efba73.png 1.5x, ./0aff86179360d19b8c813304c6efba73.png 2x"
        data-sizes="auto"
        alt="./0aff86179360d19b8c813304c6efba73.png"
        title="image-20211003160759410" /></p>
<ul>
<li><strong>Protocol ap3.0: Alice 说 “I am Alice” ，而且传送她的密码来证明.</strong>
<ul>
<li>重放攻击 playback attack: Trudy 记录 Alice 的 分组，事后向 Bob 重放</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4e4a8a821292b506c34057a9794690a0.png"
        data-srcset="./4e4a8a821292b506c34057a9794690a0.png, ./4e4a8a821292b506c34057a9794690a0.png 1.5x, ./4e4a8a821292b506c34057a9794690a0.png 2x"
        data-sizes="auto"
        alt="./4e4a8a821292b506c34057a9794690a0.png"
        title="image-20211003160937998" /></p>
<ul>
<li>
<p><strong>Protocol ap3.1: Alice 说 “I am Alice” ，而且传送她的加密之后的密码来证明</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./56e8e37caf0e63bfa9f3e575d97caf7c.png"
        data-srcset="./56e8e37caf0e63bfa9f3e575d97caf7c.png, ./56e8e37caf0e63bfa9f3e575d97caf7c.png 1.5x, ./56e8e37caf0e63bfa9f3e575d97caf7c.png 2x"
        data-sizes="auto"
        alt="./56e8e37caf0e63bfa9f3e575d97caf7c.png"
        title="image-20211003162002392" /></p>
</li>
</ul>
<h3 id="502-目标-避免重放攻击">50.2 目标: 避免重放攻击</h3>
<ul>
<li><strong>Nonce: 一生只用一次的整数 ®</strong> —— <strong>一次性随机数(nonce):一个生命周期内只用 1 次的数 R.</strong></li>
<li><strong>ap4.0: 为了证明 Alice 的活跃性, Bob 发送给 Alice 一个 nonce, R. Alice 必须返回加密之后的 R，使用双方约定好的 key</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7d76d4d6b1bf2086267d7599df375bd9.png"
        data-srcset="./7d76d4d6b1bf2086267d7599df375bd9.png, ./7d76d4d6b1bf2086267d7599df375bd9.png 1.5x, ./7d76d4d6b1bf2086267d7599df375bd9.png 2x"
        data-sizes="auto"
        alt="./7d76d4d6b1bf2086267d7599df375bd9.png"
        title="image-20211003161055230" /></p>
<p>这个协议的缺点是需要共享秘钥！</p>
<h3 id="503-认证-ap50">50.3 认证: ap5.0</h3>
<p>ap4.0 需要双方共享一个对称式的密钥</p>
<ul>
<li>是否可以通过公开密钥技术进行认证呢?</li>
</ul>
<p>ap5.0: 使用 nonce,公开密钥加密技术</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./f13c43087ed70a40df2e0c8d9ebe4fa3.png"
        data-srcset="./f13c43087ed70a40df2e0c8d9ebe4fa3.png, ./f13c43087ed70a40df2e0c8d9ebe4fa3.png 1.5x, ./f13c43087ed70a40df2e0c8d9ebe4fa3.png 2x"
        data-sizes="auto"
        alt="./f13c43087ed70a40df2e0c8d9ebe4fa3.png"
        title="image-20211003162046298" /></p>
<h3 id="504-ap50-安全漏洞--中间攻击">50.4 ap5.0: 安全漏洞 —— 中间攻击</h3>
<p>中间攻击: Trudy 在 Alice (to Bob)和 Bob 之间 (to Alice)</p>
<p><strong>Trudy 用自己的私钥加密 R</strong>
<strong>传给 Bob 公钥</strong></p>
<p><strong>Trudy 截获 Alice 的信息 和 公钥，用 Alice 的 公钥 解密 她的 私钥</strong></p>
<p><strong>Bob 与 Alice 之间的信息全被 Trudy 截获</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./81e654fbdc56f03a1535ceec3ed1a855.png"
        data-srcset="./81e654fbdc56f03a1535ceec3ed1a855.png, ./81e654fbdc56f03a1535ceec3ed1a855.png 1.5x, ./81e654fbdc56f03a1535ceec3ed1a855.png 2x"
        data-sizes="auto"
        alt="./81e654fbdc56f03a1535ceec3ed1a855.png"
        title="image-20211003162123200" /></p>
<p><strong>1、怎样可靠地拿到一个实体的公钥 —— 公开密钥</strong>
<strong>2、拿到公钥之后怎样验证对方的身份 —— 利用对称密钥</strong></p>
<h2 id="51-报文完整性">51 报文完整性</h2>
<h3 id="511-ap50-安全漏洞">51.1 ap5.0: 安全漏洞</h3>
<p>中间攻击: Trudy 在 Alice (to Bob)和 Bob 之间 (to Alice)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./23285ff1a4270546b2123f70676cf636.png"
        data-srcset="./23285ff1a4270546b2123f70676cf636.png, ./23285ff1a4270546b2123f70676cf636.png 1.5x, ./23285ff1a4270546b2123f70676cf636.png 2x"
        data-sizes="auto"
        alt="./23285ff1a4270546b2123f70676cf636.png"
        title="image-20211003165035508" /></p>
<ul>
<li>难以检测:
<ul>
<li>Bob 收到了 Alice 发送的所有报文, 反之亦然. (e.g., so Bob, Alice 一个星期以后相见，回忆起以前的会话)</li>
<li>问题时 Trudy 也接收到了所有的报文!</li>
</ul>
</li>
</ul>
<h3 id="512-数字签名">51.2 数字签名</h3>
<p>数字签名类比于手写签名</p>
<ul>
<li>发送方 (Bob) 数字签署了文件, 前提是他(她)是文件 的拥有者/创建者.</li>
<li><strong>可验证性，不可伪造性，不可抵赖性</strong>
<ul>
<li>谁签署：接收方 (Alice)可以向他人证明 是 Bob, 而不是其他 人签署了这个文件 (包括 Alice)</li>
<li>签署了什么：这份文件，而不是其它文件</li>
</ul>
</li>
</ul>
<h3 id="513-简单的对ｍ的数字签名">51.3 简单的对ｍ的数字签名：</h3>
<ul>
<li><strong>Bob 使用他自己的私钥对 m 进行了签署 ，创建数字签名 KB (m)</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./cfc77db2108c656adb5bb3fbe890d28e.png"
        data-srcset="./cfc77db2108c656adb5bb3fbe890d28e.png, ./cfc77db2108c656adb5bb3fbe890d28e.png 1.5x, ./cfc77db2108c656adb5bb3fbe890d28e.png 2x"
        data-sizes="auto"
        alt="./cfc77db2108c656adb5bb3fbe890d28e.png"
        title="image-20211003165303684" /></p>
<h3 id="514-报文摘要">51.4 报文摘要</h3>
<p><strong>对长报文进行公开密钥加密 算法的实施需要耗费大量的时间</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./978b05b1fe40efa9c7d5a8f172c241dc.png"
        data-srcset="./978b05b1fe40efa9c7d5a8f172c241dc.png, ./978b05b1fe40efa9c7d5a8f172c241dc.png 1.5x, ./978b05b1fe40efa9c7d5a8f172c241dc.png 2x"
        data-sizes="auto"
        alt="./978b05b1fe40efa9c7d5a8f172c241dc.png"
        title="image-20211003165506312" /></p>
<ul>
<li>
<p><strong>Goal: 固定长度，容易计算的 “fingerprint”</strong></p>
<ul>
<li>对 m 使用散列函数 H，获得 固定长度的 报文摘要 H(m).</li>
</ul>
</li>
<li>
<p><strong>散列函数的特性：</strong></p>
<ul>
<li><strong>多对 1</strong></li>
<li><strong>结果固定长度</strong></li>
<li><strong>给定一个报文摘要 x, 反向计算出原报文在计算上是不可行的 x = H(m)</strong></li>
</ul>
</li>
<li>
<p>假设 Alice 收到报文 m, 以及数字签名 KB (m)</p>
</li>
<li>
<p>Alice 使用 Bob 的公钥 KB 对 KB (m)进行验证， 判断 KB (KB (m) ) = m 是否成立.</p>
</li>
<li>
<p>如 KB (KB (m) ) = m 成立, 那么签署这个文件的人一定拥有 Bob 的私钥. + + - - -</p>
</li>
</ul>
<p><strong>Alice 可以验证:</strong> —— 只有 Bob 有自己的私钥</p>
<ul>
<li>Bob 签署了 m.</li>
<li>不是其他人签署了 m.</li>
<li>Bob 签署了 m 而不是 m’.</li>
</ul>
<p><strong>不可抵赖性:</strong></p>
<ul>
<li>Alice 可以拿着 m,以及数字签名 KB (m)到法庭上， 来证明是 Bob 签署了这个文件 m.</li>
</ul>
<h3 id="515-internet-校验和-弱的散列函数-容易冲突">51.5 Internet 校验和: 弱的散列函数 (容易冲突)</h3>
<p>Internet 校验和拥有一些散列函数的特性:</p>
<ul>
<li>产生报文 m 的固定长度的摘要 (16-bit sum)</li>
<li>多对 1 的</li>
</ul>
<p>但是给定一个散列值，很容易计算出另外一个报文具有同样的散列值:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./87a79738dc2d0d63515b039a683bb6db.png"
        data-srcset="./87a79738dc2d0d63515b039a683bb6db.png, ./87a79738dc2d0d63515b039a683bb6db.png 1.5x, ./87a79738dc2d0d63515b039a683bb6db.png 2x"
        data-sizes="auto"
        alt="./87a79738dc2d0d63515b039a683bb6db.png"
        title="image-20211004154803194" /></p>
<h3 id="516-数字签名--对报文摘要进行数字签署">51.6 数字签名 = 对报文摘要进行数字签署</h3>
<p><strong>Bob 发送数字签名的报文:</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b148dbc11085dd14b91cd6dc680de4d3.png"
        data-srcset="./b148dbc11085dd14b91cd6dc680de4d3.png, ./b148dbc11085dd14b91cd6dc680de4d3.png 1.5x, ./b148dbc11085dd14b91cd6dc680de4d3.png 2x"
        data-sizes="auto"
        alt="./b148dbc11085dd14b91cd6dc680de4d3.png"
        title="image-20211004154826294" /></p>
<p><strong>Alice 校验签名和报文完整性:</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./958417ceefe72d88db4949321d595d99.png"
        data-srcset="./958417ceefe72d88db4949321d595d99.png, ./958417ceefe72d88db4949321d595d99.png 1.5x, ./958417ceefe72d88db4949321d595d99.png 2x"
        data-sizes="auto"
        alt="./958417ceefe72d88db4949321d595d99.png"
        title="image-20211004154853225" /></p>
<h2 id="52-密钥分发和证书">52 密钥分发和证书</h2>
<h3 id="521-散列函数算法">52.1 散列函数算法</h3>
<ul>
<li>MD5 散列函数(RFC 1321)被广泛地应用
<ul>
<li>4 个步骤计算出 128-bit 的报文摘要</li>
<li>给定一个任意的 128-bit 串 x, 很难构造出一个报文 m 具有相同的摘要 x.</li>
</ul>
</li>
<li>SHA-1 也被使用.
<ul>
<li>US 标准 [NIST, FIPS PUB 180-1]</li>
<li>160-bit 报文摘要</li>
</ul>
</li>
</ul>
<h3 id="522-可信赖中介">52.2 可信赖中介</h3>
<h4 id="5221-对称密钥问题">52.2.1 对称密钥问题</h4>
<ul>
<li>相互通信的实体如何分享对
称式的密钥?</li>
</ul>
<p>解决办法: —— 可信赖中介</p>
<ul>
<li><strong>trusted key distribution center (KDC) 在实体之间扮演可信赖中介的角色</strong></li>
</ul>
<h4 id="5222-公共密钥问题--可信赖的-ca-证书">52.2.2 公共密钥问题 —— 可信赖的 CA 证书</h4>
<ul>
<li>当 Alice 获得 Bob 的公钥 (from web site, e-mail, diskette), 她如何知道就 是 Bob 的 public key, 而不 是 Trudy 的?</li>
</ul>
<p>解决办法:</p>
<ul>
<li><strong>可信赖的 certification authority (CA)</strong></li>
</ul>
<h3 id="523-key-distribution-center-kdc">52.3 Key Distribution Center (KDC)</h3>
<ul>
<li><strong>Alice, Bob 需要分享对称式密钥。</strong></li>
<li><strong>KDC: 服务器和每一个注册用户都分享一个对称式的密钥 (many users)</strong></li>
<li><strong>Alice, Bob 在和 KDC 通信的时候，知道他们自己的对称式 密钥 KA-KDC、KB-KDC.</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./d7f9bd16c15a1130d14d07e19b0b1730.png"
        data-srcset="./d7f9bd16c15a1130d14d07e19b0b1730.png, ./d7f9bd16c15a1130d14d07e19b0b1730.png 1.5x, ./d7f9bd16c15a1130d14d07e19b0b1730.png 2x"
        data-sizes="auto"
        alt="./d7f9bd16c15a1130d14d07e19b0b1730.png"
        title="image-20211004155311056" /></p>
<p><strong>共享 R1，使用 R1 作为对称式的会话密钥</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./27a8fd8d09ea469484628005835eb847.png"
        data-srcset="./27a8fd8d09ea469484628005835eb847.png, ./27a8fd8d09ea469484628005835eb847.png 1.5x, ./27a8fd8d09ea469484628005835eb847.png 2x"
        data-sizes="auto"
        alt="./27a8fd8d09ea469484628005835eb847.png"
        title="image-20211004160353350" /></p>
<h3 id="524-certification-authorities">52.4 Certification Authorities</h3>
<ul>
<li>
<p><strong>Certification authority (CA): 将每一个注册实体 E 和他的公钥捆绑.</strong></p>
</li>
<li>
<p>E (person, router) 到 CA 那里注册他的公钥.</p>
<ul>
<li>E 提供给 CA，自己身份的证据 “proof of identity”</li>
<li>CA 创建一个证书，捆绑了 实体信息和他的公钥.</li>
<li><strong>Certificate 包括了 E 的公钥，而且是被 CA 签署的(被 CA 用自己的私钥加了密的) – CA 说 “this is E’s public key”</strong></li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./743ff5e4e5e8172241f4d8379708f291.png"
        data-srcset="./743ff5e4e5e8172241f4d8379708f291.png, ./743ff5e4e5e8172241f4d8379708f291.png 1.5x, ./743ff5e4e5e8172241f4d8379708f291.png 2x"
        data-sizes="auto"
        alt="./743ff5e4e5e8172241f4d8379708f291.png"
        title="image-20211004160749518" /></p>
<p>当 Alice 需要拿到 Bob 公钥</p>
<ul>
<li><strong>获得 Bob 的证书 certificate (从 Bob 或者其他地方).</strong></li>
<li><strong>对 Bob 的证书，使用 CA 的公钥来验证</strong></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b721b70e204c00001502d0b2a21e2028.png"
        data-srcset="./b721b70e204c00001502d0b2a21e2028.png, ./b721b70e204c00001502d0b2a21e2028.png 1.5x, ./b721b70e204c00001502d0b2a21e2028.png 2x"
        data-sizes="auto"
        alt="./b721b70e204c00001502d0b2a21e2028.png"
        title="image-20211004160830345" /></p>
<h4 id="5241-证书包括">52.4.1 证书包括:</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./82310da3b6e95b1151b57ef877ebf8db.png"
        data-srcset="./82310da3b6e95b1151b57ef877ebf8db.png, ./82310da3b6e95b1151b57ef877ebf8db.png 1.5x, ./82310da3b6e95b1151b57ef877ebf8db.png 2x"
        data-sizes="auto"
        alt="./82310da3b6e95b1151b57ef877ebf8db.png"
        title="image-20211004160852343" /></p>
<h2 id="53-各个层次的安全性">53 各个层次的安全性</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./de998b454e7804554ffb8d78feb17a6d.png"
        data-srcset="./de998b454e7804554ffb8d78feb17a6d.png, ./de998b454e7804554ffb8d78feb17a6d.png 1.5x, ./de998b454e7804554ffb8d78feb17a6d.png 2x"
        data-sizes="auto"
        alt="./de998b454e7804554ffb8d78feb17a6d.png"
        title="image-20211004163043220" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./fc3a08e181457e4eb10d0967a362322c.png"
        data-srcset="./fc3a08e181457e4eb10d0967a362322c.png, ./fc3a08e181457e4eb10d0967a362322c.png 1.5x, ./fc3a08e181457e4eb10d0967a362322c.png 2x"
        data-sizes="auto"
        alt="./fc3a08e181457e4eb10d0967a362322c.png"
        title="image-20211004163051600" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./63049f233b3f2806ae51eb9c95ce9647.png"
        data-srcset="./63049f233b3f2806ae51eb9c95ce9647.png, ./63049f233b3f2806ae51eb9c95ce9647.png 1.5x, ./63049f233b3f2806ae51eb9c95ce9647.png 2x"
        data-sizes="auto"
        alt="./63049f233b3f2806ae51eb9c95ce9647.png"
        title="image-20211004163104288" /></p>
<h3 id="531-ssl">53.1 SSL</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./015e870ab8e26ed19c12b22494ca95be.png"
        data-srcset="./015e870ab8e26ed19c12b22494ca95be.png, ./015e870ab8e26ed19c12b22494ca95be.png 1.5x, ./015e870ab8e26ed19c12b22494ca95be.png 2x"
        data-sizes="auto"
        alt="./015e870ab8e26ed19c12b22494ca95be.png"
        title="image-20211004163120882" /></p>
<h3 id="532-ssl-3-阶段">53.2 SSL: 3 阶段</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6bfcc544437a2c98f31850d05daf775e.png"
        data-srcset="./6bfcc544437a2c98f31850d05daf775e.png, ./6bfcc544437a2c98f31850d05daf775e.png 1.5x, ./6bfcc544437a2c98f31850d05daf775e.png 2x"
        data-sizes="auto"
        alt="./6bfcc544437a2c98f31850d05daf775e.png"
        title="image-20211004163149121" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./b15d32b25796224e29d3f788d2d8c8a8.png"
        data-srcset="./b15d32b25796224e29d3f788d2d8c8a8.png, ./b15d32b25796224e29d3f788d2d8c8a8.png 1.5x, ./b15d32b25796224e29d3f788d2d8c8a8.png 2x"
        data-sizes="auto"
        alt="./b15d32b25796224e29d3f788d2d8c8a8.png"
        title="image-20211004163133733" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./561543e7e2bc26d5a8b6e53e8eab5054.png"
        data-srcset="./561543e7e2bc26d5a8b6e53e8eab5054.png, ./561543e7e2bc26d5a8b6e53e8eab5054.png 1.5x, ./561543e7e2bc26d5a8b6e53e8eab5054.png 2x"
        data-sizes="auto"
        alt="./561543e7e2bc26d5a8b6e53e8eab5054.png"
        title="image-20211004163207264" /></p>
<h3 id="533-ipsec-网络层次的安全性">53.3 IPsec: 网络层次的安全性</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./da37acb2e4eec86903c99adee0f736a8.png"
        data-srcset="./da37acb2e4eec86903c99adee0f736a8.png, ./da37acb2e4eec86903c99adee0f736a8.png 1.5x, ./da37acb2e4eec86903c99adee0f736a8.png 2x"
        data-sizes="auto"
        alt="./da37acb2e4eec86903c99adee0f736a8.png"
        title="image-20211004163238244" /></p>
<h3 id="534-esp-协议">53.4 ESP 协议</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9d566df9192e3deb225f60a7edb9764f.png"
        data-srcset="./9d566df9192e3deb225f60a7edb9764f.png, ./9d566df9192e3deb225f60a7edb9764f.png 1.5x, ./9d566df9192e3deb225f60a7edb9764f.png 2x"
        data-sizes="auto"
        alt="./9d566df9192e3deb225f60a7edb9764f.png"
        title="image-20211004163251925" /></p>
<p>8.6 访问控制：防火墙</p>
<p>8.7 攻击和对策</p>
<h2 id="54-网络安全-总结">54 网络安全 (总结)</h2>
<ul>
<li>基本原理
<ul>
<li>加密 (对称和公开)</li>
<li>报文完整性</li>
<li>端节点的认证(鉴别)</li>
</ul>
</li>
<li>在多种安全场景中使用
<ul>
<li>安全电子邮件</li>
<li>安全传输层 (SSL)</li>
<li>IP sec</li>
<li>802.11</li>
</ul>
</li>
<li><strong>运行中的安全性: firewalls and IDS</strong></li>
</ul>
<h1 id="无线和移动网络">无线和移动网络</h1>
<p>Wireless and mobile network</p>
<h1 id="多媒体网络">多媒体网络</h1>
<p>Multimedia network</p>
<h1 id="网络管理">网络管理</h1>
<p>Network management</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info"><div class="post-info-tag"><span><a href="/tags/network/">network</a>
                </span><span><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95e7-%E7%AC%94%E8%AE%B0/">计算机网络-自顶向下方法E7-笔记</a>
                </span></div><div class="post-info-line"><div class="post-info-mod">
                <span>更新于 2022-06-17</span>
            </div><div class="post-info-mod"></div>
        </div></div><div class="post-nav"><a href="/posts/database%E6%9C%AA%E5%A4%84%E7%90%86/mysql/blog_cut/mysql/transaction-isolation-level/" class="prev" rel="prev" title="事务隔离级别(图文详解)"><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
            <a href="/posts/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" class="next" rel="next" title="计算机网络常见面试题">Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div></article></div>
            </main>
            <footer class="footer"><div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.112.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/khusika/FeelIt" target="_blank" rel="noopener noreffer" title="FeelIt 1.0.1"><i class="fas fa-hand-holding-heart fa-fw"></i> FeelIt</a>
        </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/"></a></span></div>
</div>
</footer>
        </div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-chevron-up fa-fw"></i>
            </a></div><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script src="/lib/autocomplete/autocomplete.min.js"></script><script src="/lib/lunr/lunr.min.js"></script><script src="/lib/lunr/lunr.stemmer.support.min.js"></script><script src="/lib/lunr/lunr.zh.min.js"></script><script src="/lib/lazysizes/lazysizes.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script src="/js/theme.min.js"></script></body></html>
